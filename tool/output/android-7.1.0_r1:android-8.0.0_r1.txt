Find a silently evolved API code:android.net.Uri.checkFileUriExposed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * If this is a {@code file://} Uri, it will be reported to
 * {@link StrictMode}.
 *
 * @hide
 */

Body of Frist Method:
{
    if ("file".equals(getScheme()) && !getPath().startsWith("/system/")) {
        StrictMode.onFileUriExposed(this, location);
    }
}
Body of Second Method:
{
    if ("file".equals(getScheme()) && (getPath() != null) && !getPath().startsWith("/system/")) {
        StrictMode.onFileUriExposed(this, location);
    }
}
------------------------
Find a silently evolved API code:android.renderscript.ScriptIntrinsicConvolve5x5.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Supported elements types are {@link Element#U8}, {@link
 * Element#U8_2}, {@link Element#U8_3}, {@link Element#U8_4},
 * {@link Element#F32}, {@link Element#F32_2}, {@link
 * Element#F32_3}, and {@link Element#F32_4}.
 *
 * <p> The default coefficients are:
 * <code>
 * <p> [ 0,  0,  0,  0,  0  ]
 * <p> [ 0,  0,  0,  0,  0  ]
 * <p> [ 0,  0,  1,  0,  0  ]
 * <p> [ 0,  0,  0,  0,  0  ]
 * <p> [ 0,  0,  0,  0,  0  ]
 * </code>
 *
 * @param rs The RenderScript context
 * @param e Element type for intputs and outputs
 *
 * @return ScriptIntrinsicConvolve5x5
 */

Body of Frist Method:
{
    if (!e.isCompatible(Element.U8(rs)) && !e.isCompatible(Element.U8_2(rs)) && !e.isCompatible(Element.U8_3(rs)) && !e.isCompatible(Element.U8_4(rs)) && !e.isCompatible(Element.F32(rs)) && !e.isCompatible(Element.F32_2(rs)) && !e.isCompatible(Element.F32_3(rs)) && !e.isCompatible(Element.F32_4(rs))) {
        throw new RSIllegalArgumentException("Unsuported element type.");
    }
    long id = rs.nScriptIntrinsicCreate(4, e.getID(rs));
    return new ScriptIntrinsicConvolve5x5(id, rs);
}
Body of Second Method:
{
    if (!e.isCompatible(Element.U8(rs)) && !e.isCompatible(Element.U8_2(rs)) && !e.isCompatible(Element.U8_3(rs)) && !e.isCompatible(Element.U8_4(rs)) && !e.isCompatible(Element.F32(rs)) && !e.isCompatible(Element.F32_2(rs)) && !e.isCompatible(Element.F32_3(rs)) && !e.isCompatible(Element.F32_4(rs))) {
        throw new RSIllegalArgumentException("Unsupported element type.");
    }
    long id = rs.nScriptIntrinsicCreate(4, e.getID(rs));
    return new ScriptIntrinsicConvolve5x5(id, rs);
}
------------------------
Find a silently evolved API code:android.graphics.Path.isEmpty:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the path is empty (contains no lines or curves)
 *
 * @return true if the path is empty (contains no lines or curves)
 */

Body of Frist Method:
{
    return native_isEmpty(mNativePath);
}
Body of Second Method:
{
    return nIsEmpty(mNativePath);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setClientCertificateAlias:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set Client certificate alias.
 *
 * <p> See the {@link android.security.KeyChain} for details on installing or choosing
 * a certificate
 * </p>
 * @param alias identifies the certificate
 * @hide
 */

Body of Frist Method:
{
    setFieldValue(CLIENT_CERT_KEY, alias, CLIENT_CERT_PREFIX);
    setFieldValue(PRIVATE_KEY_ID_KEY, alias, Credentials.USER_PRIVATE_KEY);
    // Also, set engine parameters
    if (TextUtils.isEmpty(alias)) {
        mFields.put(ENGINE_KEY, ENGINE_DISABLE);
        mFields.put(ENGINE_ID_KEY, EMPTY_VALUE);
    } else {
        mFields.put(ENGINE_KEY, ENGINE_ENABLE);
        mFields.put(ENGINE_ID_KEY, convertToQuotedString(ENGINE_ID_KEYSTORE));
    }
}
Body of Second Method:
{
    setFieldValue(CLIENT_CERT_KEY, alias, CLIENT_CERT_PREFIX);
    setFieldValue(PRIVATE_KEY_ID_KEY, alias, Credentials.USER_PRIVATE_KEY);
    // Also, set engine parameters
    if (TextUtils.isEmpty(alias)) {
        setFieldValue(ENGINE_KEY, ENGINE_DISABLE);
        setFieldValue(ENGINE_ID_KEY, "");
    } else {
        setFieldValue(ENGINE_KEY, ENGINE_ENABLE);
        setFieldValue(ENGINE_ID_KEY, ENGINE_ID_KEYSTORE);
    }
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.fillInNotifierBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set intent notifier Bundle based on service state.
 *
 * @param m intent notifier Bundle
 * @hide
 */

Body of Frist Method:
{
    m.putInt("voiceRegState", mVoiceRegState);
    m.putInt("dataRegState", mDataRegState);
    m.putInt("voiceRoamingType", mVoiceRoamingType);
    m.putInt("dataRoamingType", mDataRoamingType);
    m.putString("operator-alpha-long", mVoiceOperatorAlphaLong);
    m.putString("operator-alpha-short", mVoiceOperatorAlphaShort);
    m.putString("operator-numeric", mVoiceOperatorNumeric);
    m.putString("data-operator-alpha-long", mDataOperatorAlphaLong);
    m.putString("data-operator-alpha-short", mDataOperatorAlphaShort);
    m.putString("data-operator-numeric", mDataOperatorNumeric);
    m.putBoolean("manual", Boolean.valueOf(mIsManualNetworkSelection));
    m.putInt("radioTechnology", mRilVoiceRadioTechnology);
    m.putInt("dataRadioTechnology", mRilDataRadioTechnology);
    m.putBoolean("cssIndicator", mCssIndicator);
    m.putInt("networkId", mNetworkId);
    m.putInt("systemId", mSystemId);
    m.putInt("cdmaRoamingIndicator", mCdmaRoamingIndicator);
    m.putInt("cdmaDefaultRoamingIndicator", mCdmaDefaultRoamingIndicator);
    m.putBoolean("emergencyOnly", Boolean.valueOf(mIsEmergencyOnly));
    m.putBoolean("isDataRoamingFromRegistration", Boolean.valueOf(mIsDataRoamingFromRegistration));
    m.putBoolean("isUsingCarrierAggregation", Boolean.valueOf(mIsUsingCarrierAggregation));
}
Body of Second Method:
{
    m.putInt("voiceRegState", mVoiceRegState);
    m.putInt("dataRegState", mDataRegState);
    m.putInt("voiceRoamingType", mVoiceRoamingType);
    m.putInt("dataRoamingType", mDataRoamingType);
    m.putString("operator-alpha-long", mVoiceOperatorAlphaLong);
    m.putString("operator-alpha-short", mVoiceOperatorAlphaShort);
    m.putString("operator-numeric", mVoiceOperatorNumeric);
    m.putString("data-operator-alpha-long", mDataOperatorAlphaLong);
    m.putString("data-operator-alpha-short", mDataOperatorAlphaShort);
    m.putString("data-operator-numeric", mDataOperatorNumeric);
    m.putBoolean("manual", mIsManualNetworkSelection);
    m.putInt("radioTechnology", mRilVoiceRadioTechnology);
    m.putInt("dataRadioTechnology", mRilDataRadioTechnology);
    m.putBoolean("cssIndicator", mCssIndicator);
    m.putInt("networkId", mNetworkId);
    m.putInt("systemId", mSystemId);
    m.putInt("cdmaRoamingIndicator", mCdmaRoamingIndicator);
    m.putInt("cdmaDefaultRoamingIndicator", mCdmaDefaultRoamingIndicator);
    m.putBoolean("emergencyOnly", mIsEmergencyOnly);
    m.putBoolean("isDataRoamingFromRegistration", mIsDataRoamingFromRegistration);
    m.putBoolean("isUsingCarrierAggregation", mIsUsingCarrierAggregation);
    m.putInt("LteEarfcnRsrpBoost", mLteEarfcnRsrpBoost);
}
------------------------
Find a silently evolved API code:android.graphics.Shader.copyLocalMatrix:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mLocalMatrix != null) {
        final Matrix lm = new Matrix();
        getLocalMatrix(lm);
        dest.setLocalMatrix(lm);
    } else {
        dest.setLocalMatrix(null);
    }
}
Body of Second Method:
{
    dest.mLocalMatrix.set(mLocalMatrix);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.query:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#query ContentProvider.query}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        final Cursor cursor = mContentProvider.query(mPackageName, url, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        if (cursor == null) {
            return null;
        }
        if ("com.google.android.gms".equals(mPackageName)) {
            // They're casting to a concrete subclass, sigh
            return cursor;
        } else {
            return new CursorWrapperInner(cursor);
        }
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "url");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        final Cursor cursor = mContentProvider.query(mPackageName, uri, projection, queryArgs, remoteCancellationSignal);
        if (cursor == null) {
            return null;
        }
        return new CursorWrapperInner(cursor);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.content.ClipDescription.validate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mMimeTypes == null) {
        throw new NullPointerException("null mime types");
    }
    if (mMimeTypes.length <= 0) {
        throw new IllegalArgumentException("must have at least 1 mime type");
    }
    for (int i = 0; i < mMimeTypes.length; i++) {
        if (mMimeTypes[i] == null) {
            throw new NullPointerException("mime type at " + i + " is null");
        }
    }
}
Body of Second Method:
{
    if (mMimeTypes == null) {
        throw new NullPointerException("null mime types");
    }
    final int size = mMimeTypes.size();
    if (size <= 0) {
        throw new IllegalArgumentException("must have at least 1 mime type");
    }
    for (int i = 0; i < size; i++) {
        if (mMimeTypes.get(i) == null) {
            throw new NullPointerException("mime type at " + i + " is null");
        }
    }
}
------------------------
Find a silently evolved API code:android.app.backup.RestoreSession.getAvailableRestoreSets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Ask the current transport what the available restore sets are.
 *
 * @param observer a RestoreObserver object whose restoreSetsAvailable() method will
 * be called on the application's main thread in order to supply the results of
 * the restore set lookup by the backup transport.  This parameter must not be
 * null.
 * @return Zero on success, nonzero on error.  The observer's restoreSetsAvailable()
 * method will only be called if this method returned zero.
 */

Body of Frist Method:
{
    int err = -1;
    RestoreObserverWrapper obsWrapper = new RestoreObserverWrapper(mContext, observer);
    try {
        err = mBinder.getAvailableRestoreSets(obsWrapper);
    } catch (RemoteException e) {
        Log.d(TAG, "Can't contact server to get available sets");
    }
    return err;
}
Body of Second Method:
{
    return getAvailableRestoreSets(observer, null);
}
------------------------
Find a silently evolved API code:android.os.Looper.loop:COMMENT
Method Modifier: public      static      
Comment:/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */

Body of Frist Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        final long traceTag = me.mTraceTag;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        try {
            msg.target.dispatchMessage(msg);
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
Body of Second Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        final long traceTag = me.mTraceTag;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
        final long end;
        try {
            msg.target.dispatchMessage(msg);
            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (slowDispatchThresholdMs > 0) {
            final long time = end - start;
            if (time > slowDispatchThresholdMs) {
                Slog.w(TAG, "Dispatch took " + time + "ms on " + Thread.currentThread().getName() + ", h=" + msg.target + " cb=" + msg.callback + " msg=" + msg.what);
            }
        }
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getIdentity:COMMENT
Method Modifier: public      
Comment:/**
 * Get the identity
 * @return the identity
 */

Body of Frist Method:
{
    return getFieldValue(IDENTITY_KEY, "");
}
Body of Second Method:
{
    return getFieldValue(IDENTITY_KEY);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.restore:COMMENT
Method Modifier: public      
Comment:/**
 * This call balances a previous call to save(), and is used to remove all
 * modifications to the matrix/clip state since the last save call. It is
 * an error to call restore() more times than save() was called.
 */

Body of Frist Method:
{
    boolean throwOnUnderflow = !sCompatibilityRestore || !isHardwareAccelerated();
    native_restore(mNativeCanvasWrapper, throwOnUnderflow);
}
Body of Second Method:
{
    if (!nRestore(mNativeCanvasWrapper) && (!sCompatibilityRestore || !isHardwareAccelerated())) {
        throw new IllegalStateException("Underflow in restore - more restores than saves");
    }
}
------------------------
Find a silently evolved API code:android.service.voice.VoiceInteractionSession.getWindow:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the window being used to show the session's UI.
 */

Body of Frist Method:
{
    return mWindow;
}
Body of Second Method:
{
    ensureWindowCreated();
    return mWindow;
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.InputMethodImpl.showSoftInput:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a request by the system to show the soft input area.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "showSoftInput()");
    boolean wasVis = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
        // We have ignored BadTokenException here since Jelly Bean MR-2 (API Level 18).
        // We could ignore BadTokenException in InputMethodService#showWindow() instead,
        // but it may break assumptions for those who override #showWindow() that we can
        // detect errors in #showWindow() by checking BadTokenException.
        // TODO: Investigate its feasibility.  Update JavaDoc of #showWindow() of
        // whether it's OK to override #showWindow() or not.
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "showSoftInput()");
    boolean wasVis = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
        // We have ignored BadTokenException here since Jelly Bean MR-2 (API Level 18).
        // We could ignore BadTokenException in InputMethodService#showWindow() instead,
        // but it may break assumptions for those who override #showWindow() that we can
        // detect errors in #showWindow() by checking BadTokenException.
        // TODO: Investigate its feasibility.  Update JavaDoc of #showWindow() of
        // whether it's OK to override #showWindow() or not.
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, mStartInputToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.updateFullscreenMode:COMMENT
Method Modifier: public      
Comment:/**
 * Re-evaluate whether the input method should be running in fullscreen
 * mode, and update its UI if this has changed since the last time it
 * was evaluated.  This will call {@link #onEvaluateFullscreenMode()} to
 * determine whether it should currently run in fullscreen mode.  You
 * can use {@link #isFullscreenMode()} to determine if the input method
 * is currently running in fullscreen mode.
 */

Body of Frist Method:
{
    boolean isFullscreen = mShowInputRequested && onEvaluateFullscreenMode();
    boolean changed = mLastShowInputRequested != mShowInputRequested;
    if (mIsFullscreen != isFullscreen || !mFullscreenApplied) {
        changed = true;
        mIsFullscreen = isFullscreen;
        InputConnection ic = getCurrentInputConnection();
        if (ic != null)
            ic.reportFullscreenMode(isFullscreen);
        mFullscreenApplied = true;
        initialize();
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) mFullscreenArea.getLayoutParams();
        if (isFullscreen) {
            mFullscreenArea.setBackgroundDrawable(mThemeAttrs.getDrawable(com.android.internal.R.styleable.InputMethodService_imeFullscreenBackground));
            lp.height = 0;
            lp.weight = 1;
        } else {
            mFullscreenArea.setBackgroundDrawable(null);
            lp.height = LinearLayout.LayoutParams.WRAP_CONTENT;
            lp.weight = 0;
        }
        ((ViewGroup) mFullscreenArea.getParent()).updateViewLayout(mFullscreenArea, lp);
        if (isFullscreen) {
            if (mExtractView == null) {
                View v = onCreateExtractTextView();
                if (v != null) {
                    setExtractView(v);
                }
            }
            startExtractingText(false);
        }
        updateExtractFrameVisibility();
    }
    if (changed) {
        onConfigureWindow(mWindow.getWindow(), isFullscreen, !mShowInputRequested);
        mLastShowInputRequested = mShowInputRequested;
    }
}
Body of Second Method:
{
    boolean isFullscreen = mShowInputRequested && onEvaluateFullscreenMode();
    boolean changed = mLastShowInputRequested != mShowInputRequested;
    if (mIsFullscreen != isFullscreen || !mFullscreenApplied) {
        changed = true;
        mIsFullscreen = isFullscreen;
        if (mImm != null && mToken != null) {
            mImm.reportFullscreenMode(mToken, mIsFullscreen);
        }
        mFullscreenApplied = true;
        initialize();
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) mFullscreenArea.getLayoutParams();
        if (isFullscreen) {
            mFullscreenArea.setBackgroundDrawable(mThemeAttrs.getDrawable(com.android.internal.R.styleable.InputMethodService_imeFullscreenBackground));
            lp.height = 0;
            lp.weight = 1;
        } else {
            mFullscreenArea.setBackgroundDrawable(null);
            lp.height = LinearLayout.LayoutParams.WRAP_CONTENT;
            lp.weight = 0;
        }
        ((ViewGroup) mFullscreenArea.getParent()).updateViewLayout(mFullscreenArea, lp);
        if (isFullscreen) {
            if (mExtractView == null) {
                View v = onCreateExtractTextView();
                if (v != null) {
                    setExtractView(v);
                }
            }
            startExtractingText(false);
        }
        updateExtractFrameVisibility();
    }
    if (changed) {
        onConfigureWindow(mWindow.getWindow(), isFullscreen, !mShowInputRequested);
        mLastShowInputRequested = mShowInputRequested;
    }
}
------------------------
Find a silently evolved API code:android.animation.ArgbEvaluator.evaluate:COMMENT
Method Modifier: public      
Comment:/**
 * This function returns the calculated in-between value for a color
 * given integers that represent the start and end values in the four
 * bytes of the 32-bit int. Each channel is separately linearly interpolated
 * and the resulting calculated values are recombined into the return value.
 *
 * @param fraction The fraction from the starting to the ending values
 * @param startValue A 32-bit int value representing colors in the
 * separate bytes of the parameter
 * @param endValue A 32-bit int value representing colors in the
 * separate bytes of the parameter
 * @return A value that is calculated to be the linearly interpolated
 * result, derived by separating the start and end values into separate
 * color channels and interpolating each one separately, recombining the
 * resulting values in the same way.
 */

Body of Frist Method:
{
    int startInt = (Integer) startValue;
    int startA = (startInt >> 24) & 0xff;
    int startR = (startInt >> 16) & 0xff;
    int startG = (startInt >> 8) & 0xff;
    int startB = startInt & 0xff;
    int endInt = (Integer) endValue;
    int endA = (endInt >> 24) & 0xff;
    int endR = (endInt >> 16) & 0xff;
    int endG = (endInt >> 8) & 0xff;
    int endB = endInt & 0xff;
    return (int) ((startA + (int) (fraction * (endA - startA))) << 24) | (int) ((startR + (int) (fraction * (endR - startR))) << 16) | (int) ((startG + (int) (fraction * (endG - startG))) << 8) | (int) ((startB + (int) (fraction * (endB - startB))));
}
Body of Second Method:
{
    int startInt = (Integer) startValue;
    float startA = ((startInt >> 24) & 0xff) / 255.0f;
    float startR = ((startInt >> 16) & 0xff) / 255.0f;
    float startG = ((startInt >> 8) & 0xff) / 255.0f;
    float startB = (startInt & 0xff) / 255.0f;
    int endInt = (Integer) endValue;
    float endA = ((endInt >> 24) & 0xff) / 255.0f;
    float endR = ((endInt >> 16) & 0xff) / 255.0f;
    float endG = ((endInt >> 8) & 0xff) / 255.0f;
    float endB = (endInt & 0xff) / 255.0f;
    // convert from sRGB to linear
    startR = (float) Math.pow(startR, 2.2);
    startG = (float) Math.pow(startG, 2.2);
    startB = (float) Math.pow(startB, 2.2);
    endR = (float) Math.pow(endR, 2.2);
    endG = (float) Math.pow(endG, 2.2);
    endB = (float) Math.pow(endB, 2.2);
    // compute the interpolated color in linear space
    float a = startA + fraction * (endA - startA);
    float r = startR + fraction * (endR - startR);
    float g = startG + fraction * (endG - startG);
    float b = startB + fraction * (endB - startB);
    // convert back to sRGB in the [0..255] range
    a = a * 255.0f;
    r = (float) Math.pow(r, 1.0 / 2.2) * 255.0f;
    g = (float) Math.pow(g, 1.0 / 2.2) * 255.0f;
    b = (float) Math.pow(b, 1.0 / 2.2) * 255.0f;
    return Math.round(a) << 24 | Math.round(r) << 16 | Math.round(g) << 8 | Math.round(b);
}
------------------------
Find a silently evolved API code:android.content.res.AssetManager.getResourceTextArray:COMMENT
Method Modifier: default     final       
Comment:/**
 * Retrieve the text array associated with a particular resource
 * identifier.
 *
 * @param resId the resource id of the string array
 */

Body of Frist Method:
{
    final int[] rawInfoArray = getArrayStringInfo(resId);
    final int rawInfoArrayLen = rawInfoArray.length;
    final int infoArrayLen = rawInfoArrayLen / 2;
    int block;
    int index;
    final CharSequence[] retArray = new CharSequence[infoArrayLen];
    for (int i = 0, j = 0; i < rawInfoArrayLen; i = i + 2, j++) {
        block = rawInfoArray[i];
        index = rawInfoArray[i + 1];
        retArray[j] = index >= 0 ? mStringBlocks[block].get(index) : null;
    }
    return retArray;
}
Body of Second Method:
{
    synchronized (this) {
        final int[] rawInfoArray = getArrayStringInfo(resId);
        if (rawInfoArray == null) {
            return null;
        }
        final int rawInfoArrayLen = rawInfoArray.length;
        final int infoArrayLen = rawInfoArrayLen / 2;
        int block;
        int index;
        final CharSequence[] retArray = new CharSequence[infoArrayLen];
        for (int i = 0, j = 0; i < rawInfoArrayLen; i = i + 2, j++) {
            block = rawInfoArray[i];
            index = rawInfoArray[i + 1];
            retArray[j] = index >= 0 ? mStringBlocks[block].get(index) : null;
        }
        return retArray;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setBluetoothA2dpDeviceConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Indicate A2DP source or sink connection state change.
 * @param device Bluetooth device connected/disconnected
 * @param state  new connection state (BluetoothProfile.STATE_xxx)
 * @param profile profile for the A2DP device
 * (either {@link android.bluetooth.BluetoothProfile.A2DP} or
 * {@link android.bluetooth.BluetoothProfile.A2DP_SINK})
 * @return a delay in ms that the caller should wait before broadcasting
 * BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED intent.
 * {@hide}
 */

Body of Frist Method:
{
    IAudioService service = getService();
    int delay = 0;
    try {
        delay = service.setBluetoothA2dpDeviceConnectionState(device, state, profile);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return delay;
}
Body of Second Method:
{
    final IAudioService service = getService();
    int delay = 0;
    try {
        delay = service.setBluetoothA2dpDeviceConnectionState(device, state, profile);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return delay;
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.copyFrom:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mGsmSignalStrength = s.mGsmSignalStrength;
    mGsmBitErrorRate = s.mGsmBitErrorRate;
    mCdmaDbm = s.mCdmaDbm;
    mCdmaEcio = s.mCdmaEcio;
    mEvdoDbm = s.mEvdoDbm;
    mEvdoEcio = s.mEvdoEcio;
    mEvdoSnr = s.mEvdoSnr;
    mLteSignalStrength = s.mLteSignalStrength;
    mLteRsrp = s.mLteRsrp;
    mLteRsrq = s.mLteRsrq;
    mLteRssnr = s.mLteRssnr;
    mLteCqi = s.mLteCqi;
    mTdScdmaRscp = s.mTdScdmaRscp;
    isGsm = s.isGsm;
}
Body of Second Method:
{
    mGsmSignalStrength = s.mGsmSignalStrength;
    mGsmBitErrorRate = s.mGsmBitErrorRate;
    mCdmaDbm = s.mCdmaDbm;
    mCdmaEcio = s.mCdmaEcio;
    mEvdoDbm = s.mEvdoDbm;
    mEvdoEcio = s.mEvdoEcio;
    mEvdoSnr = s.mEvdoSnr;
    mLteSignalStrength = s.mLteSignalStrength;
    mLteRsrp = s.mLteRsrp;
    mLteRsrq = s.mLteRsrq;
    mLteRssnr = s.mLteRssnr;
    mLteCqi = s.mLteCqi;
    mLteRsrpBoost = s.mLteRsrpBoost;
    mTdScdmaRscp = s.mTdScdmaRscp;
    isGsm = s.isGsm;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setPassword:COMMENT
Method Modifier: public      
Comment:/**
 * Set the password.
 * @param password the password
 */

Body of Frist Method:
{
    setFieldValue(PASSWORD_KEY, password, "");
}
Body of Second Method:
{
    setFieldValue(PASSWORD_KEY, password);
}
------------------------
Find a silently evolved API code:android.graphics.Path.computeBounds:COMMENT
Method Modifier: public      
Comment:/**
 * Compute the bounds of the control points of the path, and write the
 * answer into bounds. If the path contains 0 or 1 points, the bounds is
 * set to (0,0,0,0)
 *
 * @param bounds Returns the computed bounds of the path's control points.
 * @param exact This parameter is no longer used.
 */

Body of Frist Method:
{
    native_computeBounds(mNativePath, bounds);
}
Body of Second Method:
{
    nComputeBounds(mNativePath, bounds);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
        return null;
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManager.getService().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.text.method.WordIterator.getPunctuationEnd:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * If <code>offset</code> is within a group of punctuation as defined
 * by {@link #isPunctuation(int)}, returns the index of the last character
 * of that group plus one, otherwise returns BreakIterator.DONE.
 *
 * @param offset the offset to search from.
 */

Body of Frist Method:
{
    while (offset != BreakIterator.DONE && !isPunctuationEndBoundary(offset)) {
        offset = nextBoundary(offset);
    }
    // No need to shift offset, nextBoundary handles that.
    return offset;
}
Body of Second Method:
{
    checkOffsetIsValid(offset);
    while (offset != BreakIterator.DONE && !isPunctuationEndBoundary(offset)) {
        offset = nextBoundary(offset);
    }
    // No need to shift offset, nextBoundary handles that.
    return offset;
}
------------------------
Find a silently evolved API code:android.app.backup.RestoreSession.restoreSome:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Restore select packages from the given set onto the device, replacing the
 * current data of any app contained in the set with the data previously
 * backed up.
 *
 * <p>Callers must hold the android.permission.BACKUP permission to use this method.
 *
 * @return Zero on success, nonzero on error. The observer will only receive
 * progress callbacks if this method returned zero.
 * @param token The token from {@link getAvailableRestoreSets()} corresponding to
 * the restore set that should be used.
 * @param observer If non-null, this binder points to an object that will receive
 * progress callbacks during the restore operation.
 * @param packages The set of packages for which to attempt a restore.  Regardless of
 * the contents of the actual back-end dataset named by {@code token}, only
 * applications mentioned in this list will have their data restored.
 *
 * @hide
 */

Body of Frist Method:
{
    int err = -1;
    if (mObserver != null) {
        Log.d(TAG, "restoreAll() called during active restore");
        return -1;
    }
    mObserver = new RestoreObserverWrapper(mContext, observer);
    try {
        err = mBinder.restoreSome(token, mObserver, packages);
    } catch (RemoteException e) {
        Log.d(TAG, "Can't contact server to restore packages");
    }
    return err;
}
Body of Second Method:
{
    return restoreSome(token, observer, null, packages);
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbConfiguration.setInterfaces:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Only used by UsbService implementation
 * @hide
 */

Body of Frist Method:
{
    mInterfaces = interfaces;
}
Body of Second Method:
{
    mInterfaces = Preconditions.checkArrayElementsNotNull(interfaces, "interfaces");
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Direct callback version of {@link #set(int, long, long, long, PendingIntent, WorkSource)}.
 * Note that repeating alarms must use the PendingIntent variant, not an OnAlarmListener.
 * <p>
 * The OnAlarmListener's {@link OnAlarmListener#onAlarm() onAlarm()} method will be
 * invoked via the specified target Handler, or on the application's main looper
 * if {@code null} is passed as the {@code targetHandler} parameter.
 *
 * @hide
 */

Body of Frist Method:
{
    setImpl(type, triggerAtMillis, windowMillis, intervalMillis, 0, null, listener, null, targetHandler, workSource, null);
}
Body of Second Method:
{
    setImpl(type, triggerAtMillis, windowMillis, intervalMillis, 0, null, listener, tag, targetHandler, workSource, null);
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.groupedByIface:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return total statistics grouped by {@link #iface}; doesn't mutate the
 * original structure.
 */

Body of Frist Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.uid = UID_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    entry.roaming = ROAMING_ALL;
    entry.operations = 0L;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.iface = iface[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        stats.combineValues(entry);
    }
    return stats;
}
Body of Second Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.uid = UID_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    entry.metered = METERED_ALL;
    entry.roaming = ROAMING_ALL;
    entry.operations = 0L;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.iface = iface[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        stats.combineValues(entry);
    }
    return stats;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getCaPath:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the domain_suffix_match value. See setDomSuffixMatch.
 * @return The path for CA certificate files.
 * @hide
 */

Body of Frist Method:
{
    return getFieldValue(CA_PATH_KEY, "");
}
Body of Second Method:
{
    return getFieldValue(CA_PATH_KEY);
}
------------------------
Find a silently evolved API code:android.graphics.LightingColorFilter.setColorMultiply:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Specifies the RGB color used to multiply the source color when the
 * color filter is applied.
 * The alpha channel of this color is ignored.
 *
 * @see #getColorMultiply()
 *
 * @hide
 */

Body of Frist Method:
{
    mMul = mul;
    update();
}
Body of Second Method:
{
    if (mMul != mul) {
        mMul = mul;
        discardNativeInstance();
    }
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.Static.startMonitoringRoutes:COMMENT
Method Modifier: default     
Comment:// Called after sStatic is initialized

Body of Frist Method:
{
    mDefaultAudioVideo = new RouteInfo(mSystemCategory);
    mDefaultAudioVideo.mNameResId = com.android.internal.R.string.default_audio_route_name;
    mDefaultAudioVideo.mSupportedTypes = ROUTE_TYPE_LIVE_AUDIO | ROUTE_TYPE_LIVE_VIDEO;
    mDefaultAudioVideo.updatePresentationDisplay();
    addRouteStatic(mDefaultAudioVideo);
    // This will select the active wifi display route if there is one.
    updateWifiDisplayStatus(mDisplayService.getWifiDisplayStatus());
    appContext.registerReceiver(new WifiDisplayStatusChangedReceiver(), new IntentFilter(DisplayManager.ACTION_WIFI_DISPLAY_STATUS_CHANGED));
    appContext.registerReceiver(new VolumeChangeReceiver(), new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION));
    mDisplayService.registerDisplayListener(this, mHandler);
    AudioRoutesInfo newAudioRoutes = null;
    try {
        newAudioRoutes = mAudioService.startWatchingRoutes(mAudioRoutesObserver);
    } catch (RemoteException e) {
    }
    if (newAudioRoutes != null) {
        // This will select the active BT route if there is one and the current
        // selected route is the default system route, or if there is no selected
        // route yet.
        updateAudioRoutes(newAudioRoutes);
    }
    // Bind to the media router service.
    rebindAsUser(UserHandle.myUserId());
    // appropriately with relevant system state.
    if (mSelectedRoute == null) {
        selectDefaultRouteStatic();
    }
}
Body of Second Method:
{
    mDefaultAudioVideo = new RouteInfo(mSystemCategory);
    mDefaultAudioVideo.mNameResId = com.android.internal.R.string.default_audio_route_name;
    mDefaultAudioVideo.mSupportedTypes = ROUTE_TYPE_LIVE_AUDIO | ROUTE_TYPE_LIVE_VIDEO;
    mDefaultAudioVideo.updatePresentationDisplay();
    if (((AudioManager) appContext.getSystemService(Context.AUDIO_SERVICE)).isVolumeFixed()) {
        mDefaultAudioVideo.mVolumeHandling = RouteInfo.PLAYBACK_VOLUME_FIXED;
    }
    addRouteStatic(mDefaultAudioVideo);
    // This will select the active wifi display route if there is one.
    updateWifiDisplayStatus(mDisplayService.getWifiDisplayStatus());
    appContext.registerReceiver(new WifiDisplayStatusChangedReceiver(), new IntentFilter(DisplayManager.ACTION_WIFI_DISPLAY_STATUS_CHANGED));
    appContext.registerReceiver(new VolumeChangeReceiver(), new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION));
    mDisplayService.registerDisplayListener(this, mHandler);
    AudioRoutesInfo newAudioRoutes = null;
    try {
        newAudioRoutes = mAudioService.startWatchingRoutes(mAudioRoutesObserver);
    } catch (RemoteException e) {
    }
    if (newAudioRoutes != null) {
        // This will select the active BT route if there is one and the current
        // selected route is the default system route, or if there is no selected
        // route yet.
        updateAudioRoutes(newAudioRoutes);
    }
    // Bind to the media router service.
    rebindAsUser(UserHandle.myUserId());
    // appropriately with relevant system state.
    if (mSelectedRoute == null) {
        selectDefaultRouteStatic();
    }
}
------------------------
Find a silently evolved API code:android.media.midi.MidiInputPort.claimFileDescriptor:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    synchronized (mGuard) {
        ParcelFileDescriptor pfd;
        synchronized (mBuffer) {
            pfd = mParcelFileDescriptor;
            if (pfd == null)
                return null;
            IoUtils.closeQuietly(mOutputStream);
            mParcelFileDescriptor = null;
            mOutputStream = null;
        }
        // Set mIsClosed = true so we will not call mDeviceServer.closePort() in close().
        // MidiDevice.MidiConnection.close() will do the cleanup instead.
        mIsClosed = true;
        return pfd;
    }
}
Body of Second Method:
{
    synchronized (mGuard) {
        FileDescriptor fd;
        synchronized (mBuffer) {
            fd = mFileDescriptor;
            if (fd == null)
                return null;
            IoUtils.closeQuietly(mOutputStream);
            mFileDescriptor = null;
            mOutputStream = null;
        }
        // Set mIsClosed = true so we will not call mDeviceServer.closePort() in close().
        // MidiDevice.MidiConnection.close() will do the cleanup instead.
        mIsClosed = true;
        return fd;
    }
}
------------------------
Find a silently evolved API code:android.renderscript.ScriptIntrinsicBlur.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create an intrinsic for applying a blur to an allocation. The
 * default radius is 5.0.
 *
 * Supported elements types are {@link Element#U8},
 * {@link Element#U8_4}.
 *
 * @param rs The RenderScript context
 * @param e Element type for inputs and outputs
 *
 * @return ScriptIntrinsicBlur
 */

Body of Frist Method:
{
    if ((!e.isCompatible(Element.U8_4(rs))) && (!e.isCompatible(Element.U8(rs)))) {
        throw new RSIllegalArgumentException("Unsuported element type.");
    }
    long id = rs.nScriptIntrinsicCreate(5, e.getID(rs));
    ScriptIntrinsicBlur sib = new ScriptIntrinsicBlur(id, rs);
    sib.setRadius(5.f);
    return sib;
}
Body of Second Method:
{
    if ((!e.isCompatible(Element.U8_4(rs))) && (!e.isCompatible(Element.U8(rs)))) {
        throw new RSIllegalArgumentException("Unsupported element type.");
    }
    long id = rs.nScriptIntrinsicCreate(5, e.getID(rs));
    ScriptIntrinsicBlur sib = new ScriptIntrinsicBlur(id, rs);
    sib.setRadius(5.f);
    return sib;
}
------------------------
Find a silently evolved API code:android.widget.Toast.TN.hide:COMMENT
Method Modifier: public      
Comment:/**
 * schedule handleHide into the right thread
 */

Body of Frist Method:
{
    if (localLOGV)
        Log.v(TAG, "HIDE: " + this);
    mHandler.post(mHide);
}
Body of Second Method:
{
    if (localLOGV)
        Log.v(TAG, "HIDE: " + this);
    mHandler.obtainMessage(HIDE).sendToTarget();
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.flagToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */

Body of Frist Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        default:
            return null;
    }
}
Body of Second Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return "FLAG_ENABLE_ACCESSIBILITY_VOLUME";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return "FLAG_REQUEST_ACCESSIBILITY_BUTTON";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return "FLAG_REQUEST_FINGERPRINT_GESTURES";
        default:
            return null;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getStreamMaxVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the maximum volume index for a particular stream.
 *
 * @param streamType The stream type whose maximum volume index is returned.
 * @return The maximum valid volume index for the stream.
 * @see #getStreamVolume(int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getStreamMaxVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.getStreamMaxVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.display.DisplayViewport.toString:COMMENT
Method Modifier: public      hidden      
Comment:// For debugging purposes.

Body of Frist Method:
{
    return "DisplayViewport{valid=" + valid + ", displayId=" + displayId + ", orientation=" + orientation + ", logicalFrame=" + logicalFrame + ", physicalFrame=" + physicalFrame + ", deviceWidth=" + deviceWidth + ", deviceHeight=" + deviceHeight + "}";
}
Body of Second Method:
{
    return "DisplayViewport{valid=" + valid + ", displayId=" + displayId + ", uniqueId='" + uniqueId + "'" + ", orientation=" + orientation + ", logicalFrame=" + logicalFrame + ", physicalFrame=" + physicalFrame + ", deviceWidth=" + deviceWidth + ", deviceHeight=" + deviceHeight + "}";
}
------------------------
Find a silently evolved API code:android.renderscript.ScriptIntrinsicBlur.setInput:COMMENT
Method Modifier: public      
Comment:/**
 * Set the input of the blur.
 * Must match the element type supplied during create.
 *
 * @param ain The input allocation
 */

Body of Frist Method:
{
    mInput = ain;
    setVar(1, ain);
}
Body of Second Method:
{
    if (ain.getType().getY() == 0) {
        throw new RSIllegalArgumentException("Input set to a 1D Allocation");
    }
    mInput = ain;
    setVar(1, ain);
}
------------------------
Find a silently evolved API code:android.graphics.Rect.unflattenFromString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a Rect from a string of the form returned by {@link #flattenToString},
 * or null if the string is not of that form.
 */

Body of Frist Method:
{
    Matcher matcher = UnflattenHelper.getMatcher(str);
    if (!matcher.matches()) {
        return null;
    }
    return new Rect(Integer.parseInt(matcher.group(1)), Integer.parseInt(matcher.group(2)), Integer.parseInt(matcher.group(3)), Integer.parseInt(matcher.group(4)));
}
Body of Second Method:
{
    if (TextUtils.isEmpty(str)) {
        return null;
    }
    Matcher matcher = UnflattenHelper.getMatcher(str);
    if (!matcher.matches()) {
        return null;
    }
    return new Rect(Integer.parseInt(matcher.group(1)), Integer.parseInt(matcher.group(2)), Integer.parseInt(matcher.group(3)), Integer.parseInt(matcher.group(4)));
}
------------------------
Find a silently evolved API code:android.preference.Preference.setLayoutResource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the layout resource that is inflated as the {@link View} to be shown
 * for this Preference. In most cases, the default layout is sufficient for
 * custom Preference objects and only the widget layout needs to be changed.
 * <p>
 * This layout should contain a {@link ViewGroup} with ID
 * {@link android.R.id#widget_frame} to be the parent of the specific widget
 * for this Preference. It should similarly contain
 * {@link android.R.id#title} and {@link android.R.id#summary}.
 *
 * @param layoutResId The layout resource ID to be inflated and returned as
 * a {@link View}.
 * @see #setWidgetLayoutResource(int)
 */

Body of Frist Method:
{
    if (layoutResId != mLayoutResId) {
        // Layout changed
        mCanRecycleLayout = false;
    }
    mLayoutResId = layoutResId;
}
Body of Second Method:
{
    if (layoutResId != mLayoutResId) {
        // Layout changed
        mRecycleEnabled = false;
    }
    mLayoutResId = layoutResId;
}
------------------------
Find a silently evolved API code:android.content.ClipData.prepareToLeaveProcess:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Prepare this {@link ClipData} to leave an app process.
 *
 * @hide
 */

Body of Frist Method:
{
    final int size = mItems.size();
    for (int i = 0; i < size; i++) {
        final Item item = mItems.get(i);
        if (item.mIntent != null) {
            item.mIntent.prepareToLeaveProcess(leavingPackage);
        }
        if (item.mUri != null && StrictMode.vmFileUriExposureEnabled() && leavingPackage) {
            item.mUri.checkFileUriExposed("ClipData.Item.getUri()");
        }
    }
}
Body of Second Method:
{
    // Assume that callers are going to be granting permissions
    prepareToLeaveProcess(leavingPackage, Intent.FLAG_GRANT_READ_URI_PERMISSION);
}
------------------------
Find a silently evolved API code:android.location.Location.makeComplete:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Helper to fill incomplete fields.
 *
 * <p>Used to assist in backwards compatibility with
 * Location objects received from applications.
 *
 * @see #isComplete
 * @hide
 */

Body of Frist Method:
{
    if (mProvider == null)
        mProvider = "?";
    if (!hasAccuracy()) {
        mFieldsMask |= HAS_ACCURACY_MASK;
        mAccuracy = 100.0f;
    }
    if (mTime == 0)
        mTime = System.currentTimeMillis();
    if (mElapsedRealtimeNanos == 0)
        mElapsedRealtimeNanos = SystemClock.elapsedRealtimeNanos();
}
Body of Second Method:
{
    if (mProvider == null)
        mProvider = "?";
    if (!hasAccuracy()) {
        mFieldsMask |= HAS_HORIZONTAL_ACCURACY_MASK;
        mHorizontalAccuracyMeters = 100.0f;
    }
    if (mTime == 0)
        mTime = System.currentTimeMillis();
    if (mElapsedRealtimeNanos == 0)
        mElapsedRealtimeNanos = SystemClock.elapsedRealtimeNanos();
}
------------------------
Find a silently evolved API code:android.service.voice.VoiceInteractionSession.getLayoutInflater:COMMENT
Method Modifier: public      
Comment:/**
 * Convenience for inflating views.
 */

Body of Frist Method:
{
    return mInflater;
}
Body of Second Method:
{
    ensureWindowCreated();
    return mInflater;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbPort.combineRolesAsBit:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Combines one power and one data role together into a unique value with
 * exactly one bit set.  This can be used to efficiently determine whether
 * a combination of roles is supported by testing whether that bit is present
 * in a bit-field.
 *
 * @param powerRole The desired power role: {@link UsbPort#POWER_ROLE_SOURCE}
 * or {@link UsbPort#POWER_ROLE_SINK}, or 0 if no power role.
 * @param dataRole The desired data role: {@link UsbPort#DATA_ROLE_HOST}
 * or {@link UsbPort#DATA_ROLE_DEVICE}, or 0 if no data role.
 * @hide
 */

Body of Frist Method:
{
    checkRoles(powerRole, dataRole);
    final int index = powerRole * NUM_DATA_ROLES + dataRole;
    return 1 << index;
}
Body of Second Method:
{
    checkRoles(powerRole, dataRole);
    final int index = ((powerRole - POWER_ROLE_OFFSET) * NUM_DATA_ROLES) + dataRole;
    return 1 << index;
}
------------------------
Find a silently evolved API code:android.view.GestureDetector.onTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mDoubleTapTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    final boolean isGeneratedGesture = (ev.getFlags() & MotionEvent.FLAG_IS_GENERATED_GESTURE) != 0;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                int slopSquare = isGeneratedGesture ? 0 : mTouchSlopSquare;
                if (distance > slopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                int doubleTapSlopSquare = isGeneratedGesture ? 0 : mDoubleTapTouchSlopSquare;
                if (distance > doubleTapSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.getParent:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the parent window.
 *
 * @return The parent window, or {@code null} if none exists.
 */

Body of Frist Method:
{
    if (mConnectionId == UNDEFINED || mParentId == UNDEFINED) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.getWindow(mConnectionId, mParentId);
}
Body of Second Method:
{
    if (mConnectionId == UNDEFINED_WINDOW_ID || mParentId == UNDEFINED_WINDOW_ID) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.getWindow(mConnectionId, mParentId);
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getTextArray:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue resVal = mResourceData[index];
    if (resVal instanceof ArrayResourceValue) {
        ArrayResourceValue array = (ArrayResourceValue) resVal;
        int count = array.getElementCount();
        return count >= 0 ? Resources_Delegate.fillValues(mBridgeResources, array, new CharSequence[count]) : null;
    }
    int id = getResourceId(index, 0);
    String resIdMessage = id > 0 ? " (resource id 0x" + Integer.toHexString(id) + ')' : "";
    throw new NotFoundException(String.format("%1$s in %2$s%3$s is not a valid array resource.", resVal.getValue(), mNames[index], resIdMessage));
}
Body of Second Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue resVal = mResourceData[index];
    if (resVal instanceof ArrayResourceValue) {
        ArrayResourceValue array = (ArrayResourceValue) resVal;
        int count = array.getElementCount();
        return count >= 0 ? Resources_Delegate.fillValues(mBridgeResources, array, new CharSequence[count]) : null;
    }
    int id = getResourceId(index, 0);
    String resIdMessage = id > 0 ? " (resource id 0x" + Integer.toHexString(id) + ')' : "";
    assert false : String.format("%1$s in %2$s%3$s is not a valid array resource.", resVal.getValue(), mNames[index], resIdMessage);
    return new CharSequence[0];
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGattServer.addService:COMMENT
Method Modifier: public      
Comment:/**
 * Add a service to the list of services to be hosted.
 *
 * <p>Once a service has been addded to the the list, the service and its
 * included characteristics will be provided by the local device.
 *
 * <p>If the local device has already exposed services when this function
 * is called, a service update notification will be sent to all clients.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param service Service to be added to the list of services provided
 * by this device.
 * @return true, if the service has been added successfully
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "addService() - service: " + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    mServices.add(service);
    try {
        mService.beginServiceDeclaration(mServerIf, service.getType(), service.getInstanceId(), service.getHandles(), new ParcelUuid(service.getUuid()), service.isAdvertisePreferred());
        List<BluetoothGattService> includedServices = service.getIncludedServices();
        for (BluetoothGattService includedService : includedServices) {
            mService.addIncludedService(mServerIf, includedService.getType(), includedService.getInstanceId(), new ParcelUuid(includedService.getUuid()));
        }
        List<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();
        for (BluetoothGattCharacteristic characteristic : characteristics) {
            int permission = ((characteristic.getKeySize() - 7) << 12) + characteristic.getPermissions();
            mService.addCharacteristic(mServerIf, new ParcelUuid(characteristic.getUuid()), characteristic.getProperties(), permission);
            List<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();
            for (BluetoothGattDescriptor descriptor : descriptors) {
                permission = ((characteristic.getKeySize() - 7) << 12) + descriptor.getPermissions();
                mService.addDescriptor(mServerIf, new ParcelUuid(descriptor.getUuid()), permission);
            }
        }
        mService.endServiceDeclaration(mServerIf);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "addService() - service: " + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    mPendingService = service;
    try {
        mService.addService(mServerIf, service);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.stopTrackingWifiChange:COMMENT
<android.net.wifi.WifiScanner: void stopTrackingWifiChange(WifiChangeListener)>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * stop tracking changes in wifi environment
 * @param listener object that was provided to report events on {@link
 * #stopTrackingWifiChange}
 */

Body of Frist Method:
{
    int key = removeListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    mAsyncChannel.sendMessage(CMD_STOP_TRACKING_CHANGE, 0, key);
}
Body of Second Method:
{
    throw new UnsupportedOperationException();
}
------------------------
Find a silently evolved API code:android.media.SoundPool.play:COMMENT
Method Modifier: public      final       
Comment:/**
 * Play a sound from a sound ID.
 *
 * Play the sound specified by the soundID. This is the value
 * returned by the load() function. Returns a non-zero streamID
 * if successful, zero if it fails. The streamID can be used to
 * further control playback. Note that calling play() may cause
 * another sound to stop playing if the maximum number of active
 * streams is exceeded. A loop value of -1 means loop forever,
 * a value of 0 means don't loop, other values indicate the
 * number of repeats, e.g. a value of 1 plays the audio twice.
 * The playback rate allows the application to vary the playback
 * rate (pitch) of the sound. A value of 1.0 means play back at
 * the original frequency. A value of 2.0 means play back twice
 * as fast, and a value of 0.5 means playback at half speed.
 *
 * @param soundID a soundID returned by the load() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 * @param priority stream priority (0 = lowest priority)
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 * @return non-zero streamID if successful, zero if failed
 */

Body of Frist Method:
{
    if (isRestricted()) {
        leftVolume = rightVolume = 0;
    }
    return _play(soundID, leftVolume, rightVolume, priority, loop, rate);
}
Body of Second Method:
{
    baseStart();
    return _play(soundID, leftVolume, rightVolume, priority, loop, rate);
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.getCurrentSpellChecker:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        // Passing null as a locale for ICS
        return sService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        // Passing null as a locale for ICS
        return mService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.putExtras:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Adds some extras associated with a {@code Connection}.
 *
 * @param callId The unique ID of the call.
 * @param extras The extras to add.
 */

Body of Frist Method:
{
    Log.v(this, "putExtras: %s", callId);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.putExtras(callId, extras);
        } catch (RemoteException ignored) {
        }
    }
}
Body of Second Method:
{
    Log.v(this, "putExtras: %s", callId);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.putExtras(callId, extras, Log.getExternalSession());
        } catch (RemoteException ignored) {
        }
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.InputContentInfo.getContentUri:COMMENT
Method Modifier: public      
Comment:/**
 * @return Content URI with which the content can be obtained.
 */

Body of Frist Method:
{
    return mContentUri;
}
Body of Second Method:
{
    // user ID.
    if (mContentUriOwnerUserId != UserHandle.myUserId()) {
        return ContentProvider.maybeAddUserId(mContentUri, mContentUriOwnerUserId);
    }
    return mContentUri;
}
------------------------
Find a silently evolved API code:android.graphics.Path.isInverseFillType:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the filltype is one of the INVERSE variants
 *
 * @return true if the filltype is one of the INVERSE variants
 */

Body of Frist Method:
{
    final int ft = native_getFillType(mNativePath);
    return (ft & FillType.INVERSE_WINDING.nativeInt) != 0;
}
Body of Second Method:
{
    final int ft = nGetFillType(mNativePath);
    return (ft & FillType.INVERSE_WINDING.nativeInt) != 0;
}
------------------------
Find a silently evolved API code:android.graphics.Path.close:COMMENT
Method Modifier: public      
Comment:/**
 * Close the current contour. If the current point is not equal to the
 * first point of the contour, a line segment is automatically added.
 */

Body of Frist Method:
{
    isSimplePath = false;
    native_close(mNativePath);
}
Body of Second Method:
{
    isSimplePath = false;
    nClose(mNativePath);
}
------------------------
Find a silently evolved API code:android.app.DownloadManager.Query.runQuery:COMMENT
Method Modifier: default     
Comment:/**
 * Run this query using the given ContentResolver.
 * @param projection the projection to pass to ContentResolver.query()
 * @return the Cursor returned by ContentResolver.query()
 */

Body of Frist Method:
{
    Uri uri = baseUri;
    List<String> selectionParts = new ArrayList<String>();
    String[] selectionArgs = null;
    if (mIds != null) {
        selectionParts.add(getWhereClauseForIds(mIds));
        selectionArgs = getWhereArgsForIds(mIds);
    }
    if (mStatusFlags != null) {
        List<String> parts = new ArrayList<String>();
        if ((mStatusFlags & STATUS_PENDING) != 0) {
            parts.add(statusClause("=", Downloads.Impl.STATUS_PENDING));
        }
        if ((mStatusFlags & STATUS_RUNNING) != 0) {
            parts.add(statusClause("=", Downloads.Impl.STATUS_RUNNING));
        }
        if ((mStatusFlags & STATUS_PAUSED) != 0) {
            parts.add(statusClause("=", Downloads.Impl.STATUS_PAUSED_BY_APP));
            parts.add(statusClause("=", Downloads.Impl.STATUS_WAITING_TO_RETRY));
            parts.add(statusClause("=", Downloads.Impl.STATUS_WAITING_FOR_NETWORK));
            parts.add(statusClause("=", Downloads.Impl.STATUS_QUEUED_FOR_WIFI));
        }
        if ((mStatusFlags & STATUS_SUCCESSFUL) != 0) {
            parts.add(statusClause("=", Downloads.Impl.STATUS_SUCCESS));
        }
        if ((mStatusFlags & STATUS_FAILED) != 0) {
            parts.add("(" + statusClause(">=", 400) + " AND " + statusClause("<", 600) + ")");
        }
        selectionParts.add(joinStrings(" OR ", parts));
    }
    if (mOnlyIncludeVisibleInDownloadsUi) {
        selectionParts.add(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI + " != '0'");
    }
    // only return rows which are not marked 'deleted = 1'
    selectionParts.add(Downloads.Impl.COLUMN_DELETED + " != '1'");
    String selection = joinStrings(" AND ", selectionParts);
    String orderDirection = (mOrderDirection == ORDER_ASCENDING ? "ASC" : "DESC");
    String orderBy = mOrderByColumn + " " + orderDirection;
    return resolver.query(uri, projection, selection, selectionArgs, orderBy);
}
Body of Second Method:
{
    Uri uri = baseUri;
    List<String> selectionParts = new ArrayList<String>();
    String[] selectionArgs = null;
    int whereArgsCount = (mIds == null) ? 0 : mIds.length;
    whereArgsCount = (mFilterString == null) ? whereArgsCount : whereArgsCount + 1;
    selectionArgs = new String[whereArgsCount];
    if (whereArgsCount > 0) {
        if (mIds != null) {
            selectionParts.add(getWhereClauseForIds(mIds));
            getWhereArgsForIds(mIds, selectionArgs);
        }
        if (mFilterString != null) {
            selectionParts.add(Downloads.Impl.COLUMN_TITLE + " LIKE ?");
            selectionArgs[selectionArgs.length - 1] = "%" + mFilterString + "%";
        }
    }
    if (mStatusFlags != null) {
        List<String> parts = new ArrayList<String>();
        if ((mStatusFlags & STATUS_PENDING) != 0) {
            parts.add(statusClause("=", Downloads.Impl.STATUS_PENDING));
        }
        if ((mStatusFlags & STATUS_RUNNING) != 0) {
            parts.add(statusClause("=", Downloads.Impl.STATUS_RUNNING));
        }
        if ((mStatusFlags & STATUS_PAUSED) != 0) {
            parts.add(statusClause("=", Downloads.Impl.STATUS_PAUSED_BY_APP));
            parts.add(statusClause("=", Downloads.Impl.STATUS_WAITING_TO_RETRY));
            parts.add(statusClause("=", Downloads.Impl.STATUS_WAITING_FOR_NETWORK));
            parts.add(statusClause("=", Downloads.Impl.STATUS_QUEUED_FOR_WIFI));
        }
        if ((mStatusFlags & STATUS_SUCCESSFUL) != 0) {
            parts.add(statusClause("=", Downloads.Impl.STATUS_SUCCESS));
        }
        if ((mStatusFlags & STATUS_FAILED) != 0) {
            parts.add("(" + statusClause(">=", 400) + " AND " + statusClause("<", 600) + ")");
        }
        selectionParts.add(joinStrings(" OR ", parts));
    }
    if (mOnlyIncludeVisibleInDownloadsUi) {
        selectionParts.add(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI + " != '0'");
    }
    // only return rows which are not marked 'deleted = 1'
    selectionParts.add(Downloads.Impl.COLUMN_DELETED + " != '1'");
    String selection = joinStrings(" AND ", selectionParts);
    String orderDirection = (mOrderDirection == ORDER_ASCENDING ? "ASC" : "DESC");
    String orderBy = mOrderByColumn + " " + orderDirection;
    return resolver.query(uri, projection, selection, selectionArgs, orderBy);
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfEditor.shouldScaleForPrinting:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets whether the document prefers to be scaled for printing.
 *
 * @return Whether to scale the document.
 */

Body of Frist Method:
{
    throwIfClosed();
    return nativeScaleForPrinting(mNativeDocument);
}
Body of Second Method:
{
    throwIfClosed();
    synchronized (PdfRenderer.sPdfiumLock) {
        return nativeScaleForPrinting(mNativeDocument);
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHostView.applyRemoteViews:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (LOGD)
        Log.d(TAG, "updateAppWidget called mOld=" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (mLastExecutionSignal != null) {
        mLastExecutionSignal.cancel();
        mLastExecutionSignal = null;
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        if (mAsyncExecutor != null) {
            inflateAsync(remoteViews);
            return;
        }
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext();
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView, mOnClickHandler);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, "was able to recycle existing layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this, mOnClickHandler);
                if (LOGD)
                    Log.d(TAG, "had to inflate new layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    applyContent(content, recycled, exception);
    updateContentDescription(mInfo);
}
Body of Second Method:
{
    if (LOGD)
        Log.d(TAG, "updateAppWidget called mOld=" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (mLastExecutionSignal != null) {
        mLastExecutionSignal.cancel();
        mLastExecutionSignal = null;
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        if (mAsyncExecutor != null && useAsyncIfPossible) {
            inflateAsync(remoteViews);
            return;
        }
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext();
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView, mOnClickHandler);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, "was able to recycle existing layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this, mOnClickHandler);
                if (LOGD)
                    Log.d(TAG, "had to inflate new layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    applyContent(content, recycled, exception);
    updateContentDescription(mInfo);
}
------------------------
Find a silently evolved API code:android.content.ClipDescription.filterMimeTypes:COMMENT
Method Modifier: public      
Comment:/**
 * Filter the clip description MIME types by the given MIME type.  Returns
 * all MIME types in the clip that match the given MIME type.
 *
 * @param mimeType The desired MIME type.  May be a pattern.
 * @return Returns an array of all matching MIME types.  If there are no
 * matching MIME types, null is returned.
 */

Body of Frist Method:
{
    ArrayList<String> array = null;
    for (int i = 0; i < mMimeTypes.length; i++) {
        if (compareMimeTypes(mMimeTypes[i], mimeType)) {
            if (array == null) {
                array = new ArrayList<String>();
            }
            array.add(mMimeTypes[i]);
        }
    }
    if (array == null) {
        return null;
    }
    String[] rawArray = new String[array.size()];
    array.toArray(rawArray);
    return rawArray;
}
Body of Second Method:
{
    ArrayList<String> array = null;
    final int size = mMimeTypes.size();
    for (int i = 0; i < size; i++) {
        if (compareMimeTypes(mMimeTypes.get(i), mimeType)) {
            if (array == null) {
                array = new ArrayList<String>();
            }
            array.add(mMimeTypes.get(i));
        }
    }
    if (array == null) {
        return null;
    }
    String[] rawArray = new String[array.size()];
    array.toArray(rawArray);
    return rawArray;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isStreamMute:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current mute state for a particular stream.
 *
 * @param streamType The stream to get mute state for.
 * @return The mute state for the given stream.
 * @see #adjustStreamVolume(int, int, int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.isStreamMute(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.isStreamMute(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.resetClientKeyEntry:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mClientPrivateKey = null;
    mClientCertificate = null;
}
Body of Second Method:
{
    mClientPrivateKey = null;
    mClientCertificateChain = null;
}
------------------------
Find a silently evolved API code:android.text.method.WordIterator.isAfterPunctuation:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Indicates if the provided offset is after a punctuation character
 * as defined by {@link #isPunctuation(int)}.
 *
 * @param offset the offset to check from.
 * @return Whether the offset is after a punctuation character.
 */

Body of Frist Method:
{
    final int shiftedOffset = offset - mOffsetShift;
    if (shiftedOffset >= 1 && shiftedOffset <= mString.length()) {
        final int codePoint = mString.codePointBefore(shiftedOffset);
        return isPunctuation(codePoint);
    }
    return false;
}
Body of Second Method:
{
    if (mStart < offset && offset <= mEnd) {
        final int codePoint = Character.codePointBefore(mCharSeq, offset);
        return isPunctuation(codePoint);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.setup:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Sets up the renderer for drawing.
 *
 * @param width The width of the drawing surface.
 * @param height The height of the drawing surface.
 * @param attachInfo Information about the window.
 * @param surfaceInsets The drawing surface insets to apply
 */

Body of Frist Method:
{
    mWidth = width;
    mHeight = height;
    if (surfaceInsets != null && (surfaceInsets.left != 0 || surfaceInsets.right != 0 || surfaceInsets.top != 0 || surfaceInsets.bottom != 0)) {
        mHasInsets = true;
        mInsetLeft = surfaceInsets.left;
        mInsetTop = surfaceInsets.top;
        mSurfaceWidth = width + mInsetLeft + surfaceInsets.right;
        mSurfaceHeight = height + mInsetTop + surfaceInsets.bottom;
        // If the surface has insets, it can't be opaque.
        setOpaque(false);
    } else {
        mHasInsets = false;
        mInsetLeft = 0;
        mInsetTop = 0;
        mSurfaceWidth = width;
        mSurfaceHeight = height;
    }
    mRootNode.setLeftTopRightBottom(-mInsetLeft, -mInsetTop, mSurfaceWidth, mSurfaceHeight);
    nSetup(mNativeProxy, mSurfaceWidth, mSurfaceHeight, mLightRadius, mAmbientShadowAlpha, mSpotShadowAlpha);
    setLightCenter(attachInfo);
}
Body of Second Method:
{
    mWidth = width;
    mHeight = height;
    if (surfaceInsets != null && (surfaceInsets.left != 0 || surfaceInsets.right != 0 || surfaceInsets.top != 0 || surfaceInsets.bottom != 0)) {
        mHasInsets = true;
        mInsetLeft = surfaceInsets.left;
        mInsetTop = surfaceInsets.top;
        mSurfaceWidth = width + mInsetLeft + surfaceInsets.right;
        mSurfaceHeight = height + mInsetTop + surfaceInsets.bottom;
        // If the surface has insets, it can't be opaque.
        setOpaque(false);
    } else {
        mHasInsets = false;
        mInsetLeft = 0;
        mInsetTop = 0;
        mSurfaceWidth = width;
        mSurfaceHeight = height;
    }
    mRootNode.setLeftTopRightBottom(-mInsetLeft, -mInsetTop, mSurfaceWidth, mSurfaceHeight);
    nSetup(mNativeProxy, mLightRadius, mAmbientShadowAlpha, mSpotShadowAlpha);
    setLightCenter(attachInfo);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.requestAudioFocusForCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Used internally by telephony package to request audio focus. Will cause the focus request
 * to be associated with the "voice communication" identifier only used in AudioService
 * to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for
 * the establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so
 * media applications resume after a call
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.requestAudioFocus(new AudioAttributes.Builder().setInternalLegacyStreamType(streamType).build(), durationHint, mICallBack, null, AudioSystem.IN_VOICE_COMM_FOCUS_ID, getContext().getOpPackageName(), AUDIOFOCUS_FLAG_LOCK, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.requestAudioFocus(new AudioAttributes.Builder().setInternalLegacyStreamType(streamType).build(), durationHint, mICallBack, null, AudioSystem.IN_VOICE_COMM_FOCUS_ID, getContext().getOpPackageName(), AUDIOFOCUS_FLAG_LOCK, null, /* policy token */
        0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.PorterDuffColorFilter.setColor:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Specifies the color to tint the source pixels with when this color
 * filter is applied.
 *
 * @param color An ARGB {@link Color color}
 *
 * @see Color
 * @see #getColor()
 * @see #getMode()
 *
 * @hide
 */

Body of Frist Method:
{
    mColor = color;
    update();
}
Body of Second Method:
{
    if (mColor != color) {
        mColor = color;
        discardNativeInstance();
    }
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.newSpellCheckerSession:COMMENT
Method Modifier: public      
Comment:/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. "en"), the specified locale in Settings (e.g. "en_US") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */

Body of Frist Method:
{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException("Locale should not be null if you don't refer" + " settings.");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = sService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, sService, listener, subtypeInUse);
    try {
        sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        return null;
    }
    return session;
}
Body of Second Method:
{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException("Locale should not be null if you don't refer" + " settings.");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = mService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, mService, listener);
    try {
        mService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return session;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    mNetworkSelectionStatus.writeToParcel(dest);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(apBand);
    dest.writeInt(apChannel);
    dest.writeString(FQDN);
    dest.writeString(providerFriendlyName);
    dest.writeInt(roamingConsortiumIds.length);
    for (long roamingConsortiumId : roamingConsortiumIds) {
        dest.writeLong(roamingConsortiumId);
    }
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(meteredHint ? 1 : 0);
    dest.writeInt(useExternalScores ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeString(creatorName);
    dest.writeString(lastUpdateName);
    dest.writeLong(lastConnectionFailure);
    dest.writeLong(lastRoamingFailure);
    dest.writeInt(lastRoamingFailureReason);
    dest.writeLong(roamingFailureBlackListTimeMilli);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
    dest.writeInt(numTicksAtLowRSSI);
    dest.writeInt(numTicksAtBadRSSI);
    dest.writeInt(numTicksAtNotHighRSSI);
    dest.writeInt(numUserTriggeredJoinAttempts);
    dest.writeInt(userApproved);
    dest.writeInt(numNoInternetAccessReports);
    dest.writeInt(noInternetAccessExpected ? 1 : 0);
    dest.writeInt(shared ? 1 : 0);
    dest.writeString(mPasspointManagementObjectTree);
}
Body of Second Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    mNetworkSelectionStatus.writeToParcel(dest);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(apBand);
    dest.writeInt(apChannel);
    dest.writeString(FQDN);
    dest.writeString(providerFriendlyName);
    dest.writeInt(isHomeProviderNetwork ? 1 : 0);
    dest.writeInt(roamingConsortiumIds.length);
    for (long roamingConsortiumId : roamingConsortiumIds) {
        dest.writeLong(roamingConsortiumId);
    }
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(isLegacyPasspointConfig ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(meteredHint ? 1 : 0);
    dest.writeInt(meteredOverride ? 1 : 0);
    dest.writeInt(useExternalScores ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeString(creatorName);
    dest.writeString(lastUpdateName);
    dest.writeLong(lastConnectionFailure);
    dest.writeLong(lastRoamingFailure);
    dest.writeInt(lastRoamingFailureReason);
    dest.writeLong(roamingFailureBlackListTimeMilli);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(userApproved);
    dest.writeInt(numNoInternetAccessReports);
    dest.writeInt(noInternetAccessExpected ? 1 : 0);
    dest.writeInt(shared ? 1 : 0);
    dest.writeString(mPasspointManagementObjectTree);
}
------------------------
Find a silently evolved API code:android.graphics.LinearGradient.copy:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final LinearGradient copy;
    switch(mType) {
        case TYPE_COLORS_AND_POSITIONS:
            copy = new LinearGradient(mX0, mY0, mX1, mY1, mColors.clone(), mPositions != null ? mPositions.clone() : null, mTileMode);
            break;
        case TYPE_COLOR_START_AND_COLOR_END:
            copy = new LinearGradient(mX0, mY0, mX1, mY1, mColor0, mColor1, mTileMode);
            break;
        default:
            throw new IllegalArgumentException("LinearGradient should be created with either " + "colors and positions or start color and end color");
    }
    copyLocalMatrix(copy);
    return copy;
}
Body of Second Method:
{
    final LinearGradient copy;
    if (mType == TYPE_COLORS_AND_POSITIONS) {
        copy = new LinearGradient(mX0, mY0, mX1, mY1, mColors.clone(), mPositions != null ? mPositions.clone() : null, mTileMode);
    } else {
        // TYPE_COLOR_START_AND_COLOR_END
        copy = new LinearGradient(mX0, mY0, mX1, mY1, mColor0, mColor1, mTileMode);
    }
    copyLocalMatrix(copy);
    return copy;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.connect:COMMENT
Method Modifier: public      
Comment:/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */

Body of Frist Method:
{
    if (mDevice == null)
        throw new IOException("Connect is called on null device");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException("socket closed");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException("Bluetooth is off");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "connect(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("socket closed");
            if (mPfd == null)
                throw new IOException("bt socket connect failed");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = new LocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException("bt socket connect failed");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("bt socket closed");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException("unable to send RPC: " + e.getMessage());
    }
}
Body of Second Method:
{
    if (mDevice == null)
        throw new IOException("Connect is called on null device");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException("socket closed");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException("Bluetooth is off");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "connect(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("socket closed");
            if (mPfd == null)
                throw new IOException("bt socket connect failed");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException("bt socket connect failed");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("bt socket closed");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException("unable to send RPC: " + e.getMessage());
    }
}
------------------------
Find a silently evolved API code:android.renderscript.ScriptIntrinsicResize.setInput:COMMENT
Method Modifier: public      
Comment:/**
 * Set the input of the resize.
 * Must match the element type supplied during create.
 *
 * @param ain The input allocation.
 */

Body of Frist Method:
{
    Element e = ain.getElement();
    if (!e.isCompatible(Element.U8(mRS)) && !e.isCompatible(Element.U8_2(mRS)) && !e.isCompatible(Element.U8_3(mRS)) && !e.isCompatible(Element.U8_4(mRS)) && !e.isCompatible(Element.F32(mRS)) && !e.isCompatible(Element.F32_2(mRS)) && !e.isCompatible(Element.F32_3(mRS)) && !e.isCompatible(Element.F32_4(mRS))) {
        throw new RSIllegalArgumentException("Unsuported element type.");
    }
    mInput = ain;
    setVar(0, ain);
}
Body of Second Method:
{
    Element e = ain.getElement();
    if (!e.isCompatible(Element.U8(mRS)) && !e.isCompatible(Element.U8_2(mRS)) && !e.isCompatible(Element.U8_3(mRS)) && !e.isCompatible(Element.U8_4(mRS)) && !e.isCompatible(Element.F32(mRS)) && !e.isCompatible(Element.F32_2(mRS)) && !e.isCompatible(Element.F32_3(mRS)) && !e.isCompatible(Element.F32_4(mRS))) {
        throw new RSIllegalArgumentException("Unsupported element type.");
    }
    mInput = ain;
    setVar(0, ain);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the drawable for the layer at the specified index.
 *
 * @param index The index of the layer, must be in the range
 * {@code 0...getNumberOfLayers()-1}.
 * @return The {@link Drawable} at the specified layer index.
 *
 * @see #setDrawable(int, Drawable)
 * @attr ref android.R.styleable#LayerDrawableItem_drawable
 */

Body of Frist Method:
{
    if (index >= mLayerState.mNum) {
        throw new IndexOutOfBoundsException();
    }
    return mLayerState.mChildren[index].mDrawable;
}
Body of Second Method:
{
    if (index >= mLayerState.mNumChildren) {
        throw new IndexOutOfBoundsException();
    }
    return mLayerState.mChildren[index].mDrawable;
}
------------------------
Find a silently evolved API code:android.media.MediaRecorder.prepare:COMMENT
Method Modifier: public      
Comment:/**
 * Prepares the recorder to begin capturing and encoding data. This method
 * must be called after setting up the desired audio and video sources,
 * encoders, file format, etc., but before start().
 *
 * @throws IllegalStateException if it is called after
 * start() or before setOutputFormat().
 * @throws IOException if prepare fails otherwise.
 */

Body of Frist Method:
{
    if (mPath != null) {
        RandomAccessFile file = new RandomAccessFile(mPath, "rws");
        try {
            _setOutputFile(file.getFD(), 0, 0);
        } finally {
            file.close();
        }
    } else if (mFd != null) {
        _setOutputFile(mFd, 0, 0);
    } else {
        throw new IOException("No valid output file");
    }
    _prepare();
}
Body of Second Method:
{
    if (mPath != null) {
        RandomAccessFile file = new RandomAccessFile(mPath, "rws");
        try {
            _setOutputFile(file.getFD());
        } finally {
            file.close();
        }
    } else if (mFd != null) {
        _setOutputFile(mFd);
    } else if (mFile != null) {
        RandomAccessFile file = new RandomAccessFile(mFile, "rws");
        try {
            _setOutputFile(file.getFD());
        } finally {
            file.close();
        }
    } else {
        throw new IOException("No valid output file");
    }
    _prepare();
}
------------------------
Find a silently evolved API code:android.media.AudioManager.abandonAudioFocusForCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Used internally by telephony package to abandon audio focus, typically after a call or
 * when ringing ends and the call is rejected or not answered.
 * Should match one or more calls to {@link #requestAudioFocusForCall(int, int)}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.abandonAudioFocus(null, AudioSystem.IN_VOICE_COMM_FOCUS_ID, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.abandonAudioFocus(null, AudioSystem.IN_VOICE_COMM_FOCUS_ID, null, /*AudioAttributes, legacy behavior*/
        getContext().getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.ClipboardManager.getPrimaryClipDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 */

Body of Frist Method:
{
    try {
        return getService().getPrimaryClipDescription(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return mService.getPrimaryClipDescription(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.ScanResult.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeLong(hessid);
    dest.writeInt(anqpDomainId);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeInt(channelWidth);
    dest.writeInt(centerFreq0);
    dest.writeInt(centerFreq1);
    dest.writeLong(seen);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numConnection);
    dest.writeInt(numUsage);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(isAutoJoinCandidate);
    dest.writeString((venueName != null) ? venueName.toString() : "");
    dest.writeString((operatorFriendlyName != null) ? operatorFriendlyName.toString() : "");
    dest.writeLong(this.flags);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpLines != null) {
        dest.writeInt(anqpLines.size());
        for (int i = 0; i < anqpLines.size(); i++) {
            dest.writeString(anqpLines.get(i));
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpElements != null) {
        dest.writeInt(anqpElements.length);
        for (AnqpInformationElement element : anqpElements) {
            dest.writeInt(element.getVendorId());
            dest.writeInt(element.getElementId());
            dest.writeInt(element.getPayload().length);
            dest.writeByteArray(element.getPayload());
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeLong(hessid);
    dest.writeInt(anqpDomainId);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeInt(channelWidth);
    dest.writeInt(centerFreq0);
    dest.writeInt(centerFreq1);
    dest.writeLong(seen);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numConnection);
    dest.writeInt(numUsage);
    dest.writeInt(numIpConfigFailures);
    dest.writeString((venueName != null) ? venueName.toString() : "");
    dest.writeString((operatorFriendlyName != null) ? operatorFriendlyName.toString() : "");
    dest.writeLong(this.flags);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpLines != null) {
        dest.writeInt(anqpLines.size());
        for (int i = 0; i < anqpLines.size(); i++) {
            dest.writeString(anqpLines.get(i));
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpElements != null) {
        dest.writeInt(anqpElements.length);
        for (AnqpInformationElement element : anqpElements) {
            dest.writeInt(element.getVendorId());
            dest.writeInt(element.getElementId());
            dest.writeInt(element.getPayload().length);
            dest.writeByteArray(element.getPayload());
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.text.Emoji.isEmojiModifierBase:COMMENT
Method Modifier: public      static      hidden      
Comment:// Returns true if the given code point is emoji modifier base.

Body of Frist Method:
{
    return Arrays.binarySearch(EMOJI_MODIFIER_BASE, codePoint) >= 0;
}
Body of Second Method:
{
    // that treats these as potential emoji bases.
    if (codePoint == 0x1F91D || codePoint == 0x1F93C) {
        return true;
    }
    // TODO: Remove once emoji-data.text 5.0 is in ICU or update to 6.0.
    if (codePoint == 0x1F91F || (0x1F931 <= codePoint && codePoint <= 0x1F932) || (0x1F9D1 <= codePoint && codePoint <= 0x1F9DD)) {
        return true;
    }
    return UCharacter.hasBinaryProperty(codePoint, UProperty.EMOJI_MODIFIER_BASE);
}
------------------------
Find a silently evolved API code:android.animation.ObjectAnimator.animateValue:COMMENT
Method Modifier: default     
Comment:/**
 * This method is called with the elapsed fraction of the animation during every
 * animation frame. This function turns the elapsed fraction into an interpolated fraction
 * and then into an animated value (from the evaluator. The function is called mostly during
 * animation updates, but it is also called when the <code>end()</code>
 * function is called, to set the final value on the property.
 *
 * <p>Overrides of this method must call the superclass to perform the calculation
 * of the animated value.</p>
 *
 * @param fraction The elapsed fraction of the animation.
 */

Body of Frist Method:
{
    final Object target = getTarget();
    if (target == null) {
        // We lost the target reference, cancel and clean up.
        cancel();
        return;
    }
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(target);
    }
}
Body of Second Method:
{
    final Object target = getTarget();
    if (mTarget != null && target == null) {
        // We lost the target reference, cancel and clean up. Note: we allow null target if the
        // / target has never been set.
        cancel();
        return;
    }
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(target);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setMode:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the audio mode.
 * <p>
 * The audio mode encompasses audio routing AND the behavior of
 * the telephony layer. Therefore this method should only be used by applications that
 * replace the platform-wide management of audio settings or the main telephony application.
 * In particular, the {@link #MODE_IN_CALL} mode should only be used by the telephony
 * application when it places a phone call, as it will cause signals from the radio layer
 * to feed the platform mixer.
 *
 * @param mode  the requested audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
 * {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
 * Informs the HAL about the current audio state so that
 * it can route the audio appropriately.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setMode(mode, mICallBack, mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.setMode(mode, mICallBack, mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.DragEvent.recycle:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Recycle the DragEvent, to be re-used by a later caller.  After calling
 * this function you must never touch the event again.
 *
 * @hide
 */

Body of Frist Method:
{
    // Ensure recycle is only called once!
    if (TRACK_RECYCLED_LOCATION) {
        if (mRecycledLocation != null) {
            throw new RuntimeException(toString() + " recycled twice!", mRecycledLocation);
        }
        mRecycledLocation = new RuntimeException("Last recycled here");
    } else {
        if (mRecycled) {
            throw new RuntimeException(toString() + " recycled twice!");
        }
        mRecycled = true;
    }
    mClipData = null;
    mClipDescription = null;
    mLocalState = null;
    synchronized (gRecyclerLock) {
        if (gRecyclerUsed < MAX_RECYCLED) {
            gRecyclerUsed++;
            mNext = gRecyclerTop;
            gRecyclerTop = this;
        }
    }
}
Body of Second Method:
{
    // Ensure recycle is only called once!
    if (TRACK_RECYCLED_LOCATION) {
        if (mRecycledLocation != null) {
            throw new RuntimeException(toString() + " recycled twice!", mRecycledLocation);
        }
        mRecycledLocation = new RuntimeException("Last recycled here");
    } else {
        if (mRecycled) {
            throw new RuntimeException(toString() + " recycled twice!");
        }
        mRecycled = true;
    }
    mClipData = null;
    mClipDescription = null;
    mLocalState = null;
    mEventHandlerWasCalled = false;
    synchronized (gRecyclerLock) {
        if (gRecyclerUsed < MAX_RECYCLED) {
            gRecyclerUsed++;
            mNext = gRecyclerTop;
            gRecyclerTop = this;
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.DrawableWrapper.inflateChildDrawable:COMMENT
Method Modifier: private     
Comment:/**
 * Called during inflation to inflate the child element. The last valid
 * child element will take precedence over any other child elements or
 * explicit drawable attribute.
 */

Body of Frist Method:
{
    // Seek to the first child element.
    Drawable dr = null;
    int type;
    final int outerDepth = parser.getDepth();
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.START_TAG) {
            dr = Drawable.createFromXmlInner(r, parser, attrs, theme);
        }
    }
    if (dr != null) {
        setDrawable(dr);
    }
}
Body of Second Method:
{
    // Seek to the first child element.
    Drawable dr = null;
    int type;
    final int outerDepth = parser.getDepth();
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.START_TAG) {
            dr = Drawable.createFromXmlInnerForDensity(r, parser, attrs, mState.mSrcDensityOverride, theme);
        }
    }
    if (dr != null) {
        setDrawable(dr);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getVibrateSetting:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns whether the user's vibrate setting for a vibrate type.
 * <p>
 * This shouldn't be needed by most clients that want to vibrate, instead
 * see {@link #shouldVibrate(int)}.
 *
 * @param vibrateType The type of vibrate. One of
 * {@link #VIBRATE_TYPE_NOTIFICATION} or
 * {@link #VIBRATE_TYPE_RINGER}.
 * @return The vibrate setting, one of {@link #VIBRATE_SETTING_ON},
 * {@link #VIBRATE_SETTING_OFF}, or
 * {@link #VIBRATE_SETTING_ONLY_SILENT}.
 * @see #setVibrateSetting(int, int)
 * @see #shouldVibrate(int)
 * @deprecated Applications should maintain their own vibrate policy based on
 * current ringer mode that can be queried via {@link #getRingerMode()}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getVibrateSetting(vibrateType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.getVibrateSetting(vibrateType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.getCurrentIterationFraction:COMMENT
Method Modifier: private     
Comment:/**
 * Calculates the fraction of the current iteration, taking into account whether the animation
 * should be played backwards. E.g. When the animation is played backwards in an iteration,
 * the fraction for that iteration will go from 1f to 0f.
 */

Body of Frist Method:
{
    fraction = clampFraction(fraction);
    int iteration = getCurrentIteration(fraction);
    float currentFraction = fraction - iteration;
    return shouldPlayBackward(iteration) ? 1f - currentFraction : currentFraction;
}
Body of Second Method:
{
    fraction = clampFraction(fraction);
    int iteration = getCurrentIteration(fraction);
    float currentFraction = fraction - iteration;
    return shouldPlayBackward(iteration, inReverse) ? 1f - currentFraction : currentFraction;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbPort.dataRoleToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(role) {
        case 0:
            return "no-data";
        case DATA_ROLE_HOST:
            return "host";
        case DATA_ROLE_DEVICE:
            return "device";
        default:
            return Integer.toString(role);
    }
}
Body of Second Method:
{
    switch(role) {
        case DATA_ROLE_NONE:
            return "no-data";
        case DATA_ROLE_HOST:
            return "host";
        case DATA_ROLE_DEVICE:
            return "device";
        default:
            return Integer.toString(role);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setVibrateSetting:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the setting for when the vibrate type should vibrate.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param vibrateType The type of vibrate. One of
 * {@link #VIBRATE_TYPE_NOTIFICATION} or
 * {@link #VIBRATE_TYPE_RINGER}.
 * @param vibrateSetting The vibrate setting, one of
 * {@link #VIBRATE_SETTING_ON},
 * {@link #VIBRATE_SETTING_OFF}, or
 * {@link #VIBRATE_SETTING_ONLY_SILENT}.
 * @see #getVibrateSetting(int)
 * @see #shouldVibrate(int)
 * @deprecated Applications should maintain their own vibrate policy based on
 * current ringer mode that can be queried via {@link #getRingerMode()}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setVibrateSetting(vibrateType, vibrateSetting);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.setVibrateSetting(vibrateType, vibrateSetting);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.SurfaceTextureRenderer.drawIntoSurfaces:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */

Body of Frist Method:
{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError("before updateTexImage");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, "Dropping preview frame.");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, "Surface abandoned, dropping frame. ", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError("glReadPixels");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}
Body of Second Method:
{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError("before updateTexImage");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, "Dropping preview frame.");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, "Surface abandoned, dropping frame. ", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            try {
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                // Should never hit this.
                throw new IllegalStateException("Surface abandoned, skipping drawFrame...", e);
            }
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError("glReadPixels");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkCapabilities.getCapabilities:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets all the capabilities set on this {@code NetworkCapability} instance.
 *
 * @return an array of {@code NetworkCapabilities.NET_CAPABILITY_*} values
 * for this instance.
 * @hide
 */

Body of Frist Method:
{
    return enumerateBits(mNetworkCapabilities);
}
Body of Second Method:
{
    return BitUtils.unpackBits(mNetworkCapabilities);
}
------------------------
Find a silently evolved API code:android.content.res.AssetManager.getResourceValue:COMMENT
Method Modifier: default     final       
Comment:/**
 * Populates {@code outValue} with the data associated a particular
 * resource identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param densityDpi the density bucket for which to load the resource
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */

Body of Frist Method:
{
    final int block = loadResourceValue(resId, (short) densityDpi, outValue, resolveRefs);
    if (block < 0) {
        return false;
    }
    if (outValue.type == TypedValue.TYPE_STRING) {
        outValue.string = mStringBlocks[block].get(outValue.data);
    }
    return true;
}
Body of Second Method:
{
    synchronized (this) {
        final int block = loadResourceValue(resId, (short) densityDpi, outValue, resolveRefs);
        if (block < 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            outValue.string = mStringBlocks[block].get(outValue.data);
        }
        return true;
    }
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbPort.checkRoles:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    Preconditions.checkArgumentInRange(powerRole, 0, POWER_ROLE_SINK, "powerRole");
    Preconditions.checkArgumentInRange(dataRole, 0, DATA_ROLE_DEVICE, "dataRole");
}
Body of Second Method:
{
    Preconditions.checkArgumentInRange(powerRole, POWER_ROLE_NONE, POWER_ROLE_SINK, "powerRole");
    Preconditions.checkArgumentInRange(dataRole, DATA_ROLE_NONE, DATA_ROLE_DEVICE, "dataRole");
}
------------------------
Find a silently evolved API code:android.view.Display.getSize:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the size of the display, in pixels.
 * Value returned by this method does not necessarily represent the actual raw size
 * (native resolution) of the display.
 * <p>
 * 1. The returned size may be adjusted to exclude certain system decor elements
 * that are always visible.
 * </p><p>
 * 2. It may be scaled to provide compatibility with older applications that
 * were originally designed for smaller displays.
 * </p><p>
 * 3. It can be different depending on the WindowManager to which the display belongs.
 * </p><p>
 * - If requested from non-Activity context (e.g. Application context via
 * {@code (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE)})
 * it will report the size of the entire display based on current rotation and with subtracted
 * system decoration areas.
 * </p><p>
 * - If requested from activity (either using {@code getWindowManager()} or
 * {@code (WindowManager) getSystemService(Context.WINDOW_SERVICE)}) resulting size will
 * correspond to current app window size. In this case it can be smaller than physical size in
 * multi-window mode.
 * </p><p>
 * Typically for the purposes of layout apps should make a request from activity context
 * to obtain size available for the app content.
 * </p>
 *
 * @param outSize A {@link Point} object to receive the size information.
 */

Body of Frist Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(mTempMetrics, mDisplayAdjustments);
        outSize.x = mTempMetrics.widthPixels;
        outSize.y = mTempMetrics.heightPixels;
    }
}
Body of Second Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(mTempMetrics, getDisplayAdjustments());
        outSize.x = mTempMetrics.widthPixels;
        outSize.y = mTempMetrics.heightPixels;
    }
}
------------------------
Find a silently evolved API code:android.text.Hyphenator.init:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Load hyphenation patterns at initialization time. We want to have patterns
 * for all locales loaded and ready to use so we don't have to do any file IO
 * on the UI thread when drawing text in different locales.
 *
 * @hide
 */

Body of Frist Method:
{
    sMap.put(null, null);
    // TODO: replace this with a discovery-based method that looks into /system/usr/hyphen-data
    String[] availableLanguages = { "as", "bn", "cy", "da", "de-1901", "de-1996", "de-CH-1901", "en-GB", "en-US", "es", "et", "eu", "fr", "ga", "gu", "hi", "hr", "hu", "hy", "kn", "ml", "mn-Cyrl", "mr", "nb", "nn", "or", "pa", "pt", "sl", "ta", "te", "tk", "und-Ethi" };
    for (int i = 0; i < availableLanguages.length; i++) {
        String languageTag = availableLanguages[i];
        Hyphenator h = loadHyphenator(languageTag);
        if (h != null) {
            sMap.put(Locale.forLanguageTag(languageTag), h);
        }
    }
    for (int i = 0; i < LOCALE_FALLBACK_DATA.length; i++) {
        String language = LOCALE_FALLBACK_DATA[i][0];
        String fallback = LOCALE_FALLBACK_DATA[i][1];
        sMap.put(Locale.forLanguageTag(language), sMap.get(Locale.forLanguageTag(fallback)));
    }
}
Body of Second Method:
{
    sMap.put(null, null);
    for (int i = 0; i < AVAILABLE_LANGUAGES.length; i++) {
        HyphenationData data = AVAILABLE_LANGUAGES[i];
        Hyphenator h = loadHyphenator(data);
        if (h != null) {
            sMap.put(Locale.forLanguageTag(data.mLanguageTag), h);
        }
    }
    for (int i = 0; i < LOCALE_FALLBACK_DATA.length; i++) {
        String language = LOCALE_FALLBACK_DATA[i][0];
        String fallback = LOCALE_FALLBACK_DATA[i][1];
        sMap.put(Locale.forLanguageTag(language), sMap.get(Locale.forLanguageTag(fallback)));
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getBluetoothLeAdvertiser:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */

Body of Frist Method:
{
    if (!getLeAccess())
        return null;
    if (!isMultipleAdvertisementSupported() && !isPeripheralModeSupported()) {
        Log.e(TAG, "Bluetooth LE advertising not supported");
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
Body of Second Method:
{
    if (!getLeAccess())
        return null;
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
------------------------
Find a silently evolved API code:android.content.pm.ActivityInfo.isFixedOrientation:COMMENT
<android.content.pm.ActivityInfo: boolean isFixedOrientation()>
default     hidden      ->public      hidden      
Method Modifier: public      default     hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Returns true if the activity's orientation is fixed.
 * @hide
 */

Body of Frist Method:
{
    return screenOrientation == SCREEN_ORIENTATION_LANDSCAPE || screenOrientation == SCREEN_ORIENTATION_PORTRAIT || screenOrientation == SCREEN_ORIENTATION_SENSOR_LANDSCAPE || screenOrientation == SCREEN_ORIENTATION_SENSOR_PORTRAIT || screenOrientation == SCREEN_ORIENTATION_REVERSE_LANDSCAPE || screenOrientation == SCREEN_ORIENTATION_REVERSE_PORTRAIT || screenOrientation == SCREEN_ORIENTATION_USER_LANDSCAPE || screenOrientation == SCREEN_ORIENTATION_USER_PORTRAIT || screenOrientation == SCREEN_ORIENTATION_LOCKED;
}
Body of Second Method:
{
    return isFixedOrientationLandscape() || isFixedOrientationPortrait() || screenOrientation == SCREEN_ORIENTATION_LOCKED;
}
------------------------
Find a silently evolved API code:android.content.res.AssetManager.getResourceBagText:COMMENT
Method Modifier: default     final       
Comment:/**
 * Retrieves the string value associated with a particular resource
 * identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param bagEntryId
 * @return the string value, or {@code null}
 */

Body of Frist Method:
{
    synchronized (this) {
        final TypedValue outValue = mValue;
        final int block = loadResourceBagValue(resId, bagEntryId, outValue, true);
        if (block < 0) {
            return null;
        }
        if (outValue.type == TypedValue.TYPE_STRING) {
            return mStringBlocks[block].get(outValue.data);
        }
        return outValue.coerceToString();
    }
}
Body of Second Method:
{
    synchronized (this) {
        final TypedValue outValue = mValue;
        final int block = loadResourceBagValue(resId, bagEntryId, outValue, true);
        if (block < 0) {
            return null;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            return mStringBlocks[block].get(outValue.data);
        }
        return outValue.coerceToString();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setRingerMode:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the ringer mode.
 * <p>
 * Silent mode will mute the volume and will not vibrate. Vibrate mode will
 * mute the volume and vibrate. Normal mode will be audible and may vibrate
 * according to user settings.
 * <p>This method has no effect if the device implements a fixed volume policy
 * as indicated by {@link #isVolumeFixed()}.
 * * <p>From N onward, ringer mode adjustments that would toggle Do Not Disturb are not allowed
 * unless the app has been granted Do Not Disturb Access.
 * See {@link NotificationManager#isNotificationPolicyAccessGranted()}.
 * @param ringerMode The ringer mode, one of {@link #RINGER_MODE_NORMAL},
 * {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
 * @see #getRingerMode()
 * @see #isVolumeFixed()
 */

Body of Frist Method:
{
    if (!isValidRingerMode(ringerMode)) {
        return;
    }
    IAudioService service = getService();
    try {
        service.setRingerModeExternal(ringerMode, getContext().getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isValidRingerMode(ringerMode)) {
        return;
    }
    final IAudioService service = getService();
    try {
        service.setRingerModeExternal(ringerMode, getContext().getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getRingerMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current ringtone mode.
 *
 * @return The current ringtone mode, one of {@link #RINGER_MODE_NORMAL},
 * {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
 * @see #setRingerMode(int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getRingerModeExternal();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.getRingerModeExternal();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telecom.VideoCallImpl.setCamera:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    try {
        mVideoProvider.setCamera(cameraId);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        Log.w(this, "setCamera: cameraId=%s, calling=%s", cameraId, mCallingPackageName);
        mVideoProvider.setCamera(cameraId, mCallingPackageName, mTargetSdkVersion);
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getOtaSpNumberSchema:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get OTASP number schema for the default phone.
 *
 * @param defaultValue default value
 * @return OTA SP number schema
 *
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    return getOtaSpNumberSchemaForPhone(phoneId, defaultValue);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    return getOtaSpNumberSchemaForPhone(phoneId, defaultValue);
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.siftDown:COMMENT
Method Modifier: private     final       
Comment:/**
 * Helper function for heap sort.
 *
 * @param index Index of the element to sift down.
 * @param array Span array to be sorted.
 * @param size Current heap size.
 * @param priority Priorities of the spans
 * @param insertionOrder Insertion orders of the spans
 * @param <T> Span object type.
 */

Body of Frist Method:
{
    T v = array[index];
    int prio = priority[index];
    int insertOrder = insertionOrder[index];
    int left = 2 * index + 1;
    while (left < size) {
        if (left < size - 1 && compareSpans(left, left + 1, priority, insertionOrder) < 0) {
            left++;
        }
        if (compareSpans(index, left, priority, insertionOrder) >= 0) {
            break;
        }
        array[index] = array[left];
        priority[index] = priority[left];
        insertionOrder[index] = insertionOrder[left];
        index = left;
        left = 2 * index + 1;
    }
    array[index] = v;
    priority[index] = prio;
    insertionOrder[index] = insertOrder;
}
Body of Second Method:
{
    int left = 2 * index + 1;
    while (left < size) {
        if (left < size - 1 && compareSpans(left, left + 1, priority, insertionOrder) < 0) {
            left++;
        }
        if (compareSpans(index, left, priority, insertionOrder) >= 0) {
            break;
        }
        final T tmpSpan = array[index];
        array[index] = array[left];
        array[left] = tmpSpan;
        final int tmpPriority = priority[index];
        priority[index] = priority[left];
        priority[left] = tmpPriority;
        final int tmpOrder = insertionOrder[index];
        insertionOrder[index] = insertionOrder[left];
        insertionOrder[left] = tmpOrder;
        index = left;
        left = 2 * index + 1;
    }
}
------------------------
Find a silently evolved API code:android.location.Location.set:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the contents of the location to the values from the given location.
 */

Body of Frist Method:
{
    mProvider = l.mProvider;
    mTime = l.mTime;
    mElapsedRealtimeNanos = l.mElapsedRealtimeNanos;
    mFieldsMask = l.mFieldsMask;
    mLatitude = l.mLatitude;
    mLongitude = l.mLongitude;
    mAltitude = l.mAltitude;
    mSpeed = l.mSpeed;
    mBearing = l.mBearing;
    mAccuracy = l.mAccuracy;
    mExtras = (l.mExtras == null) ? null : new Bundle(l.mExtras);
}
Body of Second Method:
{
    mProvider = l.mProvider;
    mTime = l.mTime;
    mElapsedRealtimeNanos = l.mElapsedRealtimeNanos;
    mFieldsMask = l.mFieldsMask;
    mLatitude = l.mLatitude;
    mLongitude = l.mLongitude;
    mAltitude = l.mAltitude;
    mSpeed = l.mSpeed;
    mBearing = l.mBearing;
    mHorizontalAccuracyMeters = l.mHorizontalAccuracyMeters;
    mVerticalAccuracyMeters = l.mVerticalAccuracyMeters;
    mSpeedAccuracyMetersPerSecond = l.mSpeedAccuracyMetersPerSecond;
    mBearingAccuracyDegrees = l.mBearingAccuracyDegrees;
    mExtras = (l.mExtras == null) ? null : new Bundle(l.mExtras);
}
------------------------
Find a silently evolved API code:android.text.TextLine.handleText:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Utility function for measuring and rendering text.  The text must
 * not include a tab.
 *
 * @param wp the working paint
 * @param start the start of the text
 * @param end the end of the text
 * @param runIsRtl true if the run is right-to-left
 * @param c the canvas, can be null if rendering is not needed
 * @param x the edge of the run closest to the leading margin
 * @param top the top of the line
 * @param y the baseline
 * @param bottom the bottom of the line
 * @param fmi receives metrics information, can be null
 * @param needWidth true if the width of the run is needed
 * @param offset the offset for the purpose of measuring
 * @return the signed width of the run based on the run direction; only
 * valid if needWidth is true
 */

Body of Frist Method:
{
    // Get metrics first (even for empty strings or "0" width runs)
    if (fmi != null) {
        expandMetricsFromPaint(fmi, wp);
    }
    int runLen = end - start;
    // No need to do anything if the run width is "0"
    if (runLen == 0) {
        return 0f;
    }
    float ret = 0;
    if (needWidth || (c != null && (wp.bgColor != 0 || wp.underlineColor != 0 || runIsRtl))) {
        if (mCharsValid) {
            ret = wp.getRunAdvance(mChars, start, end, contextStart, contextEnd, runIsRtl, offset);
        } else {
            int delta = mStart;
            ret = wp.getRunAdvance(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, runIsRtl, delta + offset);
        }
    }
    if (c != null) {
        if (runIsRtl) {
            x -= ret;
        }
        if (wp.bgColor != 0) {
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            wp.setColor(wp.bgColor);
            wp.setStyle(Paint.Style.FILL);
            c.drawRect(x, top, x + ret, bottom, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
        }
        if (wp.underlineColor != 0) {
            // kStdUnderline_Offset = 1/9, defined in SkTextFormatParams.h
            float underlineTop = y + wp.baselineShift + (1.0f / 9.0f) * wp.getTextSize();
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            boolean previousAntiAlias = wp.isAntiAlias();
            wp.setStyle(Paint.Style.FILL);
            wp.setAntiAlias(true);
            wp.setColor(wp.underlineColor);
            c.drawRect(x, underlineTop, x + ret, underlineTop + wp.underlineThickness, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
            wp.setAntiAlias(previousAntiAlias);
        }
        drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y + wp.baselineShift);
    }
    return runIsRtl ? -ret : ret;
}
Body of Second Method:
{
    wp.setWordSpacing(mAddedWidth);
    // Get metrics first (even for empty strings or "0" width runs)
    if (fmi != null) {
        expandMetricsFromPaint(fmi, wp);
    }
    int runLen = end - start;
    // No need to do anything if the run width is "0"
    if (runLen == 0) {
        return 0f;
    }
    float ret = 0;
    if (needWidth || (c != null && (wp.bgColor != 0 || wp.underlineColor != 0 || runIsRtl))) {
        if (mCharsValid) {
            ret = wp.getRunAdvance(mChars, start, end, contextStart, contextEnd, runIsRtl, offset);
        } else {
            int delta = mStart;
            ret = wp.getRunAdvance(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, runIsRtl, delta + offset);
        }
    }
    if (c != null) {
        if (runIsRtl) {
            x -= ret;
        }
        if (wp.bgColor != 0) {
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            wp.setColor(wp.bgColor);
            wp.setStyle(Paint.Style.FILL);
            c.drawRect(x, top, x + ret, bottom, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
        }
        if (wp.underlineColor != 0) {
            // kStdUnderline_Offset = 1/9, defined in SkTextFormatParams.h
            float underlineTop = y + wp.baselineShift + (1.0f / 9.0f) * wp.getTextSize();
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            boolean previousAntiAlias = wp.isAntiAlias();
            wp.setStyle(Paint.Style.FILL);
            wp.setAntiAlias(true);
            wp.setColor(wp.underlineColor);
            c.drawRect(x, underlineTop, x + ret, underlineTop + wp.underlineThickness, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
            wp.setAntiAlias(previousAntiAlias);
        }
        drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y + wp.baselineShift);
    }
    return runIsRtl ? -ret : ret;
}
------------------------
Find a silently evolved API code:android.graphics.Path.addCircle:COMMENT
Method Modifier: public      
Comment:/**
 * Add a closed circle contour to the path
 *
 * @param x   The x-coordinate of the center of a circle to add to the path
 * @param y   The y-coordinate of the center of a circle to add to the path
 * @param radius The radius of a circle to add to the path
 * @param dir    The direction to wind the circle's contour
 */

Body of Frist Method:
{
    isSimplePath = false;
    native_addCircle(mNativePath, x, y, radius, dir.nativeInt);
}
Body of Second Method:
{
    isSimplePath = false;
    nAddCircle(mNativePath, x, y, radius, dir.nativeInt);
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.setDisconnected:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Sets a call's state to disconnected.
 *
 * @param callId The unique ID of the call whose state is changing to disconnected.
 * @param disconnectCause The reason for the disconnection, as described by
 * {@link android.telecomm.DisconnectCause}.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setDisconnected(callId, disconnectCause);
        } catch (RemoteException e) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setDisconnected(callId, disconnectCause, Log.getExternalSession());
        } catch (RemoteException e) {
        }
    }
}
------------------------
Find a silently evolved API code:android.service.voice.VoiceInteractionSession.dump:COMMENT
Method Modifier: public      
Comment:/**
 * Print the Service's state into the given stream.  This gets invoked by
 * {@link VoiceInteractionSessionService} when its Service
 * {@link android.app.Service#dump} method is called.
 *
 * @param prefix Text to print at the front of each line.
 * @param fd The raw file descriptor that the dump is being sent to.
 * @param writer The PrintWriter to which you should dump your state.  This will be
 * closed for you after you return.
 * @param args additional arguments to the dump request.
 */

Body of Frist Method:
{
    writer.print(prefix);
    writer.print("mToken=");
    writer.println(mToken);
    writer.print(prefix);
    writer.print("mTheme=#");
    writer.println(Integer.toHexString(mTheme));
    writer.print(prefix);
    writer.print("mInitialized=");
    writer.println(mInitialized);
    writer.print(prefix);
    writer.print("mWindowAdded=");
    writer.print(mWindowAdded);
    writer.print(" mWindowVisible=");
    writer.println(mWindowVisible);
    writer.print(prefix);
    writer.print("mWindowWasVisible=");
    writer.print(mWindowWasVisible);
    writer.print(" mInShowWindow=");
    writer.println(mInShowWindow);
    if (mActiveRequests.size() > 0) {
        writer.print(prefix);
        writer.println("Active requests:");
        String innerPrefix = prefix + "    ";
        for (int i = 0; i < mActiveRequests.size(); i++) {
            Request req = mActiveRequests.valueAt(i);
            writer.print(prefix);
            writer.print("  #");
            writer.print(i);
            writer.print(": ");
            writer.println(req);
            req.dump(innerPrefix, fd, writer, args);
        }
    }
}
Body of Second Method:
{
    writer.print(prefix);
    writer.print("mToken=");
    writer.println(mToken);
    writer.print(prefix);
    writer.print("mTheme=#");
    writer.println(Integer.toHexString(mTheme));
    writer.print(prefix);
    writer.print("mUiEnabled=");
    writer.println(mUiEnabled);
    writer.print(" mInitialized=");
    writer.println(mInitialized);
    writer.print(prefix);
    writer.print("mWindowAdded=");
    writer.print(mWindowAdded);
    writer.print(" mWindowVisible=");
    writer.println(mWindowVisible);
    writer.print(prefix);
    writer.print("mWindowWasVisible=");
    writer.print(mWindowWasVisible);
    writer.print(" mInShowWindow=");
    writer.println(mInShowWindow);
    if (mActiveRequests.size() > 0) {
        writer.print(prefix);
        writer.println("Active requests:");
        String innerPrefix = prefix + "    ";
        for (int i = 0; i < mActiveRequests.size(); i++) {
            Request req = mActiveRequests.valueAt(i);
            writer.print(prefix);
            writer.print("  #");
            writer.print(i);
            writer.print(": ");
            writer.println(req);
            req.dump(innerPrefix, fd, writer, args);
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@link Parcelable#writeToParcel}
 */

Body of Frist Method:
{
    out.writeInt(mGsmSignalStrength);
    out.writeInt(mGsmBitErrorRate);
    out.writeInt(mCdmaDbm);
    out.writeInt(mCdmaEcio);
    out.writeInt(mEvdoDbm);
    out.writeInt(mEvdoEcio);
    out.writeInt(mEvdoSnr);
    out.writeInt(mLteSignalStrength);
    out.writeInt(mLteRsrp);
    out.writeInt(mLteRsrq);
    out.writeInt(mLteRssnr);
    out.writeInt(mLteCqi);
    out.writeInt(mTdScdmaRscp);
    out.writeInt(isGsm ? 1 : 0);
}
Body of Second Method:
{
    out.writeInt(mGsmSignalStrength);
    out.writeInt(mGsmBitErrorRate);
    out.writeInt(mCdmaDbm);
    out.writeInt(mCdmaEcio);
    out.writeInt(mEvdoDbm);
    out.writeInt(mEvdoEcio);
    out.writeInt(mEvdoSnr);
    out.writeInt(mLteSignalStrength);
    out.writeInt(mLteRsrp);
    out.writeInt(mLteRsrq);
    out.writeInt(mLteRssnr);
    out.writeInt(mLteCqi);
    out.writeInt(mLteRsrpBoost);
    out.writeInt(mTdScdmaRscp);
    out.writeInt(isGsm ? 1 : 0);
}
------------------------
Find a silently evolved API code:android.graphics.Path.addRoundRect:COMMENT
Method Modifier: public      
Comment:/**
 * Add a closed round-rectangle contour to the path
 *
 * @param rx   The x-radius of the rounded corners on the round-rectangle
 * @param ry   The y-radius of the rounded corners on the round-rectangle
 * @param dir  The direction to wind the round-rectangle's contour
 */

Body of Frist Method:
{
    isSimplePath = false;
    native_addRoundRect(mNativePath, left, top, right, bottom, rx, ry, dir.nativeInt);
}
Body of Second Method:
{
    isSimplePath = false;
    nAddRoundRect(mNativePath, left, top, right, bottom, rx, ry, dir.nativeInt);
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.setMinute:COMMENT
Method Modifier: public      
Comment:/**
 * Set the current minute (0-59).
 */

Body of Frist Method:
{
    setMinuteInternal(minute, false);
}
Body of Second Method:
{
    setMinuteInternal(minute, FROM_EXTERNAL_API);
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.doAnimationFrame:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Processes a frame of the animation, adjusting the start time if needed.
 *
 * @param frameTime The frame time.
 * @return true if the animation has ended.
 * @hide
 */

Body of Frist Method:
{
    AnimationHandler handler = AnimationHandler.getInstance();
    if (mLastFrameTime == 0) {
        // First frame
        handler.addOneShotCommitCallback(this);
        if (mStartDelay > 0) {
            startAnimation();
        }
        if (mSeekFraction < 0) {
            mStartTime = frameTime;
        } else {
            long seekTime = (long) (getScaledDuration() * mSeekFraction);
            mStartTime = frameTime - seekTime;
            mSeekFraction = -1;
        }
        // allow start time to be compensated for jank
        mStartTimeCommitted = false;
    }
    mLastFrameTime = frameTime;
    if (mPaused) {
        mPauseTime = frameTime;
        handler.removeCallback(this);
        return;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
            // allow start time to be compensated for jank
            mStartTimeCommitted = false;
        }
        handler.addOneShotCommitCallback(this);
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The "current time" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    boolean finished = animateBasedOnTime(currentTime);
    if (finished) {
        endAnimation();
    }
}
Body of Second Method:
{
    if (mStartTime < 0) {
        // First frame. If there is start delay, start delay count down will happen *after* this
        // frame.
        mStartTime = mReversing ? frameTime : frameTime + (long) (mStartDelay * sDurationScale);
    }
    // Handle pause/resume
    if (mPaused) {
        mPauseTime = frameTime;
        removeAnimationCallback();
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    if (!mRunning) {
        // running animation. In the case of reversing, we want to run start delay in the end.
        if (mStartTime > frameTime && mSeekFraction == -1) {
            // right away.
            return false;
        } else {
            // If mRunning is not set by now, that means non-zero start delay,
            // no seeking, not reversing. At this point, start delay has passed.
            mRunning = true;
            startAnimation();
        }
    }
    if (mLastFrameTime < 0) {
        if (mSeekFraction >= 0) {
            long seekTime = (long) (getScaledDuration() * mSeekFraction);
            mStartTime = frameTime - seekTime;
            mSeekFraction = -1;
        }
        // allow start time to be compensated for jank
        mStartTimeCommitted = false;
    }
    mLastFrameTime = frameTime;
    // The frame time might be before the start time during the first frame of
    // an animation.  The "current time" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    boolean finished = animateBasedOnTime(currentTime);
    if (finished) {
        endAnimation();
    }
    return finished;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getSmsReceiveCapable:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get SMS receive capable from system property for the default phone.
 *
 * @param defaultValue default value
 * @return SMS receive capable
 *
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    return getSmsReceiveCapableForPhone(phoneId, defaultValue);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    return getSmsReceiveCapableForPhone(phoneId, defaultValue);
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbPort.powerRoleToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(role) {
        case 0:
            return "no-power";
        case POWER_ROLE_SOURCE:
            return "source";
        case POWER_ROLE_SINK:
            return "sink";
        default:
            return Integer.toString(role);
    }
}
Body of Second Method:
{
    switch(role) {
        case POWER_ROLE_NONE:
            return "no-power";
        case POWER_ROLE_SOURCE:
            return "source";
        case POWER_ROLE_SINK:
            return "sink";
        default:
            return Integer.toString(role);
    }
}
------------------------
Find a silently evolved API code:android.provider.CalendarContract.CalendarAlerts.scheduleAlarm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Schedules an alarm intent with the system AlarmManager that will
 * notify listeners when a reminder should be fired. The provider will
 * keep scheduled reminders up to date but apps may use this to
 * implement snooze functionality without modifying the reminders table.
 * Scheduled alarms will generate an intent using
 * {@link #ACTION_EVENT_REMINDER}. TODO Move to provider
 *
 * @param context A context for referencing system resources
 * @param manager The AlarmManager to use or null
 * @param alarmTime The time to fire the intent in UTC millis since
 * epoch
 * @hide
 */

Body of Frist Method:
{
    if (DEBUG) {
        Time time = new Time();
        time.set(alarmTime);
        String schedTime = time.format(" %a, %b %d, %Y %I:%M%P");
        Log.d(TAG, "Schedule alarm at " + alarmTime + " " + schedTime);
    }
    if (manager == null) {
        manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    }
    Intent intent = new Intent(ACTION_EVENT_REMINDER);
    intent.setData(ContentUris.withAppendedId(CalendarContract.CONTENT_URI, alarmTime));
    intent.putExtra(ALARM_TIME, alarmTime);
    PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);
    manager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, alarmTime, pi);
}
Body of Second Method:
{
    if (DEBUG) {
        Time time = new Time();
        time.set(alarmTime);
        String schedTime = time.format(" %a, %b %d, %Y %I:%M%P");
        Log.d(TAG, "Schedule alarm at " + alarmTime + " " + schedTime);
    }
    if (manager == null) {
        manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    }
    Intent intent = new Intent(ACTION_EVENT_REMINDER);
    intent.setData(ContentUris.withAppendedId(CalendarContract.CONTENT_URI, alarmTime));
    intent.putExtra(ALARM_TIME, alarmTime);
    intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
    PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);
    manager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, alarmTime, pi);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setAnonymousIdentity:COMMENT
Method Modifier: public      
Comment:/**
 * Set anonymous identity. This is used as the unencrypted identity with
 * certain EAP types
 * @param anonymousIdentity the anonymous identity
 */

Body of Frist Method:
{
    setFieldValue(ANON_IDENTITY_KEY, anonymousIdentity, "");
}
Body of Second Method:
{
    setFieldValue(ANON_IDENTITY_KEY, anonymousIdentity);
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater.rInflate:COMMENT
Method Modifier: default     
Comment:/**
 * Recursive method used to descend down the xml hierarchy and instantiate
 * views, instantiate their children, and then call onFinishInflate().
 * <p>
 * <strong>Note:</strong> Default visibility so the BridgeInflater can
 * override it.
 */

Body of Frist Method:
{
    final int depth = parser.getDepth();
    int type;
    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        final String name = parser.getName();
        if (TAG_REQUEST_FOCUS.equals(name)) {
            parseRequestFocus(parser, parent);
        } else if (TAG_TAG.equals(name)) {
            parseViewTag(parser, parent, attrs);
        } else if (TAG_INCLUDE.equals(name)) {
            if (parser.getDepth() == 0) {
                throw new InflateException("<include /> cannot be the root element");
            }
            parseInclude(parser, context, parent, attrs);
        } else if (TAG_MERGE.equals(name)) {
            throw new InflateException("<merge /> must be the root element");
        } else {
            final View view = createViewFromTag(parent, name, context, attrs);
            final ViewGroup viewGroup = (ViewGroup) parent;
            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
            rInflateChildren(parser, view, attrs, true);
            viewGroup.addView(view, params);
        }
    }
    if (finishInflate) {
        parent.onFinishInflate();
    }
}
Body of Second Method:
{
    final int depth = parser.getDepth();
    int type;
    boolean pendingRequestFocus = false;
    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        final String name = parser.getName();
        if (TAG_REQUEST_FOCUS.equals(name)) {
            pendingRequestFocus = true;
            consumeChildElements(parser);
        } else if (TAG_TAG.equals(name)) {
            parseViewTag(parser, parent, attrs);
        } else if (TAG_INCLUDE.equals(name)) {
            if (parser.getDepth() == 0) {
                throw new InflateException("<include /> cannot be the root element");
            }
            parseInclude(parser, context, parent, attrs);
        } else if (TAG_MERGE.equals(name)) {
            throw new InflateException("<merge /> must be the root element");
        } else {
            final View view = createViewFromTag(parent, name, context, attrs);
            final ViewGroup viewGroup = (ViewGroup) parent;
            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
            rInflateChildren(parser, view, attrs, true);
            viewGroup.addView(view, params);
        }
    }
    if (pendingRequestFocus) {
        parent.restoreDefaultFocus();
    }
    if (finishInflate) {
        parent.onFinishInflate();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path.rewind:COMMENT
Method Modifier: public      
Comment:/**
 * Rewinds the path: clears any lines and curves from the path but
 * keeps the internal data structure for faster reuse.
 */

Body of Frist Method:
{
    isSimplePath = true;
    mLastDirection = null;
    if (rects != null)
        rects.setEmpty();
    native_rewind(mNativePath);
}
Body of Second Method:
{
    isSimplePath = true;
    mLastDirection = null;
    if (rects != null)
        rects.setEmpty();
    nRewind(mNativePath);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.OutputConfiguration.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */

Body of Frist Method:
{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        boolean iSSurfaceEqual = mSurface == other.mSurface && mConfiguredGenerationId == other.mConfiguredGenerationId;
        if (mIsDeferredConfig) {
            Log.i(TAG, "deferred config has the same surface");
            iSSurfaceEqual = true;
        }
        return mRotation == other.mRotation && iSSurfaceEqual && mConfiguredSize.equals(other.mConfiguredSize) && mConfiguredFormat == other.mConfiguredFormat && mConfiguredDataspace == other.mConfiguredDataspace && mSurfaceGroupId == other.mSurfaceGroupId && mSurfaceType == other.mSurfaceType && mIsDeferredConfig == other.mIsDeferredConfig;
    }
    return false;
}
Body of Second Method:
{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId)
            return false;
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionInfo.givePrintableIccid:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String iccIdToPrint = null;
    if (iccId != null) {
        if (iccId.length() > 9 && !Build.IS_DEBUGGABLE) {
            iccIdToPrint = iccId.substring(0, 9) + "XXXXXXXXXXX";
        } else {
            iccIdToPrint = iccId;
        }
    }
    return iccIdToPrint;
}
Body of Second Method:
{
    String iccIdToPrint = null;
    if (iccId != null) {
        if (iccId.length() > 9 && !Build.IS_DEBUGGABLE) {
            iccIdToPrint = iccId.substring(0, 9) + Rlog.pii(false, iccId.substring(9));
        } else {
            iccIdToPrint = iccId;
        }
    }
    return iccIdToPrint;
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.findIndexHinted:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Find first stats index that matches the requested parameters, starting
 * search around the hinted index as an optimization.
 */

Body of Frist Method:
{
    for (int offset = 0; offset < size; offset++) {
        final int halfOffset = offset / 2;
        // search outwards from hint index, alternating forward and backward
        final int i;
        if (offset % 2 == 0) {
            i = (hintIndex + halfOffset) % size;
        } else {
            i = (size + hintIndex - halfOffset - 1) % size;
        }
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && roaming == this.roaming[i] && Objects.equals(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
Body of Second Method:
{
    for (int offset = 0; offset < size; offset++) {
        final int halfOffset = offset / 2;
        // search outwards from hint index, alternating forward and backward
        final int i;
        if (offset % 2 == 0) {
            i = (hintIndex + halfOffset) % size;
        } else {
            i = (size + hintIndex - halfOffset - 1) % size;
        }
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && metered == this.metered[i] && roaming == this.roaming[i] && Objects.equals(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.view.RenderNode.discardDisplayList:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Reset native resources. This is called when cleaning up the state of display lists
 * during destruction of hardware resources, to ensure that we do not hold onto
 * obsolete resources after related resources are gone.
 */

Body of Frist Method:
{
    if (!mValid)
        return;
    nSetDisplayList(mNativeRenderNode, 0);
    mValid = false;
}
Body of Second Method:
{
    nSetDisplayList(mNativeRenderNode, 0);
}
------------------------
Find a silently evolved API code:android.text.TextUtils.doesNotNeedBidi:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    for (int i = start; i < end; i++) {
        if (s.charAt(i) >= FIRST_RIGHT_TO_LEFT) {
            return false;
        }
    }
    return true;
}
Body of Second Method:
{
    final int end = start + len;
    for (int i = start; i < end; i++) {
        if (couldAffectRtl(text[i])) {
            return false;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.deleteStatusToPublicStatus:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    switch(status) {
        case DELETE_SUCCEEDED:
            return PackageInstaller.STATUS_SUCCESS;
        case DELETE_FAILED_INTERNAL_ERROR:
            return PackageInstaller.STATUS_FAILURE;
        case DELETE_FAILED_DEVICE_POLICY_MANAGER:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_USER_RESTRICTED:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_OWNER_BLOCKED:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_ABORTED:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        default:
            return PackageInstaller.STATUS_FAILURE;
    }
}
Body of Second Method:
{
    switch(status) {
        case DELETE_SUCCEEDED:
            return PackageInstaller.STATUS_SUCCESS;
        case DELETE_FAILED_INTERNAL_ERROR:
            return PackageInstaller.STATUS_FAILURE;
        case DELETE_FAILED_DEVICE_POLICY_MANAGER:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_USER_RESTRICTED:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_OWNER_BLOCKED:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_ABORTED:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case DELETE_FAILED_USED_SHARED_LIBRARY:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        default:
            return PackageInstaller.STATUS_FAILURE;
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.updateHourFormat:COMMENT
Method Modifier: private     
Comment:/**
 * Updates hour formatting based on the current locale and 24-hour mode.
 * <p>
 * Determines how the hour should be formatted, sets member variables for
 * leading zero and starting hour, and sets the hour view's presentation.
 */

Body of Frist Method:
{
    final String bestDateTimePattern = DateFormat.getBestDateTimePattern(mLocale, mIs24Hour ? "Hm" : "hm");
    final int lengthPattern = bestDateTimePattern.length();
    boolean showLeadingZero = false;
    char hourFormat = '\0';
    for (int i = 0; i < lengthPattern; i++) {
        final char c = bestDateTimePattern.charAt(i);
        if (c == 'H' || c == 'h' || c == 'K' || c == 'k') {
            hourFormat = c;
            if (i + 1 < lengthPattern && c == bestDateTimePattern.charAt(i + 1)) {
                showLeadingZero = true;
            }
            break;
        }
    }
    mHourFormatShowLeadingZero = showLeadingZero;
    mHourFormatStartsAtZero = hourFormat == 'K' || hourFormat == 'H';
    // Update hour text field.
    final int minHour = mHourFormatStartsAtZero ? 0 : 1;
    final int maxHour = (mIs24Hour ? 23 : 11) + minHour;
    mHourView.setRange(minHour, maxHour);
    mHourView.setShowLeadingZeroes(mHourFormatShowLeadingZero);
}
Body of Second Method:
{
    final String bestDateTimePattern = DateFormat.getBestDateTimePattern(mLocale, mIs24Hour ? "Hm" : "hm");
    final int lengthPattern = bestDateTimePattern.length();
    boolean showLeadingZero = false;
    char hourFormat = '\0';
    for (int i = 0; i < lengthPattern; i++) {
        final char c = bestDateTimePattern.charAt(i);
        if (c == 'H' || c == 'h' || c == 'K' || c == 'k') {
            hourFormat = c;
            if (i + 1 < lengthPattern && c == bestDateTimePattern.charAt(i + 1)) {
                showLeadingZero = true;
            }
            break;
        }
    }
    mHourFormatShowLeadingZero = showLeadingZero;
    mHourFormatStartsAtZero = hourFormat == 'K' || hourFormat == 'H';
    // Update hour text field.
    final int minHour = mHourFormatStartsAtZero ? 0 : 1;
    final int maxHour = (mIs24Hour ? 23 : 11) + minHour;
    mHourView.setRange(minHour, maxHour);
    mHourView.setShowLeadingZeroes(mHourFormatShowLeadingZero);
    final String[] digits = DecimalFormatSymbols.getInstance(mLocale).getDigitStrings();
    int maxCharLength = 0;
    for (int i = 0; i < 10; i++) {
        maxCharLength = Math.max(maxCharLength, digits[i].length());
    }
    mTextInputPickerView.setHourFormat(maxCharLength * 2);
}
------------------------
Find a silently evolved API code:android.content.IntentSender.getCreatorUserHandle:COMMENT
Method Modifier: public      
Comment:/**
 * Return the user handle of the application that created this
 * PendingIntent, that is the user under which you will actually be
 * sending the Intent.  The returned UserHandle is supplied by the system, so
 * that an application can not spoof its user.  See
 * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for
 * more explanation of user handles.
 *
 * @return The user handle of the PendingIntent, or null if there is
 * none associated with it.
 */

Body of Frist Method:
{
    try {
        int uid = ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
        return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}
Body of Second Method:
{
    try {
        int uid = ActivityManager.getService().getUidForIntentSender(mTarget);
        return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}
------------------------
Find a silently evolved API code:android.text.format.Formatter.formatBytes:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final boolean isNegative = (sizeBytes < 0);
    float result = isNegative ? -sizeBytes : sizeBytes;
    int suffix = com.android.internal.R.string.byteShort;
    long mult = 1;
    if (result > 900) {
        suffix = com.android.internal.R.string.kilobyteShort;
        mult = TrafficStats.KB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.megabyteShort;
        mult = TrafficStats.MB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.gigabyteShort;
        mult = TrafficStats.GB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.terabyteShort;
        mult = TrafficStats.TB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.petabyteShort;
        mult = TrafficStats.PB_IN_BYTES;
        result = result / 1024;
    }
    // Note we calculate the rounded long by ourselves, but still let String.format()
    // compute the rounded value. String.format("%f", 0.1) might not return "0.1" due to
    // floating point errors.
    final int roundFactor;
    final String roundFormat;
    if (mult == 1 || result >= 100) {
        roundFactor = 1;
        roundFormat = "%.0f";
    } else if (result < 1) {
        roundFactor = 100;
        roundFormat = "%.2f";
    } else if (result < 10) {
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 10;
            roundFormat = "%.1f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    } else {
        // 10 <= result < 100
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 1;
            roundFormat = "%.0f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    }
    if (isNegative) {
        result = -result;
    }
    final String roundedString = String.format(roundFormat, result);
    // Note this might overflow if abs(result) >= Long.MAX_VALUE / 100, but that's like 80PB so
    // it's okay (for now)...
    final long roundedBytes = (flags & FLAG_CALCULATE_ROUNDED) == 0 ? 0 : (((long) Math.round(result * roundFactor)) * mult / roundFactor);
    final String units = res.getString(suffix);
    return new BytesResult(roundedString, units, roundedBytes);
}
Body of Second Method:
{
    final boolean isNegative = (sizeBytes < 0);
    float result = isNegative ? -sizeBytes : sizeBytes;
    int suffix = com.android.internal.R.string.byteShort;
    long mult = 1;
    if (result > 900) {
        suffix = com.android.internal.R.string.kilobyteShort;
        mult = 1000;
        result = result / 1000;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.megabyteShort;
        mult *= 1000;
        result = result / 1000;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.gigabyteShort;
        mult *= 1000;
        result = result / 1000;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.terabyteShort;
        mult *= 1000;
        result = result / 1000;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.petabyteShort;
        mult *= 1000;
        result = result / 1000;
    }
    // Note we calculate the rounded long by ourselves, but still let String.format()
    // compute the rounded value. String.format("%f", 0.1) might not return "0.1" due to
    // floating point errors.
    final int roundFactor;
    final String roundFormat;
    if (mult == 1 || result >= 100) {
        roundFactor = 1;
        roundFormat = "%.0f";
    } else if (result < 1) {
        roundFactor = 100;
        roundFormat = "%.2f";
    } else if (result < 10) {
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 10;
            roundFormat = "%.1f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    } else {
        // 10 <= result < 100
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 1;
            roundFormat = "%.0f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    }
    if (isNegative) {
        result = -result;
    }
    final String roundedString = String.format(roundFormat, result);
    // Note this might overflow if abs(result) >= Long.MAX_VALUE / 100, but that's like 80PB so
    // it's okay (for now)...
    final long roundedBytes = (flags & FLAG_CALCULATE_ROUNDED) == 0 ? 0 : (((long) Math.round(result * roundFactor)) * mult / roundFactor);
    final String units = res.getString(suffix);
    return new BytesResult(roundedString, units, roundedBytes);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.createFromStream:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Create an Icon from the specified stream.
 *
 * @param stream The input stream from which to reconstruct the Icon.
 * @hide
 */

Body of Frist Method:
{
    DataInputStream inputStream = new DataInputStream(stream);
    final int version = inputStream.readInt();
    if (version >= VERSION_STREAM_SERIALIZER) {
        final int type = inputStream.readByte();
        switch(type) {
            case TYPE_BITMAP:
                return createWithBitmap(BitmapFactory.decodeStream(inputStream));
            case TYPE_DATA:
                final int length = inputStream.readInt();
                final byte[] data = new byte[length];
                inputStream.read(data, 0, /* offset */
                length);
                return createWithData(data, 0, /* offset */
                length);
            case TYPE_RESOURCE:
                final String packageName = inputStream.readUTF();
                final int resId = inputStream.readInt();
                return createWithResource(packageName, resId);
            case TYPE_URI:
                final String uriOrPath = inputStream.readUTF();
                return createWithContentUri(uriOrPath);
        }
    }
    return null;
}
Body of Second Method:
{
    DataInputStream inputStream = new DataInputStream(stream);
    final int version = inputStream.readInt();
    if (version >= VERSION_STREAM_SERIALIZER) {
        final int type = inputStream.readByte();
        switch(type) {
            case TYPE_BITMAP:
                return createWithBitmap(BitmapFactory.decodeStream(inputStream));
            case TYPE_ADAPTIVE_BITMAP:
                return createWithAdaptiveBitmap(BitmapFactory.decodeStream(inputStream));
            case TYPE_DATA:
                final int length = inputStream.readInt();
                final byte[] data = new byte[length];
                inputStream.read(data, 0, /* offset */
                length);
                return createWithData(data, 0, /* offset */
                length);
            case TYPE_RESOURCE:
                final String packageName = inputStream.readUTF();
                final int resId = inputStream.readInt();
                return createWithResource(packageName, resId);
            case TYPE_URI:
                final String uriOrPath = inputStream.readUTF();
                return createWithContentUri(uriOrPath);
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:javax.obex.ServerSession.run:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Processes requests made to the server and forwards them to the
 * appropriate event listener.
 */

Body of Frist Method:
{
    try {
        boolean done = false;
        while (!done && !mClosed) {
            if (V)
                Log.v(TAG, "Waiting for incoming request...");
            int requestType = mInput.read();
            if (V)
                Log.v(TAG, "Read request: " + requestType);
            switch(requestType) {
                case ObexHelper.OBEX_OPCODE_CONNECT:
                    handleConnectRequest();
                    break;
                case ObexHelper.OBEX_OPCODE_DISCONNECT:
                    handleDisconnectRequest();
                    done = true;
                    break;
                case ObexHelper.OBEX_OPCODE_GET:
                case ObexHelper.OBEX_OPCODE_GET_FINAL:
                    handleGetRequest(requestType);
                    break;
                case ObexHelper.OBEX_OPCODE_PUT:
                case ObexHelper.OBEX_OPCODE_PUT_FINAL:
                    handlePutRequest(requestType);
                    break;
                case ObexHelper.OBEX_OPCODE_SETPATH:
                    handleSetPathRequest();
                    break;
                case ObexHelper.OBEX_OPCODE_ABORT:
                    handleAbortRequest();
                    break;
                case -1:
                    done = true;
                    break;
                default:
                    /*
                         * Received a request type that is not recognized so I am
                         * just going to read the packet and send a not implemented
                         * to the client
                         */
                    int length = mInput.read();
                    length = (length << 8) + mInput.read();
                    for (int i = 3; i < length; i++) {
                        mInput.read();
                    }
                    sendResponse(ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED, null);
            }
        }
    } catch (NullPointerException e) {
        Log.d(TAG, "Exception occured - ignoring", e);
    } catch (Exception e) {
        Log.d(TAG, "Exception occured - ignoring", e);
    }
    close();
}
Body of Second Method:
{
    try {
        boolean done = false;
        while (!done && !mClosed) {
            if (V)
                Log.v(TAG, "Waiting for incoming request...");
            int requestType = mInput.read();
            if (V)
                Log.v(TAG, "Read request: " + requestType);
            switch(requestType) {
                case ObexHelper.OBEX_OPCODE_CONNECT:
                    handleConnectRequest();
                    break;
                case ObexHelper.OBEX_OPCODE_DISCONNECT:
                    handleDisconnectRequest();
                    break;
                case ObexHelper.OBEX_OPCODE_GET:
                case ObexHelper.OBEX_OPCODE_GET_FINAL:
                    handleGetRequest(requestType);
                    break;
                case ObexHelper.OBEX_OPCODE_PUT:
                case ObexHelper.OBEX_OPCODE_PUT_FINAL:
                    handlePutRequest(requestType);
                    break;
                case ObexHelper.OBEX_OPCODE_SETPATH:
                    handleSetPathRequest();
                    break;
                case ObexHelper.OBEX_OPCODE_ABORT:
                    handleAbortRequest();
                    break;
                case -1:
                    done = true;
                    break;
                default:
                    /*
                         * Received a request type that is not recognized so I am
                         * just going to read the packet and send a not implemented
                         * to the client
                         */
                    int length = mInput.read();
                    length = (length << 8) + mInput.read();
                    for (int i = 3; i < length; i++) {
                        mInput.read();
                    }
                    sendResponse(ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED, null);
            }
        }
    } catch (NullPointerException e) {
        Log.d(TAG, "Exception occured - ignoring", e);
    } catch (Exception e) {
        Log.d(TAG, "Exception occured - ignoring", e);
    }
    close();
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.setDialing:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Sets a call's state to dialing (e.g., dialing an outbound call).
 *
 * @param callId The unique ID of the call whose state is changing to dialing.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setDialing(callId);
        } catch (RemoteException e) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setDialing(callId, Log.getExternalSession());
        } catch (RemoteException e) {
        }
    }
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.setCurrentFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the position of the animation to the specified fraction. This fraction should
 * be between 0 and the total fraction of the animation, including any repetition. That is,
 * a fraction of 0 will position the animation at the beginning, a value of 1 at the end,
 * and a value of 2 at the end of a reversing animator that repeats once. If
 * the animation has not yet been started, then it will not advance forward after it is
 * set to this fraction; it will simply set the fraction to this value and perform any
 * appropriate actions based on that fraction. If the animation is already running, then
 * setCurrentFraction() will set the current fraction to this value and continue
 * playing from that point. {@link Animator.AnimatorListener} events are not called
 * due to changing the fraction; those events are only processed while the animation
 * is running.
 *
 * @param fraction The fraction to which the animation is advanced or rewound. Values
 * outside the range of 0 to the maximum fraction for the animator will be clamped to
 * the correct range.
 */

Body of Frist Method:
{
    initAnimation();
    fraction = clampFraction(fraction);
    long seekTime = (long) (getScaledDuration() * fraction);
    long currentTime = AnimationUtils.currentAnimationTimeMillis();
    mStartTime = currentTime - seekTime;
    // do not allow start time to be compensated for jank
    mStartTimeCommitted = true;
    if (!isPulsingInternal()) {
        // If the animation loop hasn't started, the startTime will be adjusted in the first
        // frame based on seek fraction.
        mSeekFraction = fraction;
    }
    mOverallFraction = fraction;
    final float currentIterationFraction = getCurrentIterationFraction(fraction);
    animateValue(currentIterationFraction);
}
Body of Second Method:
{
    initAnimation();
    fraction = clampFraction(fraction);
    // do not allow start time to be compensated for jank
    mStartTimeCommitted = true;
    if (isPulsingInternal()) {
        long seekTime = (long) (getScaledDuration() * fraction);
        long currentTime = AnimationUtils.currentAnimationTimeMillis();
        // Only modify the start time when the animation is running. Seek fraction will ensure
        // non-running animations skip to the correct start time.
        mStartTime = currentTime - seekTime;
    } else {
        // If the animation loop hasn't started, or during start delay, the startTime will be
        // adjusted once the delay has passed based on seek fraction.
        mSeekFraction = fraction;
    }
    mOverallFraction = fraction;
    final float currentIterationFraction = getCurrentIterationFraction(fraction, mReversing);
    animateValue(currentIterationFraction);
}
------------------------
Find a silently evolved API code:android.nfc.NdefRecord.writeToByteBuffer:COMMENT
Method Modifier: default     
Comment:/**
 * Serialize record for network transmission.<p>
 * Uses specified MB and ME flags.<p>
 * Does not chunk records.
 */

Body of Frist Method:
{
    boolean sr = mPayload.length < 256;
    boolean il = mId.length > 0;
    byte flags = (byte) ((mb ? FLAG_MB : 0) | (me ? FLAG_ME : 0) | (sr ? FLAG_SR : 0) | (il ? FLAG_IL : 0) | mTnf);
    buffer.put(flags);
    buffer.put((byte) mType.length);
    if (sr) {
        buffer.put((byte) mPayload.length);
    } else {
        buffer.putInt(mPayload.length);
    }
    if (il) {
        buffer.put((byte) mId.length);
    }
    buffer.put(mType);
    buffer.put(mId);
    buffer.put(mPayload);
}
Body of Second Method:
{
    boolean sr = mPayload.length < 256;
    boolean il = mTnf == TNF_EMPTY ? true : mId.length > 0;
    byte flags = (byte) ((mb ? FLAG_MB : 0) | (me ? FLAG_ME : 0) | (sr ? FLAG_SR : 0) | (il ? FLAG_IL : 0) | mTnf);
    buffer.put(flags);
    buffer.put((byte) mType.length);
    if (sr) {
        buffer.put((byte) mPayload.length);
    } else {
        buffer.putInt(mPayload.length);
    }
    if (il) {
        buffer.put((byte) mId.length);
    }
    buffer.put(mType);
    buffer.put(mId);
    buffer.put(mPayload);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.loadSoundEffects:COMMENT
Method Modifier: public      
Comment:/**
 * Load Sound effects.
 * This method must be called when sound effects are enabled.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.loadSoundEffects();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.loadSoundEffects();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.HotlistSettings.writeToParcel:COMMENT
<android.net.wifi.WifiScanner.HotlistSettings: void writeToParcel(Parcel,int)>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(apLostThreshold);
    if (bssidInfos != null) {
        dest.writeInt(bssidInfos.length);
        for (int i = 0; i < bssidInfos.length; i++) {
            BssidInfo info = bssidInfos[i];
            dest.writeString(info.bssid);
            dest.writeInt(info.low);
            dest.writeInt(info.high);
            dest.writeInt(info.frequencyHint);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.removeCall:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Indicates that the call no longer exists. Can be used with either a call or a conference
 * call.
 *
 * @param callId The unique ID of the call.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.removeCall(callId);
        } catch (RemoteException ignored) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.removeCall(callId, Log.getExternalSession());
        } catch (RemoteException ignored) {
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.startBluetoothScoVirtualCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Start bluetooth SCO audio connection in virtual call mode.
 * <p>Requires Permission:
 * {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
 * <p>Similar to {@link #startBluetoothSco()} with explicit selection of virtual call mode.
 * Telephony and communication applications (VoIP, Video Chat) should preferably select
 * virtual call mode.
 * Applications using voice input for search or commands should first try raw audio connection
 * with {@link #startBluetoothSco()} and fall back to startBluetoothScoVirtualCall() in case of
 * failure.
 * @see #startBluetoothSco()
 * @see #stopBluetoothSco()
 * @see #ACTION_SCO_AUDIO_STATE_UPDATED
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.startBluetoothScoVirtualCall(mICallBack);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.startBluetoothScoVirtualCall(mICallBack);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.getOutline:COMMENT
Method Modifier: public      
Comment:/**
 * Populates <code>outline</code> with the first available (non-empty) layer outline.
 *
 * @param outline Outline in which to place the first available layer outline
 */

Body of Frist Method:
{
    final ChildDrawable[] array = mLayerState.mChildren;
    final int N = mLayerState.mNum;
    for (int i = 0; i < N; i++) {
        final Drawable dr = array[i].mDrawable;
        if (dr != null) {
            dr.getOutline(outline);
            if (!outline.isEmpty()) {
                return;
            }
        }
    }
}
Body of Second Method:
{
    final ChildDrawable[] array = mLayerState.mChildren;
    final int N = mLayerState.mNumChildren;
    for (int i = 0; i < N; i++) {
        final Drawable dr = array[i].mDrawable;
        if (dr != null) {
            dr.getOutline(outline);
            if (!outline.isEmpty()) {
                return;
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.view.TextureView.destroyHardwareResources:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    destroyHardwareLayer();
}
Body of Second Method:
{
    super.destroyHardwareResources();
    destroyHardwareLayer();
}
------------------------
Find a silently evolved API code:android.content.BroadcastReceiver.PendingResult.finish:COMMENT
Method Modifier: public      final       
Comment:/**
 * Finish the broadcast.  The current result will be sent and the
 * next broadcast will proceed.
 */

Body of Frist Method:
{
    if (mType == TYPE_COMPONENT) {
        final IActivityManager mgr = ActivityManagerNative.getDefault();
        if (QueuedWork.hasPendingWork()) {
            // If this is a broadcast component, we need to make sure any
            // queued work is complete before telling AM we are done, so
            // we don't have our process killed before that.  We now know
            // there is pending work; put another piece of work at the end
            // of the list to finish the broadcast, so we don't block this
            // thread (which may be the main thread) to have it finished.
            // 
            // Note that we don't need to use QueuedWork.add() with the
            // runnable, since we know the AM is waiting for us until the
            // executor gets to it.
            QueuedWork.singleThreadExecutor().execute(new Runnable() {

                @Override
                public void run() {
                    if (ActivityThread.DEBUG_BROADCAST)
                        Slog.i(ActivityThread.TAG, "Finishing broadcast after work to component " + mToken);
                    sendFinished(mgr);
                }
            });
        } else {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, "Finishing broadcast to component " + mToken);
            sendFinished(mgr);
        }
    } else if (mOrderedHint && mType != TYPE_UNREGISTERED) {
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, "Finishing broadcast to " + mToken);
        final IActivityManager mgr = ActivityManagerNative.getDefault();
        sendFinished(mgr);
    }
}
Body of Second Method:
{
    if (mType == TYPE_COMPONENT) {
        final IActivityManager mgr = ActivityManager.getService();
        if (QueuedWork.hasPendingWork()) {
            // If this is a broadcast component, we need to make sure any
            // queued work is complete before telling AM we are done, so
            // we don't have our process killed before that.  We now know
            // there is pending work; put another piece of work at the end
            // of the list to finish the broadcast, so we don't block this
            // thread (which may be the main thread) to have it finished.
            // 
            // Note that we don't need to use QueuedWork.addFinisher() with the
            // runnable, since we know the AM is waiting for us until the
            // executor gets to it.
            QueuedWork.queue(new Runnable() {

                @Override
                public void run() {
                    if (ActivityThread.DEBUG_BROADCAST)
                        Slog.i(ActivityThread.TAG, "Finishing broadcast after work to component " + mToken);
                    sendFinished(mgr);
                }
            }, false);
        } else {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, "Finishing broadcast to component " + mToken);
            sendFinished(mgr);
        }
    } else if (mOrderedHint && mType != TYPE_UNREGISTERED) {
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, "Finishing broadcast to " + mToken);
        final IActivityManager mgr = ActivityManager.getService();
        sendFinished(mgr);
    }
}
------------------------
Find a silently evolved API code:android.view.ViewTreeObserver.dispatchOnDraw:COMMENT
Method Modifier: public      final       
Comment:/**
 * Notifies registered listeners that the drawing pass is about to start.
 */

Body of Frist Method:
{
    if (mOnDrawListeners != null) {
        final ArrayList<OnDrawListener> listeners = mOnDrawListeners;
        int numListeners = listeners.size();
        for (int i = 0; i < numListeners; ++i) {
            listeners.get(i).onDraw();
        }
    }
}
Body of Second Method:
{
    if (mOnDrawListeners != null) {
        mInDispatchOnDraw = true;
        final ArrayList<OnDrawListener> listeners = mOnDrawListeners;
        int numListeners = listeners.size();
        for (int i = 0; i < numListeners; ++i) {
            listeners.get(i).onDraw();
        }
        mInDispatchOnDraw = false;
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setSimState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set TelephonyProperties.PROPERTY_SIM_STATE for the default phone.
 *
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    setSimStateForPhone(phoneId, state);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    setSimStateForPhone(phoneId, state);
}
------------------------
Find a silently evolved API code:android.os.StatFs.getFreeBytes:COMMENT
Method Modifier: public      
Comment:/**
 * The number of bytes that are free on the file system, including reserved
 * blocks (that are not available to normal applications). Most applications
 * will want to use {@link #getAvailableBytes()} instead.
 */

Body of Frist Method:
{
    return mStat.f_bfree * mStat.f_bsize;
}
Body of Second Method:
{
    return mStat.f_bfree * mStat.f_frsize;
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.initProgressBar:COMMENT
Method Modifier: private     
Comment:/**
 * <p>
 * Initialize the progress bar's default values:
 * </p>
 * <ul>
 * <li>progress = 0</li>
 * <li>max = 100</li>
 * <li>animation duration = 4000 ms</li>
 * <li>indeterminate = false</li>
 * <li>behavior = repeat</li>
 * </ul>
 */

Body of Frist Method:
{
    mMax = 100;
    mProgress = 0;
    mSecondaryProgress = 0;
    mIndeterminate = false;
    mOnlyIndeterminate = false;
    mDuration = 4000;
    mBehavior = AlphaAnimation.RESTART;
    mMinWidth = 24;
    mMaxWidth = 48;
    mMinHeight = 24;
    mMaxHeight = 48;
}
Body of Second Method:
{
    mMin = 0;
    mMax = 100;
    mProgress = 0;
    mSecondaryProgress = 0;
    mIndeterminate = false;
    mOnlyIndeterminate = false;
    mDuration = 4000;
    mBehavior = AlphaAnimation.RESTART;
    mMinWidth = 24;
    mMaxWidth = 48;
    mMinHeight = 24;
    mMaxHeight = 48;
}
------------------------
Find a silently evolved API code:android.view.ViewTreeObserver.merge:COMMENT
Method Modifier: default     
Comment:/**
 * Merges all the listeners registered on the specified observer with the listeners
 * registered on this object. After this method is invoked, the specified observer
 * will return false in {@link #isAlive()} and should not be used anymore.
 *
 * @param observer The ViewTreeObserver whose listeners must be added to this observer
 */

Body of Frist Method:
{
    if (observer.mOnWindowAttachListeners != null) {
        if (mOnWindowAttachListeners != null) {
            mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);
        } else {
            mOnWindowAttachListeners = observer.mOnWindowAttachListeners;
        }
    }
    if (observer.mOnWindowFocusListeners != null) {
        if (mOnWindowFocusListeners != null) {
            mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners);
        } else {
            mOnWindowFocusListeners = observer.mOnWindowFocusListeners;
        }
    }
    if (observer.mOnGlobalFocusListeners != null) {
        if (mOnGlobalFocusListeners != null) {
            mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners);
        } else {
            mOnGlobalFocusListeners = observer.mOnGlobalFocusListeners;
        }
    }
    if (observer.mOnGlobalLayoutListeners != null) {
        if (mOnGlobalLayoutListeners != null) {
            mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);
        } else {
            mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;
        }
    }
    if (observer.mOnPreDrawListeners != null) {
        if (mOnPreDrawListeners != null) {
            mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);
        } else {
            mOnPreDrawListeners = observer.mOnPreDrawListeners;
        }
    }
    if (observer.mOnTouchModeChangeListeners != null) {
        if (mOnTouchModeChangeListeners != null) {
            mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners);
        } else {
            mOnTouchModeChangeListeners = observer.mOnTouchModeChangeListeners;
        }
    }
    if (observer.mOnComputeInternalInsetsListeners != null) {
        if (mOnComputeInternalInsetsListeners != null) {
            mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners);
        } else {
            mOnComputeInternalInsetsListeners = observer.mOnComputeInternalInsetsListeners;
        }
    }
    if (observer.mOnScrollChangedListeners != null) {
        if (mOnScrollChangedListeners != null) {
            mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);
        } else {
            mOnScrollChangedListeners = observer.mOnScrollChangedListeners;
        }
    }
    if (observer.mOnWindowShownListeners != null) {
        if (mOnWindowShownListeners != null) {
            mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners);
        } else {
            mOnWindowShownListeners = observer.mOnWindowShownListeners;
        }
    }
    observer.kill();
}
Body of Second Method:
{
    if (observer.mOnWindowAttachListeners != null) {
        if (mOnWindowAttachListeners != null) {
            mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);
        } else {
            mOnWindowAttachListeners = observer.mOnWindowAttachListeners;
        }
    }
    if (observer.mOnWindowFocusListeners != null) {
        if (mOnWindowFocusListeners != null) {
            mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners);
        } else {
            mOnWindowFocusListeners = observer.mOnWindowFocusListeners;
        }
    }
    if (observer.mOnGlobalFocusListeners != null) {
        if (mOnGlobalFocusListeners != null) {
            mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners);
        } else {
            mOnGlobalFocusListeners = observer.mOnGlobalFocusListeners;
        }
    }
    if (observer.mOnGlobalLayoutListeners != null) {
        if (mOnGlobalLayoutListeners != null) {
            mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);
        } else {
            mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;
        }
    }
    if (observer.mOnPreDrawListeners != null) {
        if (mOnPreDrawListeners != null) {
            mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);
        } else {
            mOnPreDrawListeners = observer.mOnPreDrawListeners;
        }
    }
    if (observer.mOnDrawListeners != null) {
        if (mOnDrawListeners != null) {
            mOnDrawListeners.addAll(observer.mOnDrawListeners);
        } else {
            mOnDrawListeners = observer.mOnDrawListeners;
        }
    }
    if (observer.mOnTouchModeChangeListeners != null) {
        if (mOnTouchModeChangeListeners != null) {
            mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners);
        } else {
            mOnTouchModeChangeListeners = observer.mOnTouchModeChangeListeners;
        }
    }
    if (observer.mOnComputeInternalInsetsListeners != null) {
        if (mOnComputeInternalInsetsListeners != null) {
            mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners);
        } else {
            mOnComputeInternalInsetsListeners = observer.mOnComputeInternalInsetsListeners;
        }
    }
    if (observer.mOnScrollChangedListeners != null) {
        if (mOnScrollChangedListeners != null) {
            mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);
        } else {
            mOnScrollChangedListeners = observer.mOnScrollChangedListeners;
        }
    }
    if (observer.mOnWindowShownListeners != null) {
        if (mOnWindowShownListeners != null) {
            mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners);
        } else {
            mOnWindowShownListeners = observer.mOnWindowShownListeners;
        }
    }
    observer.kill();
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isValidRingerMode:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks valid ringer mode values.
 *
 * @return true if the ringer mode indicated is valid, false otherwise.
 *
 * @see #setRingerMode(int)
 * @hide
 */

Body of Frist Method:
{
    if (ringerMode < 0 || ringerMode > RINGER_MODE_MAX) {
        return false;
    }
    IAudioService service = getService();
    try {
        return service.isValidRingerMode(ringerMode);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (ringerMode < 0 || ringerMode > RINGER_MODE_MAX) {
        return false;
    }
    final IAudioService service = getService();
    try {
        return service.isValidRingerMode(ringerMode);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.RatingBar.setIsIndicator:COMMENT
Method Modifier: public      
Comment:/**
 * Whether this rating bar should only be an indicator (thus non-changeable
 * by the user).
 *
 * @param isIndicator Whether it should be an indicator.
 *
 * @attr ref android.R.styleable#RatingBar_isIndicator
 */

Body of Frist Method:
{
    mIsUserSeekable = !isIndicator;
    setFocusable(!isIndicator);
}
Body of Second Method:
{
    mIsUserSeekable = !isIndicator;
    if (isIndicator) {
        setFocusable(FOCUSABLE_AUTO);
    } else {
        setFocusable(FOCUSABLE);
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.WifiChangeSettings.writeToParcel:COMMENT
<android.net.wifi.WifiScanner.WifiChangeSettings: void writeToParcel(Parcel,int)>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(rssiSampleSize);
    dest.writeInt(lostApSampleSize);
    dest.writeInt(unchangedSampleSize);
    dest.writeInt(minApsBreachingThreshold);
    dest.writeInt(periodInMs);
    if (bssidInfos != null) {
        dest.writeInt(bssidInfos.length);
        for (int i = 0; i < bssidInfos.length; i++) {
            BssidInfo info = bssidInfos[i];
            dest.writeString(info.bssid);
            dest.writeInt(info.low);
            dest.writeInt(info.high);
            dest.writeInt(info.frequencyHint);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.setPulling:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Sets a call's state to pulling (e.g. a call with {@link Connection#PROPERTY_IS_EXTERNAL_CALL}
 * is being pulled to the local device.
 *
 * @param callId The unique ID of the call whose state is changing to dialing.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setPulling(callId);
        } catch (RemoteException e) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setPulling(callId, Log.getExternalSession());
        } catch (RemoteException e) {
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.getLteLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get LTE as level 0..4
 *
 * @hide
 */

Body of Frist Method:
{
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    int rsrpThreshType = Resources.getSystem().getInteger(com.android.internal.R.integer.config_LTE_RSRP_threshold_type);
    int[] threshRsrp;
    if (rsrpThreshType == RSRP_THRESH_TYPE_STRICT) {
        threshRsrp = RSRP_THRESH_STRICT;
    } else {
        threshRsrp = RSRP_THRESH_LENIENT;
    }
    if (mLteRsrp > threshRsrp[5])
        rsrpIconLevel = -1;
    else if (mLteRsrp >= threshRsrp[4])
        rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRsrp >= threshRsrp[3])
        rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRsrp >= threshRsrp[2])
        rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRsrp >= threshRsrp[1])
        rsrpIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRsrp >= threshRsrp[0])
        rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
Body of Second Method:
{
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    int[] threshRsrp = Resources.getSystem().getIntArray(com.android.internal.R.array.config_lteDbmThresholds);
    if (threshRsrp.length != 6) {
        Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements." + " Cannot evaluate RSRP signal.");
    } else {
        if (mLteRsrp > threshRsrp[5]) {
            rsrpIconLevel = -1;
        } else if (mLteRsrp >= (threshRsrp[4] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
        } else if (mLteRsrp >= (threshRsrp[3] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
        } else if (mLteRsrp >= (threshRsrp[2] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
        } else if (mLteRsrp >= (threshRsrp[1] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_POOR;
        } else if (mLteRsrp >= threshRsrp[0]) {
            rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
        }
    }
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel + " lteRsrpBoost:" + mLteRsrpBoost);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.Key.getTag:COMMENT
Method Modifier: public      final       
Comment:/**
 * <p>
 * Get the tag corresponding to this key. This enables insertion into the
 * native metadata.
 * </p>
 *
 * <p>This value is looked up the first time, and cached subsequently.</p>
 *
 * @return The tag numeric value corresponding to the string
 */

Body of Frist Method:
{
    if (!mHasTag) {
        mTag = CameraMetadataNative.getTag(mName);
        mHasTag = true;
    }
    return mTag;
}
Body of Second Method:
{
    if (!mHasTag) {
        mTag = CameraMetadataNative.getTag(mName, mVendorId);
        mHasTag = true;
    }
    return mTag;
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.migrateTun:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * VPN accounting. Move some VPN's underlying traffic to other UIDs that use tun0 iface.
 *
 * This method should only be called on delta NetworkStats. Do not call this method on a
 * snapshot {@link NetworkStats} object because the tunUid and/or the underlyingIface may
 * change over time.
 *
 * This method performs adjustments for one active VPN package and one VPN iface at a time.
 *
 * It is possible for the VPN software to use multiple underlying networks. This method
 * only migrates traffic for the primary underlying network.
 *
 * @param tunUid uid of the VPN application
 * @param tunIface iface of the vpn tunnel
 * @param underlyingIface the primary underlying network iface used by the VPN application
 * @return true if it successfully adjusts the accounting for VPN, false otherwise
 */

Body of Frist Method:
{
    Entry tunIfaceTotal = new Entry();
    Entry underlyingIfaceTotal = new Entry();
    tunAdjustmentInit(tunUid, tunIface, underlyingIface, tunIfaceTotal, underlyingIfaceTotal);
    // If tunIface < underlyingIface, it leaves the overhead traffic in the VPN app.
    // If tunIface > underlyingIface, the VPN app doesn't get credit for data compression.
    // Negative stats should be avoided.
    Entry pool = tunGetPool(tunIfaceTotal, underlyingIfaceTotal);
    if (pool.isEmpty()) {
        return true;
    }
    Entry moved = addTrafficToApplications(tunIface, underlyingIface, tunIfaceTotal, pool);
    deductTrafficFromVpnApp(tunUid, underlyingIface, moved);
    if (!moved.isEmpty()) {
        Slog.wtf(TAG, "Failed to deduct underlying network traffic from VPN package. Moved=" + moved);
        return false;
    }
    return true;
}
Body of Second Method:
{
    Entry tunIfaceTotal = new Entry();
    Entry underlyingIfaceTotal = new Entry();
    tunAdjustmentInit(tunUid, tunIface, underlyingIface, tunIfaceTotal, underlyingIfaceTotal);
    // If tunIface < underlyingIface, it leaves the overhead traffic in the VPN app.
    // If tunIface > underlyingIface, the VPN app doesn't get credit for data compression.
    // Negative stats should be avoided.
    Entry pool = tunGetPool(tunIfaceTotal, underlyingIfaceTotal);
    if (pool.isEmpty()) {
        return true;
    }
    Entry moved = addTrafficToApplications(tunUid, tunIface, underlyingIface, tunIfaceTotal, pool);
    deductTrafficFromVpnApp(tunUid, underlyingIface, moved);
    if (!moved.isEmpty()) {
        Slog.wtf(TAG, "Failed to deduct underlying network traffic from VPN package. Moved=" + moved);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.graphics.Path.isConvex:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the path's convexity, as defined by the content of the path.
 * <p>
 * A path is convex if it has a single contour, and only ever curves in a
 * single direction.
 * <p>
 * This function will calculate the convexity of the path from its control
 * points, and cache the result.
 *
 * @return True if the path is convex.
 */

Body of Frist Method:
{
    return native_isConvex(mNativePath);
}
Body of Second Method:
{
    return nIsConvex(mNativePath);
}
------------------------
Find a silently evolved API code:android.webkit.CookieSyncManager.getInstance:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Singleton access to a {@link CookieSyncManager}. An
 * IllegalStateException will be thrown if
 * {@link CookieSyncManager#createInstance(Context)} is not called before.
 *
 * @return CookieSyncManager
 */

Body of Frist Method:
{
    checkInstanceIsAllowed();
    if (sRef == null) {
        sRef = new CookieSyncManager();
    }
    return sRef;
}
Body of Second Method:
{
    synchronized (sLock) {
        checkInstanceIsAllowed();
        if (sRef == null) {
            sRef = new CookieSyncManager();
        }
        return sRef;
    }
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.show:COMMENT
Method Modifier: public      
Comment:/**
 * Show the popup list. If the list is already showing, this method
 * will recalculate the popup's size and position.
 */

Body of Frist Method:
{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}
Body of Second Method:
{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        if (!getAnchorView().isAttachedToWindow()) {
            // Don't update position if the anchor view is detached from window.
            return;
        }
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        if (mOverlapAnchorSet) {
            mPopup.setOverlapAnchor(mOverlapAnchor);
        }
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setNetworkRoaming:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set roaming state of the current network, for GSM purposes.
 * @param isRoaming is network in romaing state or not
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    setNetworkRoamingForPhone(phoneId, isRoaming);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    setNetworkRoamingForPhone(phoneId, isRoaming);
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getSubId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!isValidSlotId(slotId)) {
        logd("[getSubId]- fail");
        return null;
    }
    int[] subId = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getSubId(slotId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return subId;
}
Body of Second Method:
{
    if (!isValidSlotIndex(slotIndex)) {
        logd("[getSubId]- fail");
        return null;
    }
    int[] subId = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getSubId(slotIndex);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return subId;
}
------------------------
Find a silently evolved API code:android.graphics.ComposeShader.copy:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final ComposeShader copy;
    switch(mType) {
        case TYPE_XFERMODE:
            copy = new ComposeShader(mShaderA.copy(), mShaderB.copy(), mXferMode);
            break;
        case TYPE_PORTERDUFFMODE:
            copy = new ComposeShader(mShaderA.copy(), mShaderB.copy(), mPorterDuffMode);
            break;
        default:
            throw new IllegalArgumentException("ComposeShader should be created with either Xfermode or PorterDuffMode");
    }
    copyLocalMatrix(copy);
    return copy;
}
Body of Second Method:
{
    final ComposeShader copy = new ComposeShader(mShaderA.copy(), mShaderB.copy(), mPorterDuffMode);
    copyLocalMatrix(copy);
    return copy;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.grantPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Grants permission for USB device without showing system dialog.
 * Only system components can call this function.
 * @param device to request permissions for
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        mService.grantDevicePermission(device, Process.myUid());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    grantPermission(device, Process.myUid());
}
------------------------
Find a silently evolved API code:android.database.DatabaseUtils.cursorRowToContentValues:COMMENT
Method Modifier: public      static      
Comment:/**
 * Read the entire contents of a cursor row and store them in a ContentValues.
 *
 * @param cursor the cursor to read from.
 * @param values the {@link ContentValues} to put the row into.
 */

Body of Frist Method:
{
    AbstractWindowedCursor awc = (cursor instanceof AbstractWindowedCursor) ? (AbstractWindowedCursor) cursor : null;
    String[] columns = cursor.getColumnNames();
    int length = columns.length;
    for (int i = 0; i < length; i++) {
        if (awc != null && awc.isBlob(i)) {
            values.put(columns[i], cursor.getBlob(i));
        } else {
            values.put(columns[i], cursor.getString(i));
        }
    }
}
Body of Second Method:
{
    String[] columns = cursor.getColumnNames();
    int length = columns.length;
    for (int i = 0; i < length; i++) {
        if (cursor.getType(i) == Cursor.FIELD_TYPE_BLOB) {
            values.put(columns[i], cursor.getBlob(i));
        } else {
            values.put(columns[i], cursor.getString(i));
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.compress:COMMENT
Method Modifier: public      
Comment:/**
 * Write a compressed version of the bitmap to the specified outputstream.
 * If this returns true, the bitmap can be reconstructed by passing a
 * corresponding inputstream to BitmapFactory.decodeStream(). Note: not
 * all Formats support all bitmap configs directly, so it is possible that
 * the returned bitmap from BitmapFactory could be in a different bitdepth,
 * and/or may have lost per-pixel alpha (e.g. JPEG only supports opaque
 * pixels).
 *
 * @param format   The format of the compressed image
 * @param quality  Hint to the compressor, 0-100. 0 meaning compress for
 * small size, 100 meaning compress for max quality. Some
 * formats, like PNG which is lossless, will ignore the
 * quality setting
 * @param stream   The outputstream to write the compressed data.
 * @return true if successfully compressed to the specified stream.
 */

Body of Frist Method:
{
    checkRecycled("Can't compress a recycled bitmap");
    // do explicit check before calling the native method
    if (stream == null) {
        throw new NullPointerException();
    }
    if (quality < 0 || quality > 100) {
        throw new IllegalArgumentException("quality must be 0..100");
    }
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "Bitmap.compress");
    boolean result = nativeCompress(mNativePtr, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    return result;
}
Body of Second Method:
{
    checkRecycled("Can't compress a recycled bitmap");
    // do explicit check before calling the native method
    if (stream == null) {
        throw new NullPointerException();
    }
    if (quality < 0 || quality > 100) {
        throw new IllegalArgumentException("quality must be 0..100");
    }
    StrictMode.noteSlowCall("Compression of a bitmap is slow");
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "Bitmap.compress");
    boolean result = nativeCompress(mNativePtr, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    return result;
}
------------------------
Find a silently evolved API code:android.os.StatFs.getTotalBytes:COMMENT
Method Modifier: public      
Comment:/**
 * The total number of bytes supported by the file system.
 */

Body of Frist Method:
{
    return mStat.f_blocks * mStat.f_bsize;
}
Body of Second Method:
{
    return mStat.f_blocks * mStat.f_frsize;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.restoreToCount:COMMENT
Method Modifier: public      
Comment:/**
 * Efficient way to pop any calls to save() that happened after the save
 * count reached saveCount. It is an error for saveCount to be less than 1.
 *
 * Example:
 * int count = canvas.save();
 * ... // more calls potentially to save()
 * canvas.restoreToCount(count);
 * // now the canvas is back in the same state it was before the initial
 * // call to save().
 *
 * @param saveCount The save level to restore to.
 */

Body of Frist Method:
{
    boolean throwOnUnderflow = !sCompatibilityRestore || !isHardwareAccelerated();
    native_restoreToCount(mNativeCanvasWrapper, saveCount, throwOnUnderflow);
}
Body of Second Method:
{
    if (saveCount < 1) {
        if (!sCompatibilityRestore || !isHardwareAccelerated()) {
            // do nothing and throw without restoring
            throw new IllegalArgumentException("Underflow in restoreToCount - more restores than saves");
        }
        // compat behavior - restore as far as possible
        saveCount = 1;
    }
    nRestoreToCount(mNativeCanvasWrapper, saveCount);
}
------------------------
Find a silently evolved API code:android.graphics.Shader.getNativeInstance:COMMENT
<android.graphics.Shader: long getNativeInstance()>
public      hidden      ->public      final       hidden      
Method Modifier: public      final       hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return native_instance;
}
Body of Second Method:
{
    // verify mNativeInstance is valid
    verifyNativeInstance();
    if (mNativeInstance == 0) {
        mNativeInstance = createNativeInstance(mLocalMatrix == null ? 0 : mLocalMatrix.native_instance);
        mCleaner = NoImagePreloadHolder.sRegistry.registerNativeAllocation(this, mNativeInstance);
    }
    return mNativeInstance;
}
------------------------
Find a silently evolved API code:android.net.InterfaceConfiguration.isActive:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * This function determines if the interface is up and has a valid IP
 * configuration (IP address has a non zero octet).
 *
 * Note: It is supposed to be quick and hence should not initiate
 * any network activity
 */

Body of Frist Method:
{
    try {
        if (hasFlag(FLAG_UP)) {
            for (byte b : mAddr.getAddress().getAddress()) {
                if (b != 0)
                    return true;
            }
        }
    } catch (NullPointerException e) {
        return false;
    }
    return false;
}
Body of Second Method:
{
    try {
        if (isUp()) {
            for (byte b : mAddr.getAddress().getAddress()) {
                if (b != 0)
                    return true;
            }
        }
    } catch (NullPointerException e) {
        return false;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.MediaRecorder.setOutputFile:COMMENT
Method Modifier: public      
Comment:/**
 * Pass in the file descriptor of the file to be written. Call this after
 * setOutputFormat() but before prepare().
 *
 * @param fd an open file descriptor to be written into.
 * @throws IllegalStateException if it is called before
 * setOutputFormat() or after prepare()
 */

Body of Frist Method:
{
    mPath = null;
    mFd = fd;
}
Body of Second Method:
{
    mPath = null;
    mFile = null;
    mFd = fd;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current audio mode.
 *
 * @return      the current audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
 * {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
 * Returns the current current audio state from the HAL.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.getMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.
 * {@link BluetoothProfile#GATT} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */

Body of Frist Method:
{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else {
        return false;
    }
}
Body of Second Method:
{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_HOST) {
        BluetoothInputHost iHost = new BluetoothInputHost(context, listener);
        return true;
    } else {
        return false;
    }
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbDeviceConnection.close:COMMENT
Method Modifier: public      
Comment:/**
 * Releases all system resources related to the device.
 * Once the object is closed it cannot be used again.
 * The client must call {@link UsbManager#openDevice} again
 * to retrieve a new instance to reestablish communication with the device.
 */

Body of Frist Method:
{
    native_close();
}
Body of Second Method:
{
    if (mNativeContext != 0) {
        native_close();
        mCloseGuard.close();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.avrcpSupportsAbsoluteVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Notifies AudioService that it is connected to an A2DP device that supports absolute volume,
 * so that AudioService can send volume change events to the A2DP device, rather than handling
 * them.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.avrcpSupportsAbsoluteVolume(address, support);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.avrcpSupportsAbsoluteVolume(address, support);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getPassword:COMMENT
Method Modifier: public      
Comment:/**
 * Get the password.
 *
 * Returns locally set password value. For networks fetched from
 * framework, returns "*".
 */

Body of Frist Method:
{
    return getFieldValue(PASSWORD_KEY, "");
}
Body of Second Method:
{
    return getFieldValue(PASSWORD_KEY);
}
------------------------
Find a silently evolved API code:android.view.DragAndDropPermissions.takeTransient:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Take the permissions. Must call {@link #release} explicitly.
 * @return True if permissions are successfully taken.
 * @hide
 */

Body of Frist Method:
{
    try {
        mPermissionOwnerToken = ActivityManagerNative.getDefault().newUriPermissionOwner("drop");
        mDragAndDropPermissions.takeTransient(mPermissionOwnerToken);
    } catch (RemoteException e) {
        return false;
    }
    return true;
}
Body of Second Method:
{
    try {
        mTransientToken = new Binder();
        mDragAndDropPermissions.takeTransient(mTransientToken);
    } catch (RemoteException e) {
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.setContentDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the description of the source.
 *
 * @param contentDescription The description.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */

Body of Frist Method:
{
    enforceNotSealed();
    mContentDescription = contentDescription;
}
Body of Second Method:
{
    enforceNotSealed();
    mContentDescription = (contentDescription == null) ? null : contentDescription.subSequence(0, contentDescription.length());
}
------------------------
Find a silently evolved API code:android.os.StrictMode.ThreadPolicy.Builder.detectAll:COMMENT
Method Modifier: public      
Comment:/**
 * Detect everything that's potentially suspect.
 *
 * <p>As of the Gingerbread release this includes network and
 * disk operations but will likely expand in future releases.
 */

Body of Frist Method:
{
    return enable(ALL_THREAD_DETECT_BITS);
}
Body of Second Method:
{
    detectDiskReads();
    detectDiskWrites();
    detectNetwork();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectCustomSlowCalls();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        detectResourceMismatches();
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectUnbufferedIo();
    }
    return this;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.setHighContrastText:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    native_setHighContrastText(mNativeCanvasWrapper, highContrastText);
}
Body of Second Method:
{
    nSetHighContrastText(mNativeCanvasWrapper, highContrastText);
}
------------------------
Find a silently evolved API code:android.view.Display.stateToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(state) {
        case STATE_UNKNOWN:
            return "UNKNOWN";
        case STATE_OFF:
            return "OFF";
        case STATE_ON:
            return "ON";
        case STATE_DOZE:
            return "DOZE";
        case STATE_DOZE_SUSPEND:
            return "DOZE_SUSPEND";
        default:
            return Integer.toString(state);
    }
}
Body of Second Method:
{
    switch(state) {
        case STATE_UNKNOWN:
            return "UNKNOWN";
        case STATE_OFF:
            return "OFF";
        case STATE_ON:
            return "ON";
        case STATE_DOZE:
            return "DOZE";
        case STATE_DOZE_SUSPEND:
            return "DOZE_SUSPEND";
        case STATE_VR:
            return "VR";
        default:
            return Integer.toString(state);
    }
}
------------------------
Find a silently evolved API code:android.widget.CalendarViewLegacyDelegate.WeekView.drawBackground:COMMENT
Method Modifier: private     
Comment:/**
 * This draws the selection highlight if a day is selected in this week.
 *
 * @param canvas The canvas to draw on
 */

Body of Frist Method:
{
    if (!mHasSelectedDay) {
        return;
    }
    mDrawPaint.setColor(mSelectedWeekBackgroundColor);
    mTempRect.top = mWeekSeperatorLineWidth;
    mTempRect.bottom = mHeight;
    final boolean isLayoutRtl = isLayoutRtl();
    if (isLayoutRtl) {
        mTempRect.left = 0;
        mTempRect.right = mSelectedLeft - 2;
    } else {
        mTempRect.left = mShowWeekNumber ? mWidth / mNumCells : 0;
        mTempRect.right = mSelectedLeft - 2;
    }
    canvas.drawRect(mTempRect, mDrawPaint);
    if (isLayoutRtl) {
        mTempRect.left = mSelectedRight + 3;
        mTempRect.right = mShowWeekNumber ? mWidth - mWidth / mNumCells : mWidth;
    } else {
        mTempRect.left = mSelectedRight + 3;
        mTempRect.right = mWidth;
    }
    canvas.drawRect(mTempRect, mDrawPaint);
}
Body of Second Method:
{
    if (!mHasSelectedDay) {
        return;
    }
    mDrawPaint.setColor(mSelectedWeekBackgroundColor);
    mTempRect.top = mWeekSeparatorLineWidth;
    mTempRect.bottom = mHeight;
    final boolean isLayoutRtl = isLayoutRtl();
    if (isLayoutRtl) {
        mTempRect.left = 0;
        mTempRect.right = mSelectedLeft - 2;
    } else {
        mTempRect.left = mShowWeekNumber ? mWidth / mNumCells : 0;
        mTempRect.right = mSelectedLeft - 2;
    }
    canvas.drawRect(mTempRect, mDrawPaint);
    if (isLayoutRtl) {
        mTempRect.left = mSelectedRight + 3;
        mTempRect.right = mShowWeekNumber ? mWidth - mWidth / mNumCells : mWidth;
    } else {
        mTempRect.left = mSelectedRight + 3;
        mTempRect.right = mWidth;
    }
    canvas.drawRect(mTempRect, mDrawPaint);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.isLeEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return true if Bluetooth LE(Always BLE On feature) is currently
 * enabled and ready for use
 * <p>This returns true if current state is either STATE_ON or STATE_BLE_ON
 *
 * @return true if the local Bluetooth LE adapter is turned on
 * @hide
 */

Body of Frist Method:
{
    final int state = getLeState();
    if (state == BluetoothAdapter.STATE_ON) {
        if (DBG)
            Log.d(TAG, "STATE_ON");
    } else if (state == BluetoothAdapter.STATE_BLE_ON) {
        if (DBG)
            Log.d(TAG, "STATE_BLE_ON");
    } else {
        if (DBG)
            Log.d(TAG, "STATE_OFF");
        return false;
    }
    return true;
}
Body of Second Method:
{
    final int state = getLeState();
    if (DBG)
        Log.d(TAG, "isLeEnabled(): " + BluetoothAdapter.nameForState(state));
    return (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_BLE_ON);
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.listen:COMMENT
Method Modifier: public      
Comment:/**
 * Registers a listener object to receive notification of changes
 * in specified telephony states.
 * <p>
 * To register a listener, pass a {@link PhoneStateListener}
 * and specify at least one telephony state of interest in
 * the events argument.
 *
 * At registration, and when a specified telephony state
 * changes, the telephony manager invokes the appropriate
 * callback method on the listener object and passes the
 * current (updated) values.
 * <p>
 * To unregister a listener, pass the listener object and set the
 * events argument to
 * {@link PhoneStateListener#LISTEN_NONE LISTEN_NONE} (0).
 *
 * @param listener The {@link PhoneStateListener} object to register
 * (or unregister)
 * @param events The telephony state(s) of interest to the listener,
 * as a bitwise-OR combination of {@link PhoneStateListener}
 * LISTEN_ flags.
 */

Body of Frist Method:
{
    if (mContext == null)
        return;
    try {
        Boolean notifyNow = (getITelephony() != null);
        sRegistry.listenForSubscriber(listener.mSubId, getOpPackageName(), listener.callback, events, notifyNow);
    } catch (RemoteException ex) {
    // system process dead
    } catch (NullPointerException ex) {
    // system process dead
    }
}
Body of Second Method:
{
    if (mContext == null)
        return;
    try {
        boolean notifyNow = (getITelephony() != null);
        // telephony manager is created with.
        if (listener.mSubId == null) {
            listener.mSubId = mSubId;
        }
        sRegistry.listenForSubscriber(listener.mSubId, getOpPackageName(), listener.callback, events, notifyNow);
    } catch (RemoteException ex) {
    // system process dead
    } catch (NullPointerException ex) {
    // system process dead
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.getMarshalerForKey:COMMENT
Method Modifier: private     static      
Comment:/**
 * Get the marshaler compatible with the {@code key} and type {@code T}.
 *
 * @throws UnsupportedOperationException
 * if the native/managed type combination for {@code key} is not supported
 */

Body of Frist Method:
{
    return MarshalRegistry.getMarshaler(key.getTypeReference(), getNativeType(key.getTag()));
}
Body of Second Method:
{
    return MarshalRegistry.getMarshaler(key.getTypeReference(), nativeType);
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.setIsConferenced:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Indicates whether or not the specified call is currently conferenced into the specified
 * conference call.
 *
 * @param callId The unique ID of the call being conferenced.
 * @param conferenceCallId The unique ID of the conference call. Null if call is not
 * conferenced.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            Log.d(this, "sending connection %s with conference %s", callId, conferenceCallId);
            adapter.setIsConferenced(callId, conferenceCallId);
        } catch (RemoteException ignored) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            Log.d(this, "sending connection %s with conference %s", callId, conferenceCallId);
            adapter.setIsConferenced(callId, conferenceCallId, Log.getExternalSession());
        } catch (RemoteException ignored) {
        }
    }
}
------------------------
Find a silently evolved API code:android.content.UndoManager.saveInstanceState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Flatten the current undo state into a Parcel object, which can later be restored
 * with {@link #restoreInstanceState(android.os.Parcel, java.lang.ClassLoader)}.
 */

Body of Frist Method:
{
    if (mUpdateCount > 0) {
        throw new IllegalStateException("Can't save state while updating");
    }
    mStateSeq++;
    if (mStateSeq <= 0) {
        mStateSeq = 0;
    }
    mNextSavedIdx = 0;
    p.writeInt(mHistorySize);
    p.writeInt(mOwners.size());
    // XXX eventually we need to be smart here about limiting the
    // number of undo states we write to not exceed X bytes.
    int i = mUndos.size();
    while (i > 0) {
        p.writeInt(1);
        i--;
        mUndos.get(i).writeToParcel(p);
    }
    i = mRedos.size();
    p.writeInt(i);
    while (i > 0) {
        p.writeInt(2);
        i--;
        mRedos.get(i).writeToParcel(p);
    }
    p.writeInt(0);
}
Body of Second Method:
{
    if (mUpdateCount > 0) {
        throw new IllegalStateException("Can't save state while updating");
    }
    mStateSeq++;
    if (mStateSeq <= 0) {
        mStateSeq = 0;
    }
    mNextSavedIdx = 0;
    p.writeInt(mHistorySize);
    p.writeInt(mOwners.size());
    // XXX eventually we need to be smart here about limiting the
    // number of undo states we write to not exceed X bytes.
    int i = mUndos.size();
    while (i > 0) {
        p.writeInt(1);
        i--;
        mUndos.get(i).writeToParcel(p);
    }
    i = mRedos.size();
    while (i > 0) {
        p.writeInt(2);
        i--;
        mRedos.get(i).writeToParcel(p);
    }
    p.writeInt(0);
}
------------------------
Find a silently evolved API code:android.content.pm.ActivityInfo.resizeModeToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(mode) {
        case RESIZE_MODE_UNRESIZEABLE:
            return "RESIZE_MODE_UNRESIZEABLE";
        case RESIZE_MODE_CROP_WINDOWS:
            return "RESIZE_MODE_CROP_WINDOWS";
        case RESIZE_MODE_RESIZEABLE:
            return "RESIZE_MODE_RESIZEABLE";
        case RESIZE_MODE_RESIZEABLE_AND_PIPABLE:
            return "RESIZE_MODE_RESIZEABLE_AND_PIPABLE";
        case RESIZE_MODE_FORCE_RESIZEABLE:
            return "RESIZE_MODE_FORCE_RESIZEABLE";
        default:
            return "unknown=" + mode;
    }
}
Body of Second Method:
{
    switch(mode) {
        case RESIZE_MODE_UNRESIZEABLE:
            return "RESIZE_MODE_UNRESIZEABLE";
        case RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION:
            return "RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION";
        case RESIZE_MODE_RESIZEABLE:
            return "RESIZE_MODE_RESIZEABLE";
        case RESIZE_MODE_FORCE_RESIZEABLE:
            return "RESIZE_MODE_FORCE_RESIZEABLE";
        case RESIZE_MODE_FORCE_RESIZABLE_PORTRAIT_ONLY:
            return "RESIZE_MODE_FORCE_RESIZABLE_PORTRAIT_ONLY";
        case RESIZE_MODE_FORCE_RESIZABLE_LANDSCAPE_ONLY:
            return "RESIZE_MODE_FORCE_RESIZABLE_LANDSCAPE_ONLY";
        case RESIZE_MODE_FORCE_RESIZABLE_PRESERVE_ORIENTATION:
            return "RESIZE_MODE_FORCE_RESIZABLE_PRESERVE_ORIENTATION";
        default:
            return "unknown=" + mode;
    }
}
------------------------
Find a silently evolved API code:android.content.IntentSender.sendIntent:COMMENT
Method Modifier: public      
Comment:/**
 * Perform the operation associated with this IntentSender, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the IntentSender's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 *
 * @throws SendIntentException Throws CanceledIntentException if the IntentSender
 * is no longer allowing more intents to be sent through it.
 */

Body of Frist Method:
{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = ActivityManagerNative.getDefault().sendIntentSender(mTarget, code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, null);
        if (res < 0) {
            throw new SendIntentException();
        }
    } catch (RemoteException e) {
        throw new SendIntentException();
    }
}
Body of Second Method:
{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = ActivityManager.getService().sendIntentSender(mTarget, mWhitelistToken, code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, null);
        if (res < 0) {
            throw new SendIntentException();
        }
    } catch (RemoteException e) {
        throw new SendIntentException();
    }
}
------------------------
Find a silently evolved API code:android.os.RemoteCallbackList.finishBroadcast:COMMENT
Method Modifier: public      
Comment:/**
 * Clean up the state of a broadcast previously initiated by calling
 * {@link #beginBroadcast}.  This must always be called when you are done
 * with a broadcast.
 *
 * @see #beginBroadcast
 */

Body of Frist Method:
{
    if (mBroadcastCount < 0) {
        throw new IllegalStateException("finishBroadcast() called outside of a broadcast");
    }
    Object[] active = mActiveBroadcast;
    if (active != null) {
        final int N = mBroadcastCount;
        for (int i = 0; i < N; i++) {
            active[i] = null;
        }
    }
    mBroadcastCount = -1;
}
Body of Second Method:
{
    synchronized (mCallbacks) {
        if (mBroadcastCount < 0) {
            throw new IllegalStateException("finishBroadcast() called outside of a broadcast");
        }
        Object[] active = mActiveBroadcast;
        if (active != null) {
            final int N = mBroadcastCount;
            for (int i = 0; i < N; i++) {
                active[i] = null;
            }
        }
        mBroadcastCount = -1;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.registerApp:COMMENT
Method Modifier: private     
Comment:/**
 * Register an application callback to start using GATT.
 *
 * <p>This is an asynchronous call. The callback {@link BluetoothGattCallback#onAppRegistered}
 * is used to notify success or failure if the function returns true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @return If true, the callback will be called to notify success or failure,
 * false on immediate error
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "registerApp()");
    if (mService == null)
        return false;
    mCallback = callback;
    UUID uuid = UUID.randomUUID();
    if (DBG)
        Log.d(TAG, "registerApp() - UUID=" + uuid);
    try {
        mService.registerClient(new ParcelUuid(uuid), mBluetoothGattCallback);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "registerApp()");
    if (mService == null)
        return false;
    mCallback = callback;
    mHandler = handler;
    UUID uuid = UUID.randomUUID();
    if (DBG)
        Log.d(TAG, "registerApp() - UUID=" + uuid);
    try {
        mService.registerClient(new ParcelUuid(uuid), mBluetoothGattCallback);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.stopBluetoothSco:COMMENT
Method Modifier: public      
Comment:// Also used for connections started with {@link #startBluetoothScoVirtualCall()}

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.stopBluetoothSco(mICallBack);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.stopBluetoothSco(mICallBack);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getAltSubjectMatch:COMMENT
Method Modifier: public      
Comment:/**
 * Get alternate subject match
 * @return the alternate subject match string
 */

Body of Frist Method:
{
    return getFieldValue(ALTSUBJECT_MATCH_KEY, "");
}
Body of Second Method:
{
    return getFieldValue(ALTSUBJECT_MATCH_KEY);
}
------------------------
Find a silently evolved API code:android.graphics.Path.incReserve:COMMENT
Method Modifier: public      
Comment:/**
 * Hint to the path to prepare for adding more points. This can allow the
 * path to more efficiently allocate its storage.
 *
 * @param extraPtCount The number of extra points that may be added to this
 * path
 */

Body of Frist Method:
{
    native_incReserve(mNativePath, extraPtCount);
}
Body of Second Method:
{
    nIncReserve(mNativePath, extraPtCount);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothManager.openGattServer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Open a GATT Server
 * The callback is used to deliver results to Caller, such as connection status as well
 * as the results of any other GATT server operations.
 * The method returns a BluetoothGattServer instance. You can use BluetoothGattServer
 * to conduct GATT server operations.
 * @param context App context
 * @param callback GATT server callback handler that will receive asynchronous callbacks.
 * @param transport preferred transport for GATT connections to remote dual-mode devices
 * {@link BluetoothDevice#TRANSPORT_AUTO} or
 * {@link BluetoothDevice#TRANSPORT_BREDR} or {@link BluetoothDevice#TRANSPORT_LE}
 * @return BluetoothGattServer instance
 * @hide
 */

Body of Frist Method:
{
    if (context == null || callback == null) {
        throw new IllegalArgumentException("null parameter: " + context + " " + callback);
    }
    try {
        IBluetoothManager managerService = mAdapter.getBluetoothManager();
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            Log.e(TAG, "Fail to get GATT Server connection");
            return null;
        }
        BluetoothGattServer mGattServer = new BluetoothGattServer(context, iGatt, transport);
        Boolean regStatus = mGattServer.registerCallback(callback);
        return regStatus ? mGattServer : null;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return null;
    }
}
Body of Second Method:
{
    if (context == null || callback == null) {
        throw new IllegalArgumentException("null parameter: " + context + " " + callback);
    }
    try {
        IBluetoothManager managerService = mAdapter.getBluetoothManager();
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            Log.e(TAG, "Fail to get GATT Server connection");
            return null;
        }
        BluetoothGattServer mGattServer = new BluetoothGattServer(iGatt, transport);
        Boolean regStatus = mGattServer.registerCallback(callback);
        return regStatus ? mGattServer : null;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.media.PlayerBase.isRestricted_sync:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * To be called by the subclass whenever an operation is potentially restricted.
 * As the media player-common behavior are incorporated into this class, the subclass's need
 * to call this method should be removed, and this method could become private.
 * FIXME can this method be private so subclasses don't have to worry about when to check
 * the restrictions.
 * @return
 */

Body of Frist Method:
{
    // check app ops
    if (mHasAppOpsPlayAudio) {
        return false;
    }
    // check bypass flag
    if ((mAttributes.getAllFlags() & AudioAttributes.FLAG_BYPASS_INTERRUPTION_POLICY) != 0) {
        return false;
    }
    return true;
}
Body of Second Method:
{
    // check app ops
    if (mHasAppOpsPlayAudio) {
        return false;
    }
    // check bypass flag
    if ((mAttributes.getAllFlags() & AudioAttributes.FLAG_BYPASS_INTERRUPTION_POLICY) != 0) {
        return false;
    }
    // check force audibility flag and camera restriction
    if (((mAttributes.getAllFlags() & AudioAttributes.FLAG_AUDIBILITY_ENFORCED) != 0) && (mAttributes.getUsage() == AudioAttributes.USAGE_ASSISTANCE_SONIFICATION)) {
        boolean cameraSoundForced = false;
        try {
            cameraSoundForced = getService().isCameraSoundForced();
        } catch (RemoteException e) {
            Log.e(TAG, "Cannot access AudioService in isRestricted_sync()");
        } catch (NullPointerException e) {
            Log.e(TAG, "Null AudioService in isRestricted_sync()");
        }
        if (cameraSoundForced) {
            return false;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.findIndex:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Find first stats index that matches the requested parameters.
 */

Body of Frist Method:
{
    for (int i = 0; i < size; i++) {
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && roaming == this.roaming[i] && Objects.equals(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
Body of Second Method:
{
    for (int i = 0; i < size; i++) {
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && metered == this.metered[i] && roaming == this.roaming[i] && Objects.equals(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.findIndexByLayerId:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the layer with the specified {@code id}.
 * <p>
 * If multiple layers have the same ID, returns the layer with the lowest
 * index.
 *
 * @param id The ID of the layer to return.
 * @return The index of the layer with the specified ID.
 */

Body of Frist Method:
{
    final ChildDrawable[] layers = mLayerState.mChildren;
    final int N = mLayerState.mNum;
    for (int i = 0; i < N; i++) {
        final ChildDrawable childDrawable = layers[i];
        if (childDrawable.mId == id) {
            return i;
        }
    }
    return -1;
}
Body of Second Method:
{
    final ChildDrawable[] layers = mLayerState.mChildren;
    final int N = mLayerState.mNumChildren;
    for (int i = 0; i < N; i++) {
        final ChildDrawable childDrawable = layers[i];
        if (childDrawable.mId == id) {
            return i;
        }
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.view.FrameMetrics.getMetric:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the value associated with Metric identifier {@code id}
 * for this frame.
 * <p>
 * Boolean metrics are represented in [0,1], with 0 corresponding to
 * false, and 1 corresponding to true.
 * </p>
 * @param id the metric to retrieve
 * @return the value of the metric or -1 if it is not available.
 */

Body of Frist Method:
{
    if (id < UNKNOWN_DELAY_DURATION || id > FIRST_DRAW_FRAME) {
        return -1;
    }
    if (mTimingData == null) {
        return -1;
    }
    if (id == FIRST_DRAW_FRAME) {
        return (mTimingData[Index.FLAGS] & FRAME_INFO_FLAG_FIRST_DRAW) != 0 ? 1 : 0;
    }
    int durationsIdx = 2 * id;
    return mTimingData[DURATIONS[durationsIdx + 1]] - mTimingData[DURATIONS[durationsIdx]];
}
Body of Second Method:
{
    if (id < UNKNOWN_DELAY_DURATION || id > VSYNC_TIMESTAMP) {
        return -1;
    }
    if (mTimingData == null) {
        return -1;
    }
    if (id == FIRST_DRAW_FRAME) {
        return (mTimingData[Index.FLAGS] & FRAME_INFO_FLAG_FIRST_DRAW) != 0 ? 1 : 0;
    } else if (id == INTENDED_VSYNC_TIMESTAMP) {
        return mTimingData[Index.INTENDED_VSYNC];
    } else if (id == VSYNC_TIMESTAMP) {
        return mTimingData[Index.VSYNC];
    }
    int durationsIdx = 2 * id;
    return mTimingData[DURATIONS[durationsIdx + 1]] - mTimingData[DURATIONS[durationsIdx]];
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.setStream:COMMENT
Method Modifier: public      
Comment:/**
 * Change the current system wallpaper to a specific byte stream, specifying a
 * hint about which subrectangle of the full image is to be visible.  The OS will
 * then try to best present the given portion of the full image as the static system
 * wallpaper image.  The data from the given InputStream is copied into persistent
 * storage and will then be used as the system wallpaper.  Currently the data must
 * be either a JPEG or PNG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param bitmapData A stream containing the raw data to install as a wallpaper.  This
 * data can be in any format handled by {@link BitmapRegionDecoder}.
 * @param visibleCropHint The rectangular subregion of the streamed image that should be
 * displayed as wallpaper.  Passing {@code null} for this parameter means that
 * the full image should be displayed if possible given the image's and device's
 * aspect ratios, etc.
 * @param allowBackup {@code true} if the OS is permitted to back up this wallpaper
 * image for restore to a future device; {@code false} otherwise.
 * @return An integer ID assigned to the newly active wallpaper; or zero on failure.
 *
 * @see #getWallpaperId(int)
 *
 * @throws IOException If an error occurs when attempting to set the wallpaper
 * based on the provided image data.
 * @throws IllegalArgumentException If the {@code visibleCropHint} rectangle is
 * empty or invalid.
 */

Body of Frist Method:
{
    return setStream(bitmapData, visibleCropHint, allowBackup, FLAG_SYSTEM);
}
Body of Second Method:
{
    return setStream(bitmapData, visibleCropHint, allowBackup, FLAG_SYSTEM | FLAG_LOCK);
}
------------------------
Find a silently evolved API code:android.widget.AbsSeekBar.onInitializeAccessibilityNodeInfoInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    if (isEnabled()) {
        final int progress = getProgress();
        if (progress > 0) {
            info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_BACKWARD);
        }
        if (progress < getMax()) {
            info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_FORWARD);
        }
    }
}
Body of Second Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    if (isEnabled()) {
        final int progress = getProgress();
        if (progress > getMin()) {
            info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_BACKWARD);
        }
        if (progress < getMax()) {
            info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_FORWARD);
        }
    }
}
------------------------
Find a silently evolved API code:android.content.ClipDescription.getMimeType:COMMENT
Method Modifier: public      
Comment:/**
 * Return one of the possible clip MIME types.
 */

Body of Frist Method:
{
    return mMimeTypes[index];
}
Body of Second Method:
{
    return mMimeTypes.get(index);
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getCurrentPhoneTypeForSlot:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * See getCurrentPhoneType.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getActivePhoneTypeForSlot(slotId);
        } else {
            // This can happen when the ITelephony interface is not up yet.
            return getPhoneTypeFromProperty(slotId);
        }
    } catch (RemoteException ex) {
        // read from the system property.
        return getPhoneTypeFromProperty(slotId);
    } catch (NullPointerException ex) {
        // read from the system property.
        return getPhoneTypeFromProperty(slotId);
    }
}
Body of Second Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getActivePhoneTypeForSlot(slotIndex);
        } else {
            // This can happen when the ITelephony interface is not up yet.
            return getPhoneTypeFromProperty(slotIndex);
        }
    } catch (RemoteException ex) {
        // read from the system property.
        return getPhoneTypeFromProperty(slotIndex);
    } catch (NullPointerException ex) {
        // read from the system property.
        return getPhoneTypeFromProperty(slotIndex);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setWiredDeviceConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Indicate wired accessory connection state change.
 * @param device type of device connected/disconnected (AudioManager.DEVICE_OUT_xxx)
 * @param state  new connection state: 1 connected, 0 disconnected
 * @param name   device name
 * {@hide}
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setWiredDeviceConnectionState(type, state, address, name, mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.setWiredDeviceConnectionState(type, state, address, name, mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.text.method.WordIterator.following:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    int shiftedOffset = offset - mOffsetShift;
    do {
        shiftedOffset = mIterator.following(shiftedOffset);
        if (shiftedOffset == BreakIterator.DONE) {
            return BreakIterator.DONE;
        }
        if (isAfterLetterOrDigit(shiftedOffset)) {
            return shiftedOffset + mOffsetShift;
        }
    } while (true);
}
Body of Second Method:
{
    checkOffsetIsValid(offset);
    while (true) {
        offset = mIterator.following(offset);
        if (offset == BreakIterator.DONE || isAfterLetterOrDigit(offset)) {
            return offset;
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.ensurePadding:COMMENT
Method Modifier: default     
Comment:/**
 * Ensures the child padding caches are large enough.
 */

Body of Frist Method:
{
    final int N = mLayerState.mNum;
    if (mPaddingL != null && mPaddingL.length >= N) {
        return;
    }
    mPaddingL = new int[N];
    mPaddingT = new int[N];
    mPaddingR = new int[N];
    mPaddingB = new int[N];
}
Body of Second Method:
{
    final int N = mLayerState.mNumChildren;
    if (mPaddingL != null && mPaddingL.length >= N) {
        return;
    }
    mPaddingL = new int[N];
    mPaddingT = new int[N];
    mPaddingR = new int[N];
    mPaddingB = new int[N];
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pManager.requestPeers:COMMENT
Method Modifier: public      
Comment:/**
 * Request the current list of peers.
 *
 * @param c is the channel created at {@link #initialize}
 * @param listener for callback when peer list is available. Can be null.
 */

Body of Frist Method:
{
    checkChannel(c);
    c.mAsyncChannel.sendMessage(REQUEST_PEERS, 0, c.putListener(listener));
}
Body of Second Method:
{
    checkChannel(c);
    Bundle callingPackage = new Bundle();
    callingPackage.putString(CALLING_PACKAGE, c.mContext.getOpPackageName());
    c.mAsyncChannel.sendMessage(REQUEST_PEERS, 0, c.putListener(listener), callingPackage);
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.setSpellCheckerSubtype:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        final int hashCode;
        if (subtype == null) {
            hashCode = 0;
        } else {
            hashCode = subtype.hashCode();
        }
        sService.setCurrentSpellCheckerSubtype(null, hashCode);
    } catch (RemoteException e) {
        Log.e(TAG, "Error in setSpellCheckerSubtype:" + e);
    }
}
Body of Second Method:
{
    try {
        final int hashCode;
        if (subtype == null) {
            hashCode = 0;
        } else {
            hashCode = subtype.hashCode();
        }
        mService.setCurrentSpellCheckerSubtype(null, hashCode);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.InsetDrawable.getOpticalInsets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final Insets contentInsets = super.getOpticalInsets();
    return Insets.of(contentInsets.left + mState.mInsetLeft, contentInsets.top + mState.mInsetTop, contentInsets.right + mState.mInsetRight, contentInsets.bottom + mState.mInsetBottom);
}
Body of Second Method:
{
    final Insets contentInsets = super.getOpticalInsets();
    getInsets(mTmpInsetRect);
    return Insets.of(contentInsets.left + mTmpInsetRect.left, contentInsets.top + mTmpInsetRect.top, contentInsets.right + mTmpInsetRect.right, contentInsets.bottom + mTmpInsetRect.bottom);
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.setIsVoipAudioMode:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Requests that the framework use VOIP audio mode for this connection.
 *
 * @param callId The unique ID of the call to set with the given call video provider.
 * @param isVoip True if the audio mode is VOIP.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setIsVoipAudioMode(callId, isVoip);
        } catch (RemoteException e) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setIsVoipAudioMode(callId, isVoip, Log.getExternalSession());
        } catch (RemoteException e) {
        }
    }
}
------------------------
Find a silently evolved API code:android.app.usage.UsageEvents.writeEventToParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Writes a single event to the parcel. Modify this when updating {@link Event}.
 */

Body of Frist Method:
{
    final int packageIndex;
    if (event.mPackage != null) {
        packageIndex = findStringIndex(event.mPackage);
    } else {
        packageIndex = -1;
    }
    final int classIndex;
    if (event.mClass != null) {
        classIndex = findStringIndex(event.mClass);
    } else {
        classIndex = -1;
    }
    p.writeInt(packageIndex);
    p.writeInt(classIndex);
    p.writeInt(event.mEventType);
    p.writeLong(event.mTimeStamp);
    switch(event.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            event.mConfiguration.writeToParcel(p, flags);
            break;
        case Event.SHORTCUT_INVOCATION:
            p.writeString(event.mShortcutId);
            break;
    }
}
Body of Second Method:
{
    final int packageIndex;
    if (event.mPackage != null) {
        packageIndex = findStringIndex(event.mPackage);
    } else {
        packageIndex = -1;
    }
    final int classIndex;
    if (event.mClass != null) {
        classIndex = findStringIndex(event.mClass);
    } else {
        classIndex = -1;
    }
    p.writeInt(packageIndex);
    p.writeInt(classIndex);
    p.writeInt(event.mEventType);
    p.writeLong(event.mTimeStamp);
    switch(event.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            event.mConfiguration.writeToParcel(p, flags);
            break;
        case Event.SHORTCUT_INVOCATION:
            p.writeString(event.mShortcutId);
            break;
        case Event.CHOOSER_ACTION:
            p.writeString(event.mAction);
            p.writeString(event.mContentType);
            p.writeStringArray(event.mContentAnnotations);
            break;
    }
}
------------------------
Find a silently evolved API code:android.widget.DatePickerSpinnerDelegate.notifyDateChanged:COMMENT
Method Modifier: private     
Comment:/**
 * Notifies the listener, if such, for a change in the selected date.
 */

Body of Frist Method:
{
    mDelegator.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
    if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(mDelegator, getYear(), getMonth(), getDayOfMonth());
    }
}
Body of Second Method:
{
    mDelegator.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
    if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(mDelegator, getYear(), getMonth(), getDayOfMonth());
    }
    if (mAutoFillChangeListener != null) {
        mAutoFillChangeListener.onDateChanged(mDelegator, getYear(), getMonth(), getDayOfMonth());
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkCapabilities.describeFirstNonRequestableCapability:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Convenience function that returns a human-readable description of the first mutable
 * capability we find. Used to present an error message to apps that request mutable
 * capabilities.
 *
 * @hide
 */

Body of Frist Method:
{
    if (hasCapability(NET_CAPABILITY_VALIDATED))
        return "NET_CAPABILITY_VALIDATED";
    if (hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL))
        return "NET_CAPABILITY_CAPTIVE_PORTAL";
    // This cannot happen unless the preceding checks are incomplete.
    if ((mNetworkCapabilities & NON_REQUESTABLE_CAPABILITIES) != 0) {
        return "unknown non-requestable capabilities " + Long.toHexString(mNetworkCapabilities);
    }
    if (mLinkUpBandwidthKbps != 0 || mLinkDownBandwidthKbps != 0)
        return "link bandwidth";
    if (hasSignalStrength())
        return "signalStrength";
    return null;
}
Body of Second Method:
{
    if (hasCapability(NET_CAPABILITY_VALIDATED))
        return "NET_CAPABILITY_VALIDATED";
    if (hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL))
        return "NET_CAPABILITY_CAPTIVE_PORTAL";
    if (hasCapability(NET_CAPABILITY_FOREGROUND))
        return "NET_CAPABILITY_FOREGROUND";
    // This cannot happen unless the preceding checks are incomplete.
    if ((mNetworkCapabilities & NON_REQUESTABLE_CAPABILITIES) != 0) {
        return "unknown non-requestable capabilities " + Long.toHexString(mNetworkCapabilities);
    }
    if (mLinkUpBandwidthKbps != 0 || mLinkDownBandwidthKbps != 0)
        return "link bandwidth";
    if (hasSignalStrength())
        return "signalStrength";
    return null;
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.measureVertical:COMMENT
Method Modifier: default     
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

Body of Frist Method:
{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    int consumedExcessSpace = 0;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
        if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // Optimization: don't bother measuring children who are only
            // laid out using excess space. These views will get measured
            // later if we have space to distribute.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            if (useExcessSpace) {
                // The heightMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal height. We'll restore the original height of 0
                // after measurement.
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight);
            final int childHeight = child.getMeasuredHeight();
            if (useExcessSpace) {
                // Restore the original height and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.height = 0;
                consumedExcessSpace += childHeight;
            }
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException("A child of LinearLayout with index " + "less than mBaselineAlignedChildIndex has weight > 0, which " + "won't work.  Either remove the weight, or don't set " + "mBaselineAlignedChildIndex.");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childHeight;
                if (mUseLargestChild && heightMode != MeasureSpec.EXACTLY) {
                    childHeight = largestChildHeight;
                } else if (lp.height == 0 && (!mAllowInconsistentMeasurement || heightMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childHeight = share;
                } else {
                    // This child had some intrinsic height to which we
                    // need to add its share of excess space.
                    childHeight = child.getMeasuredHeight() + share;
                }
                final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}
Body of Second Method:
{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    int consumedExcessSpace = 0;
    int nonSkippedChildCount = 0;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        nonSkippedChildCount++;
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
        if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // Optimization: don't bother measuring children who are only
            // laid out using excess space. These views will get measured
            // later if we have space to distribute.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            if (useExcessSpace) {
                // The heightMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal height. We'll restore the original height of 0
                // after measurement.
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight);
            final int childHeight = child.getMeasuredHeight();
            if (useExcessSpace) {
                // Restore the original height and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.height = 0;
                consumedExcessSpace += childHeight;
            }
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException("A child of LinearLayout with index " + "less than mBaselineAlignedChildIndex has weight > 0, which " + "won't work.  Either remove the weight, or don't set " + "mBaselineAlignedChildIndex.");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (nonSkippedChildCount > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childHeight;
                if (mUseLargestChild && heightMode != MeasureSpec.EXACTLY) {
                    childHeight = largestChildHeight;
                } else if (lp.height == 0 && (!mAllowInconsistentMeasurement || heightMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childHeight = share;
                } else {
                    // This child had some intrinsic height to which we
                    // need to add its share of excess space.
                    childHeight = child.getMeasuredHeight() + share;
                }
                final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.isProjected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (super.isProjected()) {
        return true;
    }
    final ChildDrawable[] layers = mLayerState.mChildren;
    final int N = mLayerState.mNum;
    for (int i = 0; i < N; i++) {
        if (layers[i].mDrawable.isProjected()) {
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    if (super.isProjected()) {
        return true;
    }
    final ChildDrawable[] layers = mLayerState.mChildren;
    final int N = mLayerState.mNumChildren;
    for (int i = 0; i < N; i++) {
        if (layers[i].mDrawable.isProjected()) {
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.addLayer:COMMENT
Method Modifier: default     
Comment:/**
 * Adds a new layer at the end of list of layers and returns its index.
 *
 * @param layer The layer to add.
 * @return The index of the layer.
 */

Body of Frist Method:
{
    final LayerState st = mLayerState;
    final int N = st.mChildren != null ? st.mChildren.length : 0;
    final int i = st.mNum;
    if (i >= N) {
        final ChildDrawable[] nu = new ChildDrawable[N + 10];
        if (i > 0) {
            System.arraycopy(st.mChildren, 0, nu, 0, i);
        }
        st.mChildren = nu;
    }
    st.mChildren[i] = layer;
    st.mNum++;
    st.invalidateCache();
    return i;
}
Body of Second Method:
{
    final LayerState st = mLayerState;
    final int N = st.mChildren != null ? st.mChildren.length : 0;
    final int i = st.mNumChildren;
    if (i >= N) {
        final ChildDrawable[] nu = new ChildDrawable[N + 10];
        if (i > 0) {
            System.arraycopy(st.mChildren, 0, nu, 0, i);
        }
        st.mChildren = nu;
    }
    st.mChildren[i] = layer;
    st.mNumChildren++;
    st.invalidateCache();
    return i;
}
------------------------
Find a silently evolved API code:android.graphics.Path.addPath:COMMENT
Method Modifier: public      
Comment:/**
 * Add a copy of src to the path, transformed by matrix
 *
 * @param src The path to add as a new contour
 */

Body of Frist Method:
{
    if (!src.isSimplePath)
        isSimplePath = false;
    native_addPath(mNativePath, src.mNativePath, matrix.native_instance);
}
Body of Second Method:
{
    if (!src.isSimplePath)
        isSimplePath = false;
    nAddPath(mNativePath, src.mNativePath, matrix.native_instance);
}
------------------------
Find a silently evolved API code:android.util.MemoryIntArray.close:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Closes the array releasing resources.
 *
 * @throws IOException If an error occurs while accessing the shared memory.
 */

Body of Frist Method:
{
    if (!isClosed()) {
        nativeClose(mFd, mMemoryAddr, isOwner());
        mFd = -1;
    }
}
Body of Second Method:
{
    if (!isClosed()) {
        nativeClose(mFd, mMemoryAddr, mIsOwner);
        mFd = -1;
        mCloseGuard.close();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.stopTrackingBssids:COMMENT
<android.net.wifi.WifiScanner: void stopTrackingBssids(BssidListener)>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * remove tracking of interesting access points
 * @param listener same object provided in {@link #startTrackingBssids}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = removeListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    mAsyncChannel.sendMessage(CMD_RESET_HOTLIST, 0, key);
}
Body of Second Method:
{
    throw new UnsupportedOperationException();
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.setFromNotifierBundle:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Set SignalStrength based on intent notifier map
 *
 * @param m intent notifier map
 * @hide
 */

Body of Frist Method:
{
    mGsmSignalStrength = m.getInt("GsmSignalStrength");
    mGsmBitErrorRate = m.getInt("GsmBitErrorRate");
    mCdmaDbm = m.getInt("CdmaDbm");
    mCdmaEcio = m.getInt("CdmaEcio");
    mEvdoDbm = m.getInt("EvdoDbm");
    mEvdoEcio = m.getInt("EvdoEcio");
    mEvdoSnr = m.getInt("EvdoSnr");
    mLteSignalStrength = m.getInt("LteSignalStrength");
    mLteRsrp = m.getInt("LteRsrp");
    mLteRsrq = m.getInt("LteRsrq");
    mLteRssnr = m.getInt("LteRssnr");
    mLteCqi = m.getInt("LteCqi");
    mTdScdmaRscp = m.getInt("TdScdma");
    isGsm = m.getBoolean("isGsm");
}
Body of Second Method:
{
    mGsmSignalStrength = m.getInt("GsmSignalStrength");
    mGsmBitErrorRate = m.getInt("GsmBitErrorRate");
    mCdmaDbm = m.getInt("CdmaDbm");
    mCdmaEcio = m.getInt("CdmaEcio");
    mEvdoDbm = m.getInt("EvdoDbm");
    mEvdoEcio = m.getInt("EvdoEcio");
    mEvdoSnr = m.getInt("EvdoSnr");
    mLteSignalStrength = m.getInt("LteSignalStrength");
    mLteRsrp = m.getInt("LteRsrp");
    mLteRsrq = m.getInt("LteRsrq");
    mLteRssnr = m.getInt("LteRssnr");
    mLteCqi = m.getInt("LteCqi");
    mLteRsrpBoost = m.getInt("lteRsrpBoost");
    mTdScdmaRscp = m.getInt("TdScdma");
    isGsm = m.getBoolean("isGsm");
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.setRinging:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Sets a call's state to ringing (e.g., an inbound ringing call).
 *
 * @param callId The unique ID of the call whose state is changing to ringing.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setRinging(callId);
        } catch (RemoteException e) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setRinging(callId, Log.getExternalSession());
        } catch (RemoteException e) {
        }
    }
}
------------------------
Find a silently evolved API code:android.content.UriMatcher.addURI:COMMENT
Method Modifier: public      
Comment:/**
 * Add a URI to match, and the code to return when this URI is
 * matched. URI nodes may be exact match string, the token "*"
 * that matches any text, or the token "#" that matches only
 * numbers.
 * <p>
 * Starting from API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * this method will accept a leading slash in the path.
 *
 * @param authority the authority to match
 * @param path the path to match. * may be used as a wild card for
 * any text, and # may be used as a wild card for numbers.
 * @param code the code that is returned when a URI is matched
 * against the given components. Must be positive.
 */

Body of Frist Method:
{
    if (code < 0) {
        throw new IllegalArgumentException("code " + code + " is invalid: it must be positive");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 0 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = newPath.split("/");
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals("#")) {
                child.mWhich = NUMBER;
            } else if (token.equals("*")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}
Body of Second Method:
{
    if (code < 0) {
        throw new IllegalArgumentException("code " + code + " is invalid: it must be positive");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 1 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = newPath.split("/");
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals("#")) {
                child.mWhich = NUMBER;
            } else if (token.equals("*")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.clear:COMMENT
Method Modifier: private     
Comment:/**
 * Clears the internal state.
 */

Body of Frist Method:
{
    mType = UNDEFINED;
    mLayer = UNDEFINED;
    mBooleanProperties = 0;
    mId = UNDEFINED;
    mParentId = UNDEFINED;
    mBoundsInScreen.setEmpty();
    if (mChildIds != null) {
        mChildIds.clear();
    }
    mConnectionId = UNDEFINED;
    mAnchorId = UNDEFINED;
    mTitle = null;
}
Body of Second Method:
{
    mType = UNDEFINED_WINDOW_ID;
    mLayer = UNDEFINED_WINDOW_ID;
    mBooleanProperties = 0;
    mId = UNDEFINED_WINDOW_ID;
    mParentId = UNDEFINED_WINDOW_ID;
    mBoundsInScreen.setEmpty();
    if (mChildIds != null) {
        mChildIds.clear();
    }
    mConnectionId = UNDEFINED_WINDOW_ID;
    mAnchorId = UNDEFINED_WINDOW_ID;
    mInPictureInPicture = false;
    mTitle = null;
}
------------------------
Find a silently evolved API code:android.os.StatFs.getBlockSize:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated Use {@link #getBlockSizeLong()} instead.
 */

Body of Frist Method:
{
    return (int) mStat.f_bsize;
}
Body of Second Method:
{
    return (int) mStat.f_frsize;
}
------------------------
Find a silently evolved API code:android.text.method.WordIterator.nextBoundary:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the position of next boundary after the given offset. Returns
 * {@code DONE} if there is no boundary after the given offset.
 *
 * @param offset the given start position to search from.
 * @return the position of the last boundary preceding the given offset.
 */

Body of Frist Method:
{
    int shiftedOffset = offset - mOffsetShift;
    shiftedOffset = mIterator.following(shiftedOffset);
    if (shiftedOffset == BreakIterator.DONE) {
        return BreakIterator.DONE;
    }
    return shiftedOffset + mOffsetShift;
}
Body of Second Method:
{
    checkOffsetIsValid(offset);
    return mIterator.following(offset);
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.onConnectionEvent:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Informs Telecom of a connection level event.
 *
 * @param callId The unique ID of the call.
 * @param event The event.
 * @param extras Extras associated with the event.
 */

Body of Frist Method:
{
    Log.v(this, "onConnectionEvent: %s", event);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.onConnectionEvent(callId, event, extras);
        } catch (RemoteException ignored) {
        }
    }
}
Body of Second Method:
{
    Log.v(this, "onConnectionEvent: %s", event);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.onConnectionEvent(callId, event, extras, Log.getExternalSession());
        } catch (RemoteException ignored) {
        }
    }
}
------------------------
Find a silently evolved API code:javax.obex.ServerSession.handleConnectRequest:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Handles a connect request from a client. This method will read the rest
 * of the request from the client. Assuming the request is valid, it will
 * create a <code>HeaderSet</code> object to pass to the
 * <code>ServerRequestHandler</code> object. After the handler processes the
 * request, this method will create a reply message to send to the server
 * with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */

Body of Frist Method:
{
    int packetLength;
    @SuppressWarnings("unused") int version;
    @SuppressWarnings("unused") int flags;
    int totalLength = 7;
    byte[] head = null;
    int code = -1;
    HeaderSet request = new HeaderSet();
    HeaderSet reply = new HeaderSet();
    int bytesReceived;
    if (V)
        Log.v(TAG, "handleConnectRequest()");
    /*
         * Read in the length of the OBEX packet, OBEX version, flags, and max
         * packet length
         */
    packetLength = mInput.read();
    packetLength = (packetLength << 8) + mInput.read();
    if (V)
        Log.v(TAG, "handleConnectRequest() - packetLength: " + packetLength);
    version = mInput.read();
    flags = mInput.read();
    mMaxPacketLength = mInput.read();
    mMaxPacketLength = (mMaxPacketLength << 8) + mInput.read();
    if (V)
        Log.v(TAG, "handleConnectRequest() - version: " + version + " MaxLength: " + mMaxPacketLength + " flags: " + flags);
    // should we check it?
    if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
        mMaxPacketLength = ObexHelper.MAX_PACKET_SIZE_INT;
    }
    if (mMaxPacketLength > ObexHelper.getMaxTxPacketSize(mTransport)) {
        Log.w(TAG, "Requested MaxObexPacketSize " + mMaxPacketLength + " is larger than the max size supported by the transport: " + ObexHelper.getMaxTxPacketSize(mTransport) + " Reducing to this size.");
        mMaxPacketLength = ObexHelper.getMaxTxPacketSize(mTransport);
    }
    if (packetLength > ObexHelper.getMaxRxPacketSize(mTransport)) {
        code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
        totalLength = 7;
    } else {
        if (packetLength > 7) {
            byte[] headers = new byte[packetLength - 7];
            bytesReceived = mInput.read(headers);
            while (bytesReceived != headers.length) {
                bytesReceived += mInput.read(headers, bytesReceived, headers.length - bytesReceived);
            }
            ObexHelper.updateHeaderSet(request, headers);
        }
        if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
            mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
        } else {
            mListener.setConnectionId(1);
        }
        if (request.mAuthResp != null) {
            if (!handleAuthResp(request.mAuthResp)) {
                code = ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
                mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte) 0x01, request.mAuthResp));
            }
            request.mAuthResp = null;
        }
        if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
            if (request.mAuthChall != null) {
                handleAuthChall(request);
                reply.mAuthResp = new byte[request.mAuthResp.length];
                System.arraycopy(request.mAuthResp, 0, reply.mAuthResp, 0, reply.mAuthResp.length);
                request.mAuthChall = null;
                request.mAuthResp = null;
            }
            try {
                code = mListener.onConnect(request, reply);
                code = validateResponseCode(code);
                if (reply.nonce != null) {
                    mChallengeDigest = new byte[16];
                    System.arraycopy(reply.nonce, 0, mChallengeDigest, 0, 16);
                } else {
                    mChallengeDigest = null;
                }
                long id = mListener.getConnectionId();
                if (id == -1) {
                    reply.mConnectionID = null;
                } else {
                    reply.mConnectionID = ObexHelper.convertToByteArray(id);
                }
                head = ObexHelper.createHeader(reply, false);
                totalLength += head.length;
                if (totalLength > mMaxPacketLength) {
                    totalLength = 7;
                    head = null;
                    code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
                }
            } catch (Exception e) {
                if (V)
                    Log.d(TAG, "Exception occured - sending OBEX_HTTP_INTERNAL_ERROR reply", e);
                totalLength = 7;
                head = null;
                code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
            }
        }
    }
    // Compute Length of OBEX CONNECT packet
    byte[] length = ObexHelper.convertToByteArray(totalLength);
    /*
         * Write the OBEX CONNECT packet to the server. Byte 0: response code
         * Byte 1&2: Connect Packet Length Byte 3: OBEX Version Number
         * (Presently, 0x10) Byte 4: Flags (For TCP 0x00) Byte 5&6: Max OBEX
         * Packet Length (Defined in MAX_PACKET_SIZE) Byte 7 to n: headers
         */
    byte[] sendData = new byte[totalLength];
    int maxRxLength = ObexHelper.getMaxRxPacketSize(mTransport);
    sendData[0] = (byte) code;
    sendData[1] = length[2];
    sendData[2] = length[3];
    sendData[3] = (byte) 0x10;
    sendData[4] = (byte) 0x00;
    sendData[5] = (byte) (maxRxLength >> 8);
    sendData[6] = (byte) (maxRxLength & 0xFF);
    if (head != null) {
        System.arraycopy(head, 0, sendData, 7, head.length);
    }
    mOutput.write(sendData);
    mOutput.flush();
}
Body of Second Method:
{
    int packetLength;
    @SuppressWarnings("unused") int version;
    @SuppressWarnings("unused") int flags;
    int totalLength = 7;
    byte[] head = null;
    int code = -1;
    HeaderSet request = new HeaderSet();
    HeaderSet reply = new HeaderSet();
    int bytesReceived;
    if (V)
        Log.v(TAG, "handleConnectRequest()");
    /*
         * Read in the length of the OBEX packet, OBEX version, flags, and max
         * packet length
         */
    packetLength = mInput.read();
    packetLength = (packetLength << 8) + mInput.read();
    if (V)
        Log.v(TAG, "handleConnectRequest() - packetLength: " + packetLength);
    version = mInput.read();
    flags = mInput.read();
    mMaxPacketLength = mInput.read();
    mMaxPacketLength = (mMaxPacketLength << 8) + mInput.read();
    if (V)
        Log.v(TAG, "handleConnectRequest() - version: " + version + " MaxLength: " + mMaxPacketLength + " flags: " + flags);
    // should we check it?
    if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
        mMaxPacketLength = ObexHelper.MAX_PACKET_SIZE_INT;
    }
    if (mMaxPacketLength > ObexHelper.getMaxTxPacketSize(mTransport)) {
        Log.w(TAG, "Requested MaxObexPacketSize " + mMaxPacketLength + " is larger than the max size supported by the transport: " + ObexHelper.getMaxTxPacketSize(mTransport) + " Reducing to this size.");
        mMaxPacketLength = ObexHelper.getMaxTxPacketSize(mTransport);
    }
    if (packetLength > ObexHelper.getMaxRxPacketSize(mTransport)) {
        code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
        totalLength = 7;
    } else {
        if (packetLength > 7) {
            byte[] headers = new byte[packetLength - 7];
            bytesReceived = mInput.read(headers);
            while (bytesReceived != headers.length) {
                bytesReceived += mInput.read(headers, bytesReceived, headers.length - bytesReceived);
            }
            ObexHelper.updateHeaderSet(request, headers);
        }
        if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
            mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
        } else {
            mListener.setConnectionId(1);
        }
        if (request.mAuthResp != null) {
            if (!handleAuthResp(request.mAuthResp)) {
                code = ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
                mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte) 0x01, request.mAuthResp));
            }
            request.mAuthResp = null;
        }
        if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
            if (request.mAuthChall != null) {
                handleAuthChall(request);
                reply.mAuthResp = new byte[request.mAuthResp.length];
                System.arraycopy(request.mAuthResp, 0, reply.mAuthResp, 0, reply.mAuthResp.length);
                request.mAuthChall = null;
                request.mAuthResp = null;
            }
            try {
                code = mListener.onConnect(request, reply);
                code = validateResponseCode(code);
                if (reply.nonce != null) {
                    mChallengeDigest = new byte[16];
                    System.arraycopy(reply.nonce, 0, mChallengeDigest, 0, 16);
                } else {
                    mChallengeDigest = null;
                }
                long id = mListener.getConnectionId();
                if (id == -1) {
                    reply.mConnectionID = null;
                } else {
                    reply.mConnectionID = ObexHelper.convertToByteArray(id);
                }
                head = ObexHelper.createHeader(reply, false);
                totalLength += head.length;
                if (totalLength > mMaxPacketLength) {
                    totalLength = 7;
                    head = null;
                    code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
                }
            } catch (Exception e) {
                if (V)
                    Log.d(TAG, "Exception occured - sending OBEX_HTTP_INTERNAL_ERROR reply", e);
                totalLength = 7;
                head = null;
                code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
            }
        }
    }
    // Compute Length of OBEX CONNECT packet
    byte[] length = ObexHelper.convertToByteArray(totalLength);
    /*
         * Write the OBEX CONNECT packet to the server. Byte 0: response code
         * Byte 1&2: Connect Packet Length Byte 3: OBEX Version Number
         * (Presently, 0x10) Byte 4: Flags (For TCP 0x00) Byte 5&6: Max OBEX
         * Packet Length (Defined in MAX_PACKET_SIZE) Byte 7 to n: headers
         */
    byte[] sendData = new byte[totalLength];
    int maxRxLength = ObexHelper.getMaxRxPacketSize(mTransport);
    if (maxRxLength > mMaxPacketLength) {
        if (V)
            Log.v(TAG, "Set maxRxLength to min of maxRxServrLen:" + maxRxLength + " and MaxNegotiated from Client: " + mMaxPacketLength);
        maxRxLength = mMaxPacketLength;
    }
    sendData[0] = (byte) code;
    sendData[1] = length[2];
    sendData[2] = length[3];
    sendData[3] = (byte) 0x10;
    sendData[4] = (byte) 0x00;
    sendData[5] = (byte) (maxRxLength >> 8);
    sendData[6] = (byte) (maxRxLength & 0xFF);
    if (head != null) {
        System.arraycopy(head, 0, sendData, 7, head.length);
    }
    mOutput.write(sendData);
    mOutput.flush();
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.getClipBounds:COMMENT
Method Modifier: public      
Comment:/**
 * Return the bounds of the current clip (in local coordinates) in the
 * bounds parameter, and return true if it is non-empty. This can be useful
 * in a way similar to quickReject, in that it tells you that drawing
 * outside of these bounds will be clipped out.
 *
 * @param bounds Return the clip bounds here. If it is null, ignore it but
 * still return true if the current clip is non-empty.
 * @return true if the current clip is non-empty.
 */

Body of Frist Method:
{
    return native_getClipBounds(mNativeCanvasWrapper, bounds);
}
Body of Second Method:
{
    return nGetClipBounds(mNativeCanvasWrapper, bounds);
}
------------------------
Find a silently evolved API code:android.view.Display.toString:COMMENT
Method Modifier: public      
Comment:// For debugging purposes

Body of Frist Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(mTempMetrics, mDisplayAdjustments);
        return "Display id " + mDisplayId + ": " + mDisplayInfo + ", " + mTempMetrics + ", isValid=" + mIsValid;
    }
}
Body of Second Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(mTempMetrics, getDisplayAdjustments());
        return "Display id " + mDisplayId + ": " + mDisplayInfo + ", " + mTempMetrics + ", isValid=" + mIsValid;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setEapMethod:COMMENT
Method Modifier: public      
Comment:/**
 * Set the EAP authentication method.
 * @param  eapMethod is one {@link Eap#PEAP}, {@link Eap#TLS}, {@link Eap#TTLS} or
 * {@link Eap#PWD}
 * @throws IllegalArgumentException on an invalid eap method
 */

Body of Frist Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.TLS:
        case Eap.UNAUTH_TLS:
            setPhase2Method(Phase2.NONE);
        /* fall through */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TTLS:
        case Eap.SIM:
        case Eap.AKA:
        case Eap.AKA_PRIME:
            mEapMethod = eapMethod;
            mFields.put(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
Body of Second Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.TLS:
        case Eap.UNAUTH_TLS:
            setPhase2Method(Phase2.NONE);
        /* fall through */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TTLS:
        case Eap.SIM:
        case Eap.AKA:
        case Eap.AKA_PRIME:
            mEapMethod = eapMethod;
            setFieldValue(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path.rMoveTo:COMMENT
Method Modifier: public      
Comment:/**
 * Set the beginning of the next contour relative to the last point on the
 * previous contour. If there is no previous contour, this is treated the
 * same as moveTo().
 *
 * @param dx The amount to add to the x-coordinate of the end of the
 * previous contour, to specify the start of a new contour
 * @param dy The amount to add to the y-coordinate of the end of the
 * previous contour, to specify the start of a new contour
 */

Body of Frist Method:
{
    native_rMoveTo(mNativePath, dx, dy);
}
Body of Second Method:
{
    nRMoveTo(mNativePath, dx, dy);
}
------------------------
Find a silently evolved API code:android.bluetooth.le.ScanRecord.parseFromBytes:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Parse scan record bytes to {@link ScanRecord}.
 * <p>
 * The format is defined in Bluetooth 4.1 specification, Volume 3, Part C, Section 11 and 18.
 * <p>
 * All numerical multi-byte entities and values shall use little-endian <strong>byte</strong>
 * order.
 *
 * @param scanRecord The scan record of Bluetooth LE advertisement and/or scan response.
 * @hide
 */

Body of Frist Method:
{
    if (scanRecord == null) {
        return null;
    }
    int currentPos = 0;
    int advertiseFlag = -1;
    List<ParcelUuid> serviceUuids = new ArrayList<ParcelUuid>();
    String localName = null;
    int txPowerLevel = Integer.MIN_VALUE;
    SparseArray<byte[]> manufacturerData = new SparseArray<byte[]>();
    Map<ParcelUuid, byte[]> serviceData = new ArrayMap<ParcelUuid, byte[]>();
    try {
        while (currentPos < scanRecord.length) {
            // length is unsigned int.
            int length = scanRecord[currentPos++] & 0xFF;
            if (length == 0) {
                break;
            }
            // Note the length includes the length of the field type itself.
            int dataLength = length - 1;
            // fieldType is unsigned int.
            int fieldType = scanRecord[currentPos++] & 0xFF;
            switch(fieldType) {
                case DATA_TYPE_FLAGS:
                    advertiseFlag = scanRecord[currentPos] & 0xFF;
                    break;
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_16_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_32_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_128_BIT, serviceUuids);
                    break;
                case DATA_TYPE_LOCAL_NAME_SHORT:
                case DATA_TYPE_LOCAL_NAME_COMPLETE:
                    localName = new String(extractBytes(scanRecord, currentPos, dataLength));
                    break;
                case DATA_TYPE_TX_POWER_LEVEL:
                    txPowerLevel = scanRecord[currentPos];
                    break;
                case DATA_TYPE_SERVICE_DATA:
                    // The first two bytes of the service data are service data UUID in little
                    // endian. The rest bytes are service data.
                    int serviceUuidLength = BluetoothUuid.UUID_BYTES_16_BIT;
                    byte[] serviceDataUuidBytes = extractBytes(scanRecord, currentPos, serviceUuidLength);
                    ParcelUuid serviceDataUuid = BluetoothUuid.parseUuidFrom(serviceDataUuidBytes);
                    byte[] serviceDataArray = extractBytes(scanRecord, currentPos + serviceUuidLength, dataLength - serviceUuidLength);
                    serviceData.put(serviceDataUuid, serviceDataArray);
                    break;
                case DATA_TYPE_MANUFACTURER_SPECIFIC_DATA:
                    // The first two bytes of the manufacturer specific data are
                    // manufacturer ids in little endian.
                    int manufacturerId = ((scanRecord[currentPos + 1] & 0xFF) << 8) + (scanRecord[currentPos] & 0xFF);
                    byte[] manufacturerDataBytes = extractBytes(scanRecord, currentPos + 2, dataLength - 2);
                    manufacturerData.put(manufacturerId, manufacturerDataBytes);
                    break;
                default:
                    // Just ignore, we don't handle such data type.
                    break;
            }
            currentPos += dataLength;
        }
        if (serviceUuids.isEmpty()) {
            serviceUuids = null;
        }
        return new ScanRecord(serviceUuids, manufacturerData, serviceData, advertiseFlag, txPowerLevel, localName, scanRecord);
    } catch (Exception e) {
        Log.e(TAG, "unable to parse scan record: " + Arrays.toString(scanRecord));
        // and return an empty record with raw scanRecord bytes in results
        return new ScanRecord(null, null, null, -1, Integer.MIN_VALUE, null, scanRecord);
    }
}
Body of Second Method:
{
    if (scanRecord == null) {
        return null;
    }
    int currentPos = 0;
    int advertiseFlag = -1;
    List<ParcelUuid> serviceUuids = new ArrayList<ParcelUuid>();
    String localName = null;
    int txPowerLevel = Integer.MIN_VALUE;
    SparseArray<byte[]> manufacturerData = new SparseArray<byte[]>();
    Map<ParcelUuid, byte[]> serviceData = new ArrayMap<ParcelUuid, byte[]>();
    try {
        while (currentPos < scanRecord.length) {
            // length is unsigned int.
            int length = scanRecord[currentPos++] & 0xFF;
            if (length == 0) {
                break;
            }
            // Note the length includes the length of the field type itself.
            int dataLength = length - 1;
            // fieldType is unsigned int.
            int fieldType = scanRecord[currentPos++] & 0xFF;
            switch(fieldType) {
                case DATA_TYPE_FLAGS:
                    advertiseFlag = scanRecord[currentPos] & 0xFF;
                    break;
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_16_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_32_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_128_BIT, serviceUuids);
                    break;
                case DATA_TYPE_LOCAL_NAME_SHORT:
                case DATA_TYPE_LOCAL_NAME_COMPLETE:
                    localName = new String(extractBytes(scanRecord, currentPos, dataLength));
                    break;
                case DATA_TYPE_TX_POWER_LEVEL:
                    txPowerLevel = scanRecord[currentPos];
                    break;
                case DATA_TYPE_SERVICE_DATA_16_BIT:
                case DATA_TYPE_SERVICE_DATA_32_BIT:
                case DATA_TYPE_SERVICE_DATA_128_BIT:
                    int serviceUuidLength = BluetoothUuid.UUID_BYTES_16_BIT;
                    if (fieldType == DATA_TYPE_SERVICE_DATA_32_BIT) {
                        serviceUuidLength = BluetoothUuid.UUID_BYTES_32_BIT;
                    } else if (fieldType == DATA_TYPE_SERVICE_DATA_128_BIT) {
                        serviceUuidLength = BluetoothUuid.UUID_BYTES_128_BIT;
                    }
                    byte[] serviceDataUuidBytes = extractBytes(scanRecord, currentPos, serviceUuidLength);
                    ParcelUuid serviceDataUuid = BluetoothUuid.parseUuidFrom(serviceDataUuidBytes);
                    byte[] serviceDataArray = extractBytes(scanRecord, currentPos + serviceUuidLength, dataLength - serviceUuidLength);
                    serviceData.put(serviceDataUuid, serviceDataArray);
                    break;
                case DATA_TYPE_MANUFACTURER_SPECIFIC_DATA:
                    // The first two bytes of the manufacturer specific data are
                    // manufacturer ids in little endian.
                    int manufacturerId = ((scanRecord[currentPos + 1] & 0xFF) << 8) + (scanRecord[currentPos] & 0xFF);
                    byte[] manufacturerDataBytes = extractBytes(scanRecord, currentPos + 2, dataLength - 2);
                    manufacturerData.put(manufacturerId, manufacturerDataBytes);
                    break;
                default:
                    // Just ignore, we don't handle such data type.
                    break;
            }
            currentPos += dataLength;
        }
        if (serviceUuids.isEmpty()) {
            serviceUuids = null;
        }
        return new ScanRecord(serviceUuids, manufacturerData, serviceData, advertiseFlag, txPowerLevel, localName, scanRecord);
    } catch (Exception e) {
        Log.e(TAG, "unable to parse scan record: " + Arrays.toString(scanRecord));
        // and return an empty record with raw scanRecord bytes in results
        return new ScanRecord(null, null, null, -1, Integer.MIN_VALUE, null, scanRecord);
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.obtain:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a cached instance if such is available or a new one is
 * created.
 *
 * @return An instance.
 */

Body of Frist Method:
{
    AccessibilityWindowInfo info = sPool.acquire();
    if (info == null) {
        info = new AccessibilityWindowInfo();
    }
    return info;
}
Body of Second Method:
{
    AccessibilityWindowInfo info = sPool.acquire();
    if (info == null) {
        info = new AccessibilityWindowInfo();
    }
    if (sNumInstancesInUse != null) {
        sNumInstancesInUse.incrementAndGet();
    }
    return info;
}
------------------------
Find a silently evolved API code:android.content.pm.PackageUserState.isMatch:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Test if the given component is considered installed, enabled and a match
 * for the given flags.
 *
 * <p>
 * Expects at least one of {@link PackageManager#MATCH_DIRECT_BOOT_AWARE} and
 * {@link PackageManager#MATCH_DIRECT_BOOT_UNAWARE} are specified in {@code flags}.
 * </p>
 */

Body of Frist Method:
{
    if (!isInstalled(flags))
        return false;
    if (!isEnabled(componentInfo, flags))
        return false;
    if ((flags & MATCH_SYSTEM_ONLY) != 0) {
        if (!componentInfo.applicationInfo.isSystemApp()) {
            return false;
        }
    }
    final boolean matchesUnaware = ((flags & MATCH_DIRECT_BOOT_UNAWARE) != 0) && !componentInfo.directBootAware;
    final boolean matchesAware = ((flags & MATCH_DIRECT_BOOT_AWARE) != 0) && componentInfo.directBootAware;
    return matchesUnaware || matchesAware;
}
Body of Second Method:
{
    final boolean isSystemApp = componentInfo.applicationInfo.isSystemApp();
    final boolean matchUninstalled = (flags & PackageManager.MATCH_KNOWN_PACKAGES) != 0;
    if (!isAvailable(flags) && !(isSystemApp && matchUninstalled))
        return false;
    if (!isEnabled(componentInfo, flags))
        return false;
    if ((flags & MATCH_SYSTEM_ONLY) != 0) {
        if (!isSystemApp) {
            return false;
        }
    }
    final boolean matchesUnaware = ((flags & MATCH_DIRECT_BOOT_UNAWARE) != 0) && !componentInfo.directBootAware;
    final boolean matchesAware = ((flags & MATCH_DIRECT_BOOT_AWARE) != 0) && componentInfo.directBootAware;
    return matchesUnaware || matchesAware;
}
------------------------
Find a silently evolved API code:android.media.MediaScannerConnection.disconnect:COMMENT
Method Modifier: public      
Comment:/**
 * Releases the connection to the media scanner service.
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mConnected) {
            if (false) {
                Log.v(TAG, "Disconnecting from Media Scanner");
            }
            try {
                mContext.unbindService(this);
            } catch (IllegalArgumentException ex) {
                if (false) {
                    Log.v(TAG, "disconnect failed: " + ex);
                }
            }
            mConnected = false;
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mConnected) {
            if (false) {
                Log.v(TAG, "Disconnecting from Media Scanner");
            }
            try {
                mContext.unbindService(this);
                if (mClient instanceof ClientProxy) {
                    mClient = null;
                }
                mService = null;
            } catch (IllegalArgumentException ex) {
                if (false) {
                    Log.v(TAG, "disconnect failed: " + ex);
                }
            }
            mConnected = false;
        }
    }
}
------------------------
Find a silently evolved API code:android.app.usage.UsageEvents.readEventFromParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Reads a single event from the parcel. Modify this when updating {@link Event}.
 */

Body of Frist Method:
{
    final int packageIndex = p.readInt();
    if (packageIndex >= 0) {
        eventOut.mPackage = mStringPool[packageIndex];
    } else {
        eventOut.mPackage = null;
    }
    final int classIndex = p.readInt();
    if (classIndex >= 0) {
        eventOut.mClass = mStringPool[classIndex];
    } else {
        eventOut.mClass = null;
    }
    eventOut.mEventType = p.readInt();
    eventOut.mTimeStamp = p.readLong();
    // Fill out the event-dependant fields.
    eventOut.mConfiguration = null;
    eventOut.mShortcutId = null;
    switch(eventOut.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            // Extract the configuration for configuration change events.
            eventOut.mConfiguration = Configuration.CREATOR.createFromParcel(p);
            break;
        case Event.SHORTCUT_INVOCATION:
            eventOut.mShortcutId = p.readString();
            break;
    }
}
Body of Second Method:
{
    final int packageIndex = p.readInt();
    if (packageIndex >= 0) {
        eventOut.mPackage = mStringPool[packageIndex];
    } else {
        eventOut.mPackage = null;
    }
    final int classIndex = p.readInt();
    if (classIndex >= 0) {
        eventOut.mClass = mStringPool[classIndex];
    } else {
        eventOut.mClass = null;
    }
    eventOut.mEventType = p.readInt();
    eventOut.mTimeStamp = p.readLong();
    // Fill out the event-dependant fields.
    eventOut.mConfiguration = null;
    eventOut.mShortcutId = null;
    eventOut.mAction = null;
    eventOut.mContentType = null;
    eventOut.mContentAnnotations = null;
    switch(eventOut.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            // Extract the configuration for configuration change events.
            eventOut.mConfiguration = Configuration.CREATOR.createFromParcel(p);
            break;
        case Event.SHORTCUT_INVOCATION:
            eventOut.mShortcutId = p.readString();
            break;
        case Event.CHOOSER_ACTION:
            eventOut.mAction = p.readString();
            eventOut.mContentType = p.readString();
            eventOut.mContentAnnotations = p.createStringArray();
            break;
    }
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.setActive:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Sets a call's state to active (e.g., an ongoing call where two parties can actively
 * communicate).
 *
 * @param callId The unique ID of the call whose state is changing to active.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setActive(callId);
        } catch (RemoteException e) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setActive(callId, Log.getExternalSession());
        } catch (RemoteException e) {
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.onInitializeAccessibilityEventInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onInitializeAccessibilityEventInternal(event);
    event.setItemCount(mMax);
    event.setCurrentItemIndex(mProgress);
}
Body of Second Method:
{
    super.onInitializeAccessibilityEventInternal(event);
    event.setItemCount(mMax - mMin);
    event.setCurrentItemIndex(mProgress);
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.setDividerDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set a drawable to be used as a divider between items.
 *
 * @param divider Drawable that will divide each item.
 *
 * @see #setShowDividers(int)
 *
 * @attr ref android.R.styleable#LinearLayout_divider
 */

Body of Frist Method:
{
    if (divider == mDivider) {
        return;
    }
    mDivider = divider;
    if (divider != null) {
        mDividerWidth = divider.getIntrinsicWidth();
        mDividerHeight = divider.getIntrinsicHeight();
    } else {
        mDividerWidth = 0;
        mDividerHeight = 0;
    }
    setWillNotDraw(divider == null);
    requestLayout();
}
Body of Second Method:
{
    if (divider == mDivider) {
        return;
    }
    mDivider = divider;
    if (divider != null) {
        mDividerWidth = divider.getIntrinsicWidth();
        mDividerHeight = divider.getIntrinsicHeight();
    } else {
        mDividerWidth = 0;
        mDividerHeight = 0;
    }
    setWillNotDraw(!isShowingDividers());
    requestLayout();
}
------------------------
Find a silently evolved API code:android.media.AudioManager.forceVolumeControlStream:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * forces the stream controlled by hard volume keys
 * specifying streamType == -1 releases control to the
 * logic.
 *
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.forceVolumeControlStream(streamType, mICallBack);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.forceVolumeControlStream(streamType, mICallBack);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.transition.TransitionManager.changeScene:COMMENT
Method Modifier: private     static      
Comment:/**
 * This is where all of the work of a transition/scene-change is
 * orchestrated. This method captures the start values for the given
 * transition, exits the current Scene, enters the new scene, captures
 * the end values for the transition, and finally plays the
 * resulting values-populated transition.
 *
 * @param scene The scene being entered
 * @param transition The transition to play for this scene change
 */

Body of Frist Method:
{
    final ViewGroup sceneRoot = scene.getSceneRoot();
    if (!sPendingTransitions.contains(sceneRoot)) {
        sPendingTransitions.add(sceneRoot);
        Transition transitionClone = null;
        if (transition != null) {
            transitionClone = transition.clone();
            transitionClone.setSceneRoot(sceneRoot);
        }
        Scene oldScene = Scene.getCurrentScene(sceneRoot);
        if (oldScene != null && transitionClone != null && oldScene.isCreatedFromLayoutResource()) {
            transitionClone.setCanRemoveViews(true);
        }
        sceneChangeSetup(sceneRoot, transitionClone);
        scene.enter();
        sceneChangeRunTransition(sceneRoot, transitionClone);
    }
}
Body of Second Method:
{
    final ViewGroup sceneRoot = scene.getSceneRoot();
    if (!sPendingTransitions.contains(sceneRoot)) {
        if (transition == null) {
            scene.enter();
        } else {
            sPendingTransitions.add(sceneRoot);
            Transition transitionClone = transition.clone();
            transitionClone.setSceneRoot(sceneRoot);
            Scene oldScene = Scene.getCurrentScene(sceneRoot);
            if (oldScene != null && oldScene.isCreatedFromLayoutResource()) {
                transitionClone.setCanRemoveViews(true);
            }
            sceneChangeSetup(sceneRoot, transitionClone);
            scene.enter();
            sceneChangeRunTransition(sceneRoot, transitionClone);
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.setFromNotifierBundle:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Set ServiceState based on intent notifier map.
 *
 * @param m intent notifier map
 * @hide
 */

Body of Frist Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mVoiceRoamingType = m.getInt("voiceRoamingType");
    mDataRoamingType = m.getInt("dataRoamingType");
    mVoiceOperatorAlphaLong = m.getString("operator-alpha-long");
    mVoiceOperatorAlphaShort = m.getString("operator-alpha-short");
    mVoiceOperatorNumeric = m.getString("operator-numeric");
    mDataOperatorAlphaLong = m.getString("data-operator-alpha-long");
    mDataOperatorAlphaShort = m.getString("data-operator-alpha-short");
    mDataOperatorNumeric = m.getString("data-operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilDataRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
    mIsDataRoamingFromRegistration = m.getBoolean("isDataRoamingFromRegistration");
    mIsUsingCarrierAggregation = m.getBoolean("isUsingCarrierAggregation");
}
Body of Second Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mVoiceRoamingType = m.getInt("voiceRoamingType");
    mDataRoamingType = m.getInt("dataRoamingType");
    mVoiceOperatorAlphaLong = m.getString("operator-alpha-long");
    mVoiceOperatorAlphaShort = m.getString("operator-alpha-short");
    mVoiceOperatorNumeric = m.getString("operator-numeric");
    mDataOperatorAlphaLong = m.getString("data-operator-alpha-long");
    mDataOperatorAlphaShort = m.getString("data-operator-alpha-short");
    mDataOperatorNumeric = m.getString("data-operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilDataRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
    mIsDataRoamingFromRegistration = m.getBoolean("isDataRoamingFromRegistration");
    mIsUsingCarrierAggregation = m.getBoolean("isUsingCarrierAggregation");
    mLteEarfcnRsrpBoost = m.getInt("LteEarfcnRsrpBoost");
}
------------------------
Find a silently evolved API code:android.graphics.Path.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Clear any lines and curves from the path, making it empty.
 * This does NOT change the fill-type setting.
 */

Body of Frist Method:
{
    isSimplePath = true;
    mLastDirection = null;
    if (rects != null)
        rects.setEmpty();
    // We promised not to change this, so preserve it around the native
    // call, which does now reset fill type.
    final FillType fillType = getFillType();
    native_reset(mNativePath);
    setFillType(fillType);
}
Body of Second Method:
{
    isSimplePath = true;
    mLastDirection = null;
    if (rects != null)
        rects.setEmpty();
    // We promised not to change this, so preserve it around the native
    // call, which does now reset fill type.
    final FillType fillType = getFillType();
    nReset(mNativePath);
    setFillType(fillType);
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pManager.setWFDInfo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    checkChannel(c);
    c.mAsyncChannel.sendMessage(SET_WFD_INFO, 0, c.putListener(listener), wfdInfo);
}
Body of Second Method:
{
    checkChannel(c);
    try {
        mService.checkConfigureWifiDisplayPermission();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    c.mAsyncChannel.sendMessage(SET_WFD_INFO, 0, c.putListener(listener), wfdInfo);
}
------------------------
Find a silently evolved API code:android.net.SntpClient.requestTime:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends an SNTP request to the given host and processes the response.
 *
 * @param host host name of the server.
 * @param timeout network timeout in milliseconds.
 * @return true if the transaction was successful.
 */

Body of Frist Method:
{
    InetAddress address = null;
    try {
        address = InetAddress.getByName(host);
    } catch (Exception e) {
        if (DBG)
            Log.d(TAG, "request time failed: " + e);
        return false;
    }
    return requestTime(address, NTP_PORT, timeout);
}
Body of Second Method:
{
    InetAddress address = null;
    try {
        address = InetAddress.getByName(host);
    } catch (Exception e) {
        EventLogTags.writeNtpFailure(host, e.toString());
        if (DBG)
            Log.d(TAG, "request time failed: " + e);
        return false;
    }
    return requestTime(address, NTP_PORT, timeout);
}
------------------------
Find a silently evolved API code:android.graphics.Path.setFillType:COMMENT
Method Modifier: public      
Comment:/**
 * Set the path's fill type. This defines how "inside" is computed.
 *
 * @param ft The new fill type for this path
 */

Body of Frist Method:
{
    native_setFillType(mNativePath, ft.nativeInt);
}
Body of Second Method:
{
    nSetFillType(mNativePath, ft.nativeInt);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getClientCertificate:COMMENT
Method Modifier: public      
Comment:/**
 * Get client certificate
 *
 * @return X.509 client certificate
 */

Body of Frist Method:
{
    return mClientCertificate;
}
Body of Second Method:
{
    if (mClientCertificateChain != null && mClientCertificateChain.length > 0) {
        return mClientCertificateChain[0];
    } else {
        return null;
    }
}
------------------------
Find a silently evolved API code:android.renderscript.ScriptIntrinsicConvolve3x3.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Supported elements types are {@link Element#U8}, {@link
 * Element#U8_2}, {@link Element#U8_3}, {@link Element#U8_4},
 * {@link Element#F32}, {@link Element#F32_2}, {@link
 * Element#F32_3}, and {@link Element#F32_4}.
 *
 * <p> The default coefficients are:
 * <code>
 * <p> [ 0,  0,  0 ]
 * <p> [ 0,  1,  0 ]
 * <p> [ 0,  0,  0 ]
 * </code>
 *
 * @param rs The RenderScript context
 * @param e Element type for intputs and outputs
 *
 * @return ScriptIntrinsicConvolve3x3
 */

Body of Frist Method:
{
    float[] f = { 0, 0, 0, 0, 1, 0, 0, 0, 0 };
    if (!e.isCompatible(Element.U8(rs)) && !e.isCompatible(Element.U8_2(rs)) && !e.isCompatible(Element.U8_3(rs)) && !e.isCompatible(Element.U8_4(rs)) && !e.isCompatible(Element.F32(rs)) && !e.isCompatible(Element.F32_2(rs)) && !e.isCompatible(Element.F32_3(rs)) && !e.isCompatible(Element.F32_4(rs))) {
        throw new RSIllegalArgumentException("Unsuported element type.");
    }
    long id = rs.nScriptIntrinsicCreate(1, e.getID(rs));
    ScriptIntrinsicConvolve3x3 si = new ScriptIntrinsicConvolve3x3(id, rs);
    si.setCoefficients(f);
    return si;
}
Body of Second Method:
{
    float[] f = { 0, 0, 0, 0, 1, 0, 0, 0, 0 };
    if (!e.isCompatible(Element.U8(rs)) && !e.isCompatible(Element.U8_2(rs)) && !e.isCompatible(Element.U8_3(rs)) && !e.isCompatible(Element.U8_4(rs)) && !e.isCompatible(Element.F32(rs)) && !e.isCompatible(Element.F32_2(rs)) && !e.isCompatible(Element.F32_3(rs)) && !e.isCompatible(Element.F32_4(rs))) {
        throw new RSIllegalArgumentException("Unsupported element type.");
    }
    long id = rs.nScriptIntrinsicCreate(1, e.getID(rs));
    ScriptIntrinsicConvolve3x3 si = new ScriptIntrinsicConvolve3x3(id, rs);
    si.setCoefficients(f);
    return si;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.TaskDrainer.taskStarted:COMMENT
Method Modifier: public      
Comment:/**
 * Mark an asynchronous task as having started.
 *
 * <p>A task cannot be started more than once without first having finished. Once
 * draining begins with {@link #beginDrain}, no new tasks can be started.</p>
 *
 * @param task a key to identify a task
 *
 * @see #taskFinished
 * @see #beginDrain
 *
 * @throws IllegalStateException
 * If attempting to start a task which is already started (and not finished),
 * or if attempting to start a task after draining has begun.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (DEBUG) {
            Log.v(TAG + "[" + mName + "]", "taskStarted " + task);
        }
        if (mDraining) {
            throw new IllegalStateException("Can't start more tasks after draining has begun");
        }
        if (!mTaskSet.add(task)) {
            throw new IllegalStateException("Task " + task + " was already started");
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (DEBUG) {
            Log.v(TAG + "[" + mName + "]", "taskStarted " + task);
        }
        if (mDraining) {
            throw new IllegalStateException("Can't start more tasks after draining has begun");
        }
        // Try to remove the task from the early finished set.
        if (!mEarlyFinishedTaskSet.remove(task)) {
            // The task is not finished early. Add it to the started set.
            if (!mTaskSet.add(task)) {
                throw new IllegalStateException("Task " + task + " was already started");
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.preference.PreferenceActivity.startPreferencePanel:COMMENT
Method Modifier: public      
Comment:/**
 * Start a new fragment containing a preference panel.  If the preferences
 * are being displayed in multi-pane mode, the given fragment class will
 * be instantiated and placed in the appropriate pane.  If running in
 * single-pane mode, a new activity will be launched in which to show the
 * fragment.
 *
 * @param fragmentClass Full name of the class implementing the fragment.
 * @param args Any desired arguments to supply to the fragment.
 * @param titleRes Optional resource identifier of the title of this
 * fragment.
 * @param titleText Optional text of the title of this fragment.
 * @param resultTo Optional fragment that result data should be sent to.
 * If non-null, resultTo.onActivityResult() will be called when this
 * preference panel is done.  The launched panel must use
 * {@link #finishPreferencePanel(Fragment, int, Intent)} when done.
 * @param resultRequestCode If resultTo is non-null, this is the caller's
 * request code to be received with the result.
 */

Body of Frist Method:
{
    if (mSinglePane) {
        startWithFragment(fragmentClass, args, resultTo, resultRequestCode, titleRes, 0);
    } else {
        Fragment f = Fragment.instantiate(this, fragmentClass, args);
        if (resultTo != null) {
            f.setTargetFragment(resultTo, resultRequestCode);
        }
        FragmentTransaction transaction = getFragmentManager().beginTransaction();
        transaction.replace(com.android.internal.R.id.prefs, f);
        if (titleRes != 0) {
            transaction.setBreadCrumbTitle(titleRes);
        } else if (titleText != null) {
            transaction.setBreadCrumbTitle(titleText);
        }
        transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
        transaction.addToBackStack(BACK_STACK_PREFS);
        transaction.commitAllowingStateLoss();
    }
}
Body of Second Method:
{
    Fragment f = Fragment.instantiate(this, fragmentClass, args);
    if (resultTo != null) {
        f.setTargetFragment(resultTo, resultRequestCode);
    }
    FragmentTransaction transaction = getFragmentManager().beginTransaction();
    transaction.replace(com.android.internal.R.id.prefs, f);
    if (titleRes != 0) {
        transaction.setBreadCrumbTitle(titleRes);
    } else if (titleText != null) {
        transaction.setBreadCrumbTitle(titleText);
    }
    transaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
    transaction.addToBackStack(BACK_STACK_PREFS);
    transaction.commitAllowingStateLoss();
}
------------------------
Find a silently evolved API code:android.text.TextLine.set:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Initializes a TextLine and prepares it for use.
 *
 * @param paint the base paint for the line
 * @param text the text, can be Styled
 * @param start the start of the line relative to the text
 * @param limit the limit of the line relative to the text
 * @param dir the paragraph direction of this line
 * @param directions the directions information of this line
 * @param hasTabs true if the line might contain tabs
 * @param tabStops the tabStops. Can be null.
 */

Body of Frist Method:
{
    mPaint = paint;
    mText = text;
    mStart = start;
    mLen = limit - start;
    mDir = dir;
    mDirections = directions;
    if (mDirections == null) {
        throw new IllegalArgumentException("Directions cannot be null");
    }
    mHasTabs = hasTabs;
    mSpanned = null;
    boolean hasReplacement = false;
    if (text instanceof Spanned) {
        mSpanned = (Spanned) text;
        mReplacementSpanSpanSet.init(mSpanned, start, limit);
        hasReplacement = mReplacementSpanSpanSet.numberOfSpans > 0;
    }
    mCharsValid = hasReplacement || hasTabs || directions != Layout.DIRS_ALL_LEFT_TO_RIGHT;
    if (mCharsValid) {
        if (mChars == null || mChars.length < mLen) {
            mChars = ArrayUtils.newUnpaddedCharArray(mLen);
        }
        TextUtils.getChars(text, start, limit, mChars, 0);
        if (hasReplacement) {
            // Handle these all at once so we don't have to do it as we go.
            // Replace the first character of each replacement run with the
            // object-replacement character and the remainder with zero width
            // non-break space aka BOM.  Cursor movement code skips these
            // zero-width characters.
            char[] chars = mChars;
            for (int i = start, inext; i < limit; i = inext) {
                inext = mReplacementSpanSpanSet.getNextTransition(i, limit);
                if (mReplacementSpanSpanSet.hasSpansIntersecting(i, inext)) {
                    // transition into a span
                    chars[i - start] = '\ufffc';
                    for (int j = i - start + 1, e = inext - start; j < e; ++j) {
                        // used as ZWNBS, marks positions to skip
                        chars[j] = '\ufeff';
                    }
                }
            }
        }
    }
    mTabs = tabStops;
}
Body of Second Method:
{
    mPaint = paint;
    mText = text;
    mStart = start;
    mLen = limit - start;
    mDir = dir;
    mDirections = directions;
    if (mDirections == null) {
        throw new IllegalArgumentException("Directions cannot be null");
    }
    mHasTabs = hasTabs;
    mSpanned = null;
    boolean hasReplacement = false;
    if (text instanceof Spanned) {
        mSpanned = (Spanned) text;
        mReplacementSpanSpanSet.init(mSpanned, start, limit);
        hasReplacement = mReplacementSpanSpanSet.numberOfSpans > 0;
    }
    mCharsValid = hasReplacement || hasTabs || directions != Layout.DIRS_ALL_LEFT_TO_RIGHT;
    if (mCharsValid) {
        if (mChars == null || mChars.length < mLen) {
            mChars = ArrayUtils.newUnpaddedCharArray(mLen);
        }
        TextUtils.getChars(text, start, limit, mChars, 0);
        if (hasReplacement) {
            // Handle these all at once so we don't have to do it as we go.
            // Replace the first character of each replacement run with the
            // object-replacement character and the remainder with zero width
            // non-break space aka BOM.  Cursor movement code skips these
            // zero-width characters.
            char[] chars = mChars;
            for (int i = start, inext; i < limit; i = inext) {
                inext = mReplacementSpanSpanSet.getNextTransition(i, limit);
                if (mReplacementSpanSpanSet.hasSpansIntersecting(i, inext)) {
                    // transition into a span
                    chars[i - start] = '\ufffc';
                    for (int j = i - start + 1, e = inext - start; j < e; ++j) {
                        // used as ZWNBS, marks positions to skip
                        chars[j] = '\ufeff';
                    }
                }
            }
        }
    }
    mTabs = tabStops;
    mAddedWidth = 0;
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.toString:COMMENT
Method Modifier: public      
Comment:/**
 * @return string representation.
 */

Body of Frist Method:
{
    return ("SignalStrength:" + " " + mGsmSignalStrength + " " + mGsmBitErrorRate + " " + mCdmaDbm + " " + mCdmaEcio + " " + mEvdoDbm + " " + mEvdoEcio + " " + mEvdoSnr + " " + mLteSignalStrength + " " + mLteRsrp + " " + mLteRsrq + " " + mLteRssnr + " " + mLteCqi + " " + mTdScdmaRscp + " " + (isGsm ? "gsm|lte" : "cdma"));
}
Body of Second Method:
{
    return ("SignalStrength:" + " " + mGsmSignalStrength + " " + mGsmBitErrorRate + " " + mCdmaDbm + " " + mCdmaEcio + " " + mEvdoDbm + " " + mEvdoEcio + " " + mEvdoSnr + " " + mLteSignalStrength + " " + mLteRsrp + " " + mLteRsrq + " " + mLteRssnr + " " + mLteCqi + " " + mLteRsrpBoost + " " + mTdScdmaRscp + " " + (isGsm ? "gsm|lte" : "cdma"));
}
------------------------
Find a silently evolved API code:android.net.Network.openConnection:COMMENT
Method Modifier: public      
Comment:/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @param proxy the proxy through which the connection will be established.
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IllegalArgumentException if the argument proxy is null.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */

Body of Frist Method:
{
    if (proxy == null)
        throw new IllegalArgumentException("proxy is null");
    maybeInitHttpClient();
    String protocol = url.getProtocol();
    OkUrlFactory okUrlFactory;
    // Could this cause unexpected behavior?
    if (protocol.equals("http")) {
        okUrlFactory = HttpHandler.createHttpOkUrlFactory(proxy);
    } else if (protocol.equals("https")) {
        okUrlFactory = HttpsHandler.createHttpsOkUrlFactory(proxy);
    } else {
        // passed another protocol.
        throw new MalformedURLException("Invalid URL or unrecognized protocol " + protocol);
    }
    OkHttpClient client = okUrlFactory.client();
    client.setSocketFactory(getSocketFactory()).setConnectionPool(mConnectionPool);
    // Use internal APIs to change the Network.
    Internal.instance.setNetwork(client, mNetwork);
    return okUrlFactory.open(url);
}
Body of Second Method:
{
    if (proxy == null)
        throw new IllegalArgumentException("proxy is null");
    maybeInitHttpClient();
    String protocol = url.getProtocol();
    OkUrlFactory okUrlFactory;
    // Could this cause unexpected behavior?
    if (protocol.equals("http")) {
        okUrlFactory = HttpHandler.createHttpOkUrlFactory(proxy);
    } else if (protocol.equals("https")) {
        okUrlFactory = HttpsHandler.createHttpsOkUrlFactory(proxy);
    } else {
        // passed another protocol.
        throw new MalformedURLException("Invalid URL or unrecognized protocol " + protocol);
    }
    OkHttpClient client = okUrlFactory.client();
    client.setSocketFactory(getSocketFactory()).setConnectionPool(mConnectionPool);
    // Let network traffic go via mDns
    client.setDns(mDns);
    return okUrlFactory.open(url);
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.queryBroadcastReceivers:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    Log.w(TAG, "STAHP USING HIDDEN APIS KTHX");
    return queryBroadcastReceiversAsUser(intent, flags, userId);
}
Body of Second Method:
{
    final String msg = "Shame on you for calling the hidden API " + "queryBroadcastReceivers(). Shame!";
    if (VMRuntime.getRuntime().getTargetSdkVersion() >= Build.VERSION_CODES.O) {
        throw new UnsupportedOperationException(msg);
    } else {
        Log.d(TAG, msg);
        return queryBroadcastReceiversAsUser(intent, flags, userId);
    }
}
------------------------
Find a silently evolved API code:javax.obex.ClientOperation.startProcessing:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * This method starts the processing thread results. It will send the
 * initial request. If the response takes more then one packet, a thread
 * will be started to handle additional requests
 * @throws IOException if an IO error occurs
 */

Body of Frist Method:
{
    if (mPrivateInput == null) {
        mPrivateInput = new PrivateInputStream(this);
    }
    boolean more = true;
    if (mGetOperation) {
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(ObexHelper.OBEX_OPCODE_GET);
            }
            // reply.
            if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                mParent.sendRequest(ObexHelper.OBEX_OPCODE_GET_FINAL, null, mReplyHeader, mPrivateInput, mSrmActive);
            }
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            } else {
                checkForSrm();
            }
        }
    } else {
        // PUT operation
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(ObexHelper.OBEX_OPCODE_PUT);
            }
        }
        if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
            mParent.sendRequest(ObexHelper.OBEX_OPCODE_PUT_FINAL, null, mReplyHeader, mPrivateInput, mSrmActive);
        }
        if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
            mOperationDone = true;
        }
    }
}
Body of Second Method:
{
    if (mPrivateInput == null) {
        mPrivateInput = new PrivateInputStream(this);
    }
    boolean more = true;
    if (mGetOperation) {
        if (!mOperationDone) {
            if (!mGetFinalFlag) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
                while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                    more = sendRequest(ObexHelper.OBEX_OPCODE_GET);
                }
                // reply.
                if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                    mParent.sendRequest(ObexHelper.OBEX_OPCODE_GET_FINAL, null, mReplyHeader, mPrivateInput, mSrmActive);
                }
                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                    mOperationDone = true;
                } else {
                    checkForSrm();
                }
            } else {
                more = sendRequest(ObexHelper.OBEX_OPCODE_GET_FINAL);
                if (more) {
                    throw new IOException("FINAL_GET forced, data didn't fit into one packet");
                }
                mOperationDone = true;
            }
        }
    } else {
        // PUT operation
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(ObexHelper.OBEX_OPCODE_PUT);
            }
        }
        if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
            mParent.sendRequest(ObexHelper.OBEX_OPCODE_PUT_FINAL, null, mReplyHeader, mPrivateInput, mSrmActive);
        }
        if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
            mOperationDone = true;
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path.setLastPoint:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the last point of the path.
 *
 * @param dx The new X coordinate for the last point
 * @param dy The new Y coordinate for the last point
 */

Body of Frist Method:
{
    isSimplePath = false;
    native_setLastPoint(mNativePath, dx, dy);
}
Body of Second Method:
{
    isSimplePath = false;
    nSetLastPoint(mNativePath, dx, dy);
}
------------------------
Find a silently evolved API code:android.content.ClipboardManager.getPrimaryClip:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current primary clip on the clipboard.
 */

Body of Frist Method:
{
    try {
        return getService().getPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return mService.getPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.getCurrentSpellCheckerSubtype:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        if (sService == null) {
            // TODO: This is a workaround. Needs to investigate why sService could be null
            // here.
            Log.e(TAG, "sService is null.");
            return null;
        }
        // Passing null as a locale until we support multiple enabled spell checker subtypes.
        return sService.getCurrentSpellCheckerSubtype(null, allowImplicitlySelectedSubtype);
    } catch (RemoteException e) {
        Log.e(TAG, "Error in getCurrentSpellCheckerSubtype: " + e);
        return null;
    }
}
Body of Second Method:
{
    try {
        // Passing null as a locale until we support multiple enabled spell checker subtypes.
        return mService.getCurrentSpellCheckerSubtype(null, allowImplicitlySelectedSubtype);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.IntentSender.getCreatorPackage:COMMENT
Method Modifier: public      
Comment:/**
 * Return the package name of the application that created this
 * IntentSender, that is the identity under which you will actually be
 * sending the Intent.  The returned string is supplied by the system, so
 * that an application can not spoof its package.
 *
 * @return The package name of the PendingIntent, or null if there is
 * none associated with it.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}
Body of Second Method:
{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.describeContents:COMMENT
Method Modifier: public      
Comment:/**
 * Parcelable interface
 */

Body of Frist Method:
{
    return (mType == TYPE_BITMAP || mType == TYPE_DATA) ? Parcelable.CONTENTS_FILE_DESCRIPTOR : 0;
}
Body of Second Method:
{
    return (mType == TYPE_BITMAP || mType == TYPE_ADAPTIVE_BITMAP || mType == TYPE_DATA) ? Parcelable.CONTENTS_FILE_DESCRIPTOR : 0;
}
------------------------
Find a silently evolved API code:android.util.jar.StrictJarVerifier.VerifierEntry.verify:COMMENT
Method Modifier: default     
Comment:/**
 * Verifies that the digests stored in the manifest match the decrypted
 * digests from the .SF file. This indicates the validity of the
 * signing, not the integrity of the file, as its digest must be
 * calculated and verified when its contents are read.
 *
 * @throws SecurityException
 * if the digest value stored in the manifest does <i>not</i>
 * agree with the decrypted digest as recovered from the
 * <code>.SF</code> file.
 */

Body of Frist Method:
{
    byte[] d = digest.digest();
    if (!MessageDigest.isEqual(d, Base64.decode(hash))) {
        throw invalidDigest(JarFile.MANIFEST_NAME, name, name);
    }
    verifiedEntries.put(name, certChains);
}
Body of Second Method:
{
    byte[] d = digest.digest();
    if (!verifyMessageDigest(d, hash)) {
        throw invalidDigest(JarFile.MANIFEST_NAME, name, name);
    }
    verifiedEntries.put(name, certChains);
}
------------------------
Find a silently evolved API code:android.widget.SuggestionsAdapter.newView:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Tags the view with cached child view look-ups.
 */

Body of Frist Method:
{
    final View v = super.newView(context, cursor, parent);
    v.setTag(new ChildViewCache(v));
    // Set up icon.
    final ImageView iconRefine = (ImageView) v.findViewById(R.id.edit_query);
    iconRefine.setImageResource(mCommitIconResId);
    return v;
}
Body of Second Method:
{
    final View v = super.newView(context, cursor, parent);
    v.setTag(new ChildViewCache(v));
    // Set up icon.
    final ImageView iconRefine = v.findViewById(R.id.edit_query);
    iconRefine.setImageResource(mCommitIconResId);
    return v;
}
------------------------
Find a silently evolved API code:android.renderscript.Allocation.createAllocations:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a new Allocation Array with the given {@link
 * android.renderscript.Type}, and usage flags.
 * Note: If the input allocation is of usage: USAGE_IO_INPUT,
 * the created Allocation will be sharing the same BufferQueue.
 *
 * @param rs RenderScript context
 * @param t RenderScript type describing data layout
 * @param usage bit field specifying how the Allocation is
 * utilized
 * @param numAlloc Number of Allocations in the array.
 * @return Allocation[]
 */

Body of Frist Method:
{
    try {
        Trace.traceBegin(RenderScript.TRACE_TAG, "createAllocations");
        rs.validate();
        if (t.getID(rs) == 0) {
            throw new RSInvalidStateException("Bad Type");
        }
        Allocation[] mAllocationArray = new Allocation[numAlloc];
        mAllocationArray[0] = createTyped(rs, t, usage);
        if ((usage & USAGE_IO_INPUT) != 0) {
            if (numAlloc > MAX_NUMBER_IO_INPUT_ALLOC) {
                throw new RSIllegalArgumentException("Exceeds the max number of Allocations allowed: " + MAX_NUMBER_IO_INPUT_ALLOC);
            }
            mAllocationArray[0].setupBufferQueue(numAlloc);
            ;
        }
        for (int i = 1; i < numAlloc; i++) {
            mAllocationArray[i] = createFromAllocation(rs, mAllocationArray[0]);
        }
        return mAllocationArray;
    } finally {
        Trace.traceEnd(RenderScript.TRACE_TAG);
    }
}
Body of Second Method:
{
    try {
        Trace.traceBegin(RenderScript.TRACE_TAG, "createAllocations");
        rs.validate();
        if (t.getID(rs) == 0) {
            throw new RSInvalidStateException("Bad Type");
        }
        Allocation[] mAllocationArray = new Allocation[numAlloc];
        mAllocationArray[0] = createTyped(rs, t, usage);
        if ((usage & USAGE_IO_INPUT) != 0) {
            if (numAlloc > MAX_NUMBER_IO_INPUT_ALLOC) {
                mAllocationArray[0].destroy();
                throw new RSIllegalArgumentException("Exceeds the max number of Allocations allowed: " + MAX_NUMBER_IO_INPUT_ALLOC);
            }
            mAllocationArray[0].setupBufferQueue(numAlloc);
            ;
        }
        for (int i = 1; i < numAlloc; i++) {
            mAllocationArray[i] = createFromAllocation(rs, mAllocationArray[0]);
        }
        return mAllocationArray;
    } finally {
        Trace.traceEnd(RenderScript.TRACE_TAG);
    }
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets all contents to the values stored in the provided object.
 * @hide
 */

Body of Frist Method:
{
    mFlags = measurement.mFlags;
    mSvid = measurement.mSvid;
    mConstellationType = measurement.mConstellationType;
    mTimeOffsetNanos = measurement.mTimeOffsetNanos;
    mState = measurement.mState;
    mReceivedSvTimeNanos = measurement.mReceivedSvTimeNanos;
    mReceivedSvTimeUncertaintyNanos = measurement.mReceivedSvTimeUncertaintyNanos;
    mCn0DbHz = measurement.mCn0DbHz;
    mPseudorangeRateMetersPerSecond = measurement.mPseudorangeRateMetersPerSecond;
    mPseudorangeRateUncertaintyMetersPerSecond = measurement.mPseudorangeRateUncertaintyMetersPerSecond;
    mAccumulatedDeltaRangeState = measurement.mAccumulatedDeltaRangeState;
    mAccumulatedDeltaRangeMeters = measurement.mAccumulatedDeltaRangeMeters;
    mAccumulatedDeltaRangeUncertaintyMeters = measurement.mAccumulatedDeltaRangeUncertaintyMeters;
    mCarrierFrequencyHz = measurement.mCarrierFrequencyHz;
    mCarrierCycles = measurement.mCarrierCycles;
    mCarrierPhase = measurement.mCarrierPhase;
    mCarrierPhaseUncertainty = measurement.mCarrierPhaseUncertainty;
    mMultipathIndicator = measurement.mMultipathIndicator;
    mSnrInDb = measurement.mSnrInDb;
}
Body of Second Method:
{
    mFlags = measurement.mFlags;
    mSvid = measurement.mSvid;
    mConstellationType = measurement.mConstellationType;
    mTimeOffsetNanos = measurement.mTimeOffsetNanos;
    mState = measurement.mState;
    mReceivedSvTimeNanos = measurement.mReceivedSvTimeNanos;
    mReceivedSvTimeUncertaintyNanos = measurement.mReceivedSvTimeUncertaintyNanos;
    mCn0DbHz = measurement.mCn0DbHz;
    mPseudorangeRateMetersPerSecond = measurement.mPseudorangeRateMetersPerSecond;
    mPseudorangeRateUncertaintyMetersPerSecond = measurement.mPseudorangeRateUncertaintyMetersPerSecond;
    mAccumulatedDeltaRangeState = measurement.mAccumulatedDeltaRangeState;
    mAccumulatedDeltaRangeMeters = measurement.mAccumulatedDeltaRangeMeters;
    mAccumulatedDeltaRangeUncertaintyMeters = measurement.mAccumulatedDeltaRangeUncertaintyMeters;
    mCarrierFrequencyHz = measurement.mCarrierFrequencyHz;
    mCarrierCycles = measurement.mCarrierCycles;
    mCarrierPhase = measurement.mCarrierPhase;
    mCarrierPhaseUncertainty = measurement.mCarrierPhaseUncertainty;
    mMultipathIndicator = measurement.mMultipathIndicator;
    mSnrInDb = measurement.mSnrInDb;
    mAutomaticGainControlLevelInDb = measurement.mAutomaticGainControlLevelInDb;
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.sort:COMMENT
Method Modifier: private     final       
Comment:/**
 * An iterative heap sort implementation. It will sort the spans using first their priority
 * then insertion order. A span with higher priority will be before a span with lower
 * priority. If priorities are the same, the spans will be sorted with insertion order. A
 * span with a lower insertion order will be before a span with a higher insertion order.
 *
 * @param array Span array to be sorted.
 * @param priority Priorities of the spans
 * @param insertionOrder Insertion orders of the spans
 * @param <T> Span object type.
 * @param <T>
 */

Body of Frist Method:
{
    int size = array.length;
    for (int i = size / 2 - 1; i >= 0; i--) {
        siftDown(i, array, size, priority, insertionOrder);
    }
    for (int i = size - 1; i > 0; i--) {
        T v = array[0];
        int prio = priority[0];
        int insertOrder = insertionOrder[0];
        array[0] = array[i];
        priority[0] = priority[i];
        insertionOrder[0] = insertionOrder[i];
        siftDown(0, array, i, priority, insertionOrder);
        array[i] = v;
        priority[i] = prio;
        insertionOrder[i] = insertOrder;
    }
}
Body of Second Method:
{
    int size = array.length;
    for (int i = size / 2 - 1; i >= 0; i--) {
        siftDown(i, array, size, priority, insertionOrder);
    }
    for (int i = size - 1; i > 0; i--) {
        final T tmpSpan = array[0];
        array[0] = array[i];
        array[i] = tmpSpan;
        final int tmpPriority = priority[0];
        priority[0] = priority[i];
        priority[i] = tmpPriority;
        final int tmpOrder = insertionOrder[0];
        insertionOrder[0] = insertionOrder[i];
        insertionOrder[i] = tmpOrder;
        siftDown(0, array, i, priority, insertionOrder);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ActivityInfo.isResizeableMode:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mode == RESIZE_MODE_RESIZEABLE || mode == RESIZE_MODE_RESIZEABLE_AND_PIPABLE || mode == RESIZE_MODE_FORCE_RESIZEABLE;
}
Body of Second Method:
{
    return mode == RESIZE_MODE_RESIZEABLE || mode == RESIZE_MODE_FORCE_RESIZEABLE || mode == RESIZE_MODE_FORCE_RESIZABLE_PORTRAIT_ONLY || mode == RESIZE_MODE_FORCE_RESIZABLE_LANDSCAPE_ONLY || mode == RESIZE_MODE_FORCE_RESIZABLE_PRESERVE_ORIENTATION || mode == RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION;
}
------------------------
Find a silently evolved API code:android.text.TextUtils.isEmpty:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns true if the string is null or 0-length.
 * @param str the string to be examined
 * @return true if str is null or zero length
 */

Body of Frist Method:
{
    if (str == null || str.length() == 0)
        return true;
    else
        return false;
}
Body of Second Method:
{
    return str == null || str.length() == 0;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the Drawable for the attribute at <var>index</var>.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a color or drawable resource.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a color or drawable resource.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        return mResources.loadDrawable(value, value.resourceId, mTheme);
    }
    return null;
}
Body of Second Method:
{
    return getDrawableForDensity(index, 0);
}
------------------------
Find a silently evolved API code:android.view.RenderNode.end:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Ends the recording for this display list. A display list cannot be
 * replayed if recording is not finished. Calling this method marks
 * the display list valid and {@link #isValid()} will return true.
 *
 * @see #start(int, int)
 * @see #isValid()
 */

Body of Frist Method:
{
    long displayList = canvas.finishRecording();
    nSetDisplayList(mNativeRenderNode, displayList);
    canvas.recycle();
    mValid = true;
}
Body of Second Method:
{
    long displayList = canvas.finishRecording();
    nSetDisplayList(mNativeRenderNode, displayList);
    canvas.recycle();
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getSmsSendCapableForPhone:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get SMS send capable from system property by phone id.
 *
 * @param phoneId for which SMS send capable is get
 * @param defaultValue default value
 * @return SMS send capable
 *
 * @hide
 */

Body of Frist Method:
{
    if (SubscriptionManager.isValidPhoneId(phoneId)) {
        return Boolean.valueOf(TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_SMS_SEND, String.valueOf(defaultValue)));
    }
    return defaultValue;
}
Body of Second Method:
{
    if (SubscriptionManager.isValidPhoneId(phoneId)) {
        return Boolean.parseBoolean(TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_SMS_SEND, String.valueOf(defaultValue)));
    }
    return defaultValue;
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.tileify:COMMENT
Method Modifier: private     
Comment:/**
 * Converts a drawable to a tiled version of itself. It will recursively
 * traverse layer and state list drawables.
 */

Body of Frist Method:
{
    if (drawable instanceof LayerDrawable) {
        final LayerDrawable orig = (LayerDrawable) drawable;
        final int N = orig.getNumberOfLayers();
        final Drawable[] outDrawables = new Drawable[N];
        for (int i = 0; i < N; i++) {
            final int id = orig.getId(i);
            outDrawables[i] = tileify(orig.getDrawable(i), (id == R.id.progress || id == R.id.secondaryProgress));
        }
        final LayerDrawable clone = new LayerDrawable(outDrawables);
        for (int i = 0; i < N; i++) {
            clone.setId(i, orig.getId(i));
            clone.setLayerGravity(i, orig.getLayerGravity(i));
            clone.setLayerWidth(i, orig.getLayerWidth(i));
            clone.setLayerHeight(i, orig.getLayerHeight(i));
            clone.setLayerInsetLeft(i, orig.getLayerInsetLeft(i));
            clone.setLayerInsetRight(i, orig.getLayerInsetRight(i));
            clone.setLayerInsetTop(i, orig.getLayerInsetTop(i));
            clone.setLayerInsetBottom(i, orig.getLayerInsetBottom(i));
            clone.setLayerInsetStart(i, orig.getLayerInsetStart(i));
            clone.setLayerInsetEnd(i, orig.getLayerInsetEnd(i));
        }
        return clone;
    }
    if (drawable instanceof StateListDrawable) {
        final StateListDrawable in = (StateListDrawable) drawable;
        final StateListDrawable out = new StateListDrawable();
        final int N = in.getStateCount();
        for (int i = 0; i < N; i++) {
            out.addState(in.getStateSet(i), tileify(in.getStateDrawable(i), clip));
        }
        return out;
    }
    if (drawable instanceof BitmapDrawable) {
        final BitmapDrawable bitmap = (BitmapDrawable) drawable;
        final Bitmap tileBitmap = bitmap.getBitmap();
        if (mSampleTile == null) {
            mSampleTile = tileBitmap;
        }
        final BitmapDrawable clone = (BitmapDrawable) bitmap.getConstantState().newDrawable();
        clone.setTileModeXY(Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
        if (clip) {
            return new ClipDrawable(clone, Gravity.LEFT, ClipDrawable.HORIZONTAL);
        } else {
            return clone;
        }
    }
    return drawable;
}
Body of Second Method:
{
    if (drawable instanceof LayerDrawable) {
        final LayerDrawable orig = (LayerDrawable) drawable;
        final int N = orig.getNumberOfLayers();
        final Drawable[] outDrawables = new Drawable[N];
        for (int i = 0; i < N; i++) {
            final int id = orig.getId(i);
            outDrawables[i] = tileify(orig.getDrawable(i), (id == R.id.progress || id == R.id.secondaryProgress));
        }
        final LayerDrawable clone = new LayerDrawable(outDrawables);
        for (int i = 0; i < N; i++) {
            clone.setId(i, orig.getId(i));
            clone.setLayerGravity(i, orig.getLayerGravity(i));
            clone.setLayerWidth(i, orig.getLayerWidth(i));
            clone.setLayerHeight(i, orig.getLayerHeight(i));
            clone.setLayerInsetLeft(i, orig.getLayerInsetLeft(i));
            clone.setLayerInsetRight(i, orig.getLayerInsetRight(i));
            clone.setLayerInsetTop(i, orig.getLayerInsetTop(i));
            clone.setLayerInsetBottom(i, orig.getLayerInsetBottom(i));
            clone.setLayerInsetStart(i, orig.getLayerInsetStart(i));
            clone.setLayerInsetEnd(i, orig.getLayerInsetEnd(i));
        }
        return clone;
    }
    if (drawable instanceof StateListDrawable) {
        final StateListDrawable in = (StateListDrawable) drawable;
        final StateListDrawable out = new StateListDrawable();
        final int N = in.getStateCount();
        for (int i = 0; i < N; i++) {
            out.addState(in.getStateSet(i), tileify(in.getStateDrawable(i), clip));
        }
        return out;
    }
    if (drawable instanceof BitmapDrawable) {
        final Drawable.ConstantState cs = drawable.getConstantState();
        final BitmapDrawable clone = (BitmapDrawable) cs.newDrawable(getResources());
        clone.setTileModeXY(Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
        if (mSampleWidth <= 0) {
            mSampleWidth = clone.getIntrinsicWidth();
        }
        if (clip) {
            return new ClipDrawable(clone, Gravity.LEFT, ClipDrawable.HORIZONTAL);
        } else {
            return clone;
        }
    }
    return drawable;
}
------------------------
Find a silently evolved API code:android.preference.PreferenceActivity.isMultiPane:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if this activity is showing multiple panes -- the headers
 * and a preference fragment.
 */

Body of Frist Method:
{
    return hasHeaders() && mPrefsContainer.getVisibility() == View.VISIBLE;
}
Body of Second Method:
{
    return !mSinglePane;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.InputContentInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    Uri.writeToParcel(dest, mContentUri);
    mDescription.writeToParcel(dest, flags);
    Uri.writeToParcel(dest, mLinkUri);
    if (mUriToken != null) {
        dest.writeInt(1);
        dest.writeStrongBinder(mUriToken.asBinder());
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    Uri.writeToParcel(dest, mContentUri);
    dest.writeInt(mContentUriOwnerUserId);
    mDescription.writeToParcel(dest, flags);
    Uri.writeToParcel(dest, mLinkUri);
    if (mUriToken != null) {
        dest.writeInt(1);
        dest.writeStrongBinder(mUriToken.asBinder());
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.rotate:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcat the current matrix with the specified rotation.
 *
 * @param degrees The amount to rotate, in degrees
 */

Body of Frist Method:
{
    native_rotate(mNativeCanvasWrapper, degrees);
}
Body of Second Method:
{
    if (degrees == 0.0f)
        return;
    nRotate(mNativeCanvasWrapper, degrees);
}
------------------------
Find a silently evolved API code:android.content.pm.InstrumentationInfo.copyTo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    ai.packageName = packageName;
    ai.sourceDir = sourceDir;
    ai.publicSourceDir = publicSourceDir;
    ai.splitSourceDirs = splitSourceDirs;
    ai.splitPublicSourceDirs = splitPublicSourceDirs;
    ai.dataDir = dataDir;
    ai.deviceProtectedDataDir = deviceProtectedDataDir;
    ai.credentialProtectedDataDir = credentialProtectedDataDir;
    ai.nativeLibraryDir = nativeLibraryDir;
    ai.secondaryNativeLibraryDir = secondaryNativeLibraryDir;
}
Body of Second Method:
{
    ai.packageName = packageName;
    ai.sourceDir = sourceDir;
    ai.publicSourceDir = publicSourceDir;
    ai.splitNames = splitNames;
    ai.splitSourceDirs = splitSourceDirs;
    ai.splitPublicSourceDirs = splitPublicSourceDirs;
    ai.splitDependencies = splitDependencies;
    ai.dataDir = dataDir;
    ai.deviceProtectedDataDir = deviceProtectedDataDir;
    ai.credentialProtectedDataDir = credentialProtectedDataDir;
    ai.nativeLibraryDir = nativeLibraryDir;
    ai.secondaryNativeLibraryDir = secondaryNativeLibraryDir;
}
------------------------
Find a silently evolved API code:android.telecom.PhoneAccount.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates an instance of a {@link PhoneAccount} based on the current builder settings.
 *
 * @return The {@link PhoneAccount}.
 */

Body of Frist Method:
{
    // If no supported URI schemes were defined, assume "tel" is supported.
    if (mSupportedUriSchemes.isEmpty()) {
        addSupportedUriScheme(SCHEME_TEL);
    }
    return new PhoneAccount(mAccountHandle, mAddress, mSubscriptionAddress, mCapabilities, mIcon, mHighlightColor, mLabel, mShortDescription, mSupportedUriSchemes, mExtras, mIsEnabled, mGroupId);
}
Body of Second Method:
{
    // If no supported URI schemes were defined, assume "tel" is supported.
    if (mSupportedUriSchemes.isEmpty()) {
        addSupportedUriScheme(SCHEME_TEL);
    }
    return new PhoneAccount(mAccountHandle, mAddress, mSubscriptionAddress, mCapabilities, mIcon, mHighlightColor, mLabel, mShortDescription, mSupportedUriSchemes, mExtras, mSupportedAudioRoutes, mIsEnabled, mGroupId);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.convertToAshmem:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Puts the memory used by this instance into Ashmem memory, if possible.
 * @hide
 */

Body of Frist Method:
{
    if (mType == TYPE_BITMAP && getBitmap().isMutable() && getBitmap().getAllocationByteCount() >= MIN_ASHMEM_ICON_SIZE) {
        setBitmap(getBitmap().createAshmemBitmap());
    }
}
Body of Second Method:
{
    if ((mType == TYPE_BITMAP || mType == TYPE_ADAPTIVE_BITMAP) && getBitmap().isMutable() && getBitmap().getAllocationByteCount() >= MIN_ASHMEM_ICON_SIZE) {
        setBitmap(getBitmap().createAshmemBitmap());
    }
}
------------------------
Find a silently evolved API code:android.graphics.Outline.set:COMMENT
Method Modifier: public      
Comment:/**
 * Replace the contents of this Outline with the contents of src.
 *
 * @param src Source outline to copy from.
 */

Body of Frist Method:
{
    mMode = src.mMode;
    mPath.set(src.mPath);
    mRect.set(src.mRect);
    mRadius = src.mRadius;
    mAlpha = src.mAlpha;
}
Body of Second Method:
{
    mMode = src.mMode;
    if (src.mMode == MODE_CONVEX_PATH) {
        if (mPath == null) {
            mPath = new Path();
        }
        mPath.set(src.mPath);
    }
    mRect.set(src.mRect);
    mRadius = src.mRadius;
    mAlpha = src.mAlpha;
}
------------------------
Find a silently evolved API code:android.os.StrictMode.onVmPolicyViolation:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final boolean penaltyDropbox = (sVmPolicyMask & PENALTY_DROPBOX) != 0;
    final boolean penaltyDeath = ((sVmPolicyMask & PENALTY_DEATH) != 0) || forceDeath;
    final boolean penaltyLog = (sVmPolicyMask & PENALTY_LOG) != 0;
    final ViolationInfo info = new ViolationInfo(message, originStack, sVmPolicyMask);
    // Erase stuff not relevant for process-wide violations
    info.numAnimationsRunning = 0;
    info.tags = null;
    info.broadcastIntentAction = null;
    final Integer fingerprint = info.hashCode();
    final long now = SystemClock.uptimeMillis();
    long lastViolationTime = 0;
    long timeSinceLastViolationMillis = Long.MAX_VALUE;
    synchronized (sLastVmViolationTime) {
        if (sLastVmViolationTime.containsKey(fingerprint)) {
            lastViolationTime = sLastVmViolationTime.get(fingerprint);
            timeSinceLastViolationMillis = now - lastViolationTime;
        }
        if (timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
            sLastVmViolationTime.put(fingerprint, now);
        }
    }
    if (penaltyLog && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        Log.e(TAG, message, originStack);
    }
    int violationMaskSubset = PENALTY_DROPBOX | (ALL_VM_DETECT_BITS & sVmPolicyMask);
    if (penaltyDropbox && !penaltyDeath) {
        // Common case for userdebug/eng builds.  If no death and
        // just dropboxing, we can do the ActivityManager call
        // asynchronously.
        dropboxViolationAsync(violationMaskSubset, info);
        return;
    }
    if (penaltyDropbox && lastViolationTime == 0) {
        // The violationMask, passed to ActivityManager, is a
        // subset of the original StrictMode policy bitmask, with
        // only the bit violated and penalty bits to be executed
        // by the ActivityManagerService remaining set.
        final int savedPolicyMask = getThreadPolicyMask();
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            if (e instanceof DeadObjectException) {
            // System process is dead; ignore
            } else {
                Log.e(TAG, "RemoteException trying to handle StrictMode violation", e);
            }
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if (penaltyDeath) {
        System.err.println("StrictMode VmPolicy violation with POLICY_DEATH; shutting down.");
        Process.killProcess(Process.myPid());
        System.exit(10);
    }
}
Body of Second Method:
{
    onVmPolicyViolation(message, originStack, false);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getAnonymousIdentity:COMMENT
Method Modifier: public      
Comment:/**
 * Get the anonymous identity
 * @return anonymous identity
 */

Body of Frist Method:
{
    return getFieldValue(ANON_IDENTITY_KEY, "");
}
Body of Second Method:
{
    return getFieldValue(ANON_IDENTITY_KEY);
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.getId:COMMENT
Method Modifier: public      
Comment:/**
 * The accessibility service id.
 * <p>
 * <strong>Generated by the system.</strong>
 * </p>
 * @return The id.
 */

Body of Frist Method:
{
    return mId;
}
Body of Second Method:
{
    return mComponentName.flattenToShortString();
}
------------------------
Find a silently evolved API code:android.media.midi.MidiDevice.openInputPort:COMMENT
Method Modifier: public      
Comment:/**
 * Called to open a {@link MidiInputPort} for the specified port number.
 *
 * An input port can only be used by one sender at a time.
 * Opening an input port will fail if another application has already opened it for use.
 * A {@link MidiDeviceStatus} can be used to determine if an input port is already open.
 *
 * @param portNumber the number of the input port to open
 * @return the {@link MidiInputPort} if the open is successful,
 * or null in case of failure.
 */

Body of Frist Method:
{
    if (mIsDeviceClosed) {
        return null;
    }
    try {
        IBinder token = new Binder();
        ParcelFileDescriptor pfd = mDeviceServer.openInputPort(token, portNumber);
        if (pfd == null) {
            return null;
        }
        return new MidiInputPort(mDeviceServer, token, pfd, portNumber);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in openInputPort");
        return null;
    }
}
Body of Second Method:
{
    if (mIsDeviceClosed) {
        return null;
    }
    try {
        IBinder token = new Binder();
        FileDescriptor fd = mDeviceServer.openInputPort(token, portNumber);
        if (fd == null) {
            return null;
        }
        return new MidiInputPort(mDeviceServer, token, fd, portNumber);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in openInputPort");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.isOpaque:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if the device that the current layer draws into is opaque
 * (i.e. does not support per-pixel alpha).
 *
 * @return true if the device that the current layer draws into is opaque
 */

Body of Frist Method:
{
    return native_isOpaque(mNativeCanvasWrapper);
}
Body of Second Method:
{
    return nIsOpaque(mNativeCanvasWrapper);
}
------------------------
Find a silently evolved API code:android.net.NetworkScoreManager.getActiveScorerPackage:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Obtain the package name of the current active network scorer.
 *
 * <p>At any time, only one scorer application will receive {@link #ACTION_SCORE_NETWORKS}
 * broadcasts and be allowed to call {@link #updateScores}. Applications may use this method to
 * determine the current scorer and offer the user the ability to select a different scorer via
 * the {@link #ACTION_CHANGE_ACTIVE} intent.
 * @return the full package name of the current active scorer, or null if there is no active
 * scorer.
 */

Body of Frist Method:
{
    NetworkScorerAppData app = NetworkScorerAppManager.getActiveScorer(mContext);
    if (app == null) {
        return null;
    }
    return app.mPackageName;
}
Body of Second Method:
{
    try {
        return mService.getActiveScorerPackage();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Outline.setEmpty:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the outline to be empty.
 *
 * @see #isEmpty()
 */

Body of Frist Method:
{
    mMode = MODE_EMPTY;
    mPath.rewind();
    mRect.setEmpty();
    mRadius = RADIUS_UNDEFINED;
}
Body of Second Method:
{
    if (mPath != null) {
        // rewind here to avoid thrashing the allocations, but could alternately clear ref
        mPath.rewind();
    }
    mMode = MODE_EMPTY;
    mRect.setEmpty();
    mRadius = RADIUS_UNDEFINED;
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfEditor.getPageMediaBox:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the media box of a given page in mils (1/72").
 *
 * @param pageIndex The page index.
 * @param outMediaBox The media box output.
 */

Body of Frist Method:
{
    throwIfClosed();
    throwIfOutMediaBoxNull(outMediaBox);
    throwIfPageNotInDocument(pageIndex);
    return nativeGetPageMediaBox(mNativeDocument, pageIndex, outMediaBox);
}
Body of Second Method:
{
    throwIfClosed();
    throwIfOutMediaBoxNull(outMediaBox);
    throwIfPageNotInDocument(pageIndex);
    synchronized (PdfRenderer.sPdfiumLock) {
        return nativeGetPageMediaBox(mNativeDocument, pageIndex, outMediaBox);
    }
}
------------------------
Find a silently evolved API code:android.content.ClipData.newUri:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new ClipData holding a URI.  If the URI is a content: URI,
 * this will query the content provider for the MIME type of its data and
 * use that as the MIME type.  Otherwise, it will use the MIME type
 * {@link ClipDescription#MIMETYPE_TEXT_URILIST}.
 *
 * @param resolver ContentResolver used to get information about the URI.
 * @param label User-visible label for the clip data.
 * @param uri The URI in the clip.
 * @return Returns a new ClipData containing the specified data.
 */

Body of Frist Method:
{
    Item item = new Item(uri);
    String[] mimeTypes = null;
    if ("content".equals(uri.getScheme())) {
        String realType = resolver.getType(uri);
        mimeTypes = resolver.getStreamTypes(uri, "*/*");
        if (realType != null) {
            if (mimeTypes == null) {
                mimeTypes = new String[] { realType };
            } else {
                String[] tmp = new String[mimeTypes.length + 1];
                tmp[0] = realType;
                System.arraycopy(mimeTypes, 0, tmp, 1, mimeTypes.length);
                mimeTypes = tmp;
            }
        }
    }
    if (mimeTypes == null) {
        mimeTypes = MIMETYPES_TEXT_URILIST;
    }
    return new ClipData(label, mimeTypes, item);
}
Body of Second Method:
{
    Item item = new Item(uri);
    String[] mimeTypes = getMimeTypes(resolver, uri);
    return new ClipData(label, mimeTypes, item);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraMetadata.getKeys:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */

Body of Frist Method:
{
    Class<CameraMetadata<TKey>> thisClass = (Class<CameraMetadata<TKey>>) getClass();
    return Collections.unmodifiableList(getKeysStatic(thisClass, getKeyClass(), this, /*filterTags*/
    null));
}
Body of Second Method:
{
    Class<CameraMetadata<TKey>> thisClass = (Class<CameraMetadata<TKey>>) getClass();
    return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), this, /*filterTags*/
    null));
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.sameAs:COMMENT
Method Modifier: public      
Comment:/**
 * Given another bitmap, return true if it has the same dimensions, config,
 * and pixel data as this bitmap. If any of those differ, return false.
 * If other is null, return false.
 */

Body of Frist Method:
{
    checkRecycled("Can't call sameAs on a recycled bitmap!");
    if (this == other)
        return true;
    if (other == null)
        return false;
    if (other.isRecycled()) {
        throw new IllegalArgumentException("Can't compare to a recycled bitmap!");
    }
    return nativeSameAs(mNativePtr, other.mNativePtr);
}
Body of Second Method:
{
    checkRecycled("Can't call sameAs on a recycled bitmap!");
    noteHardwareBitmapSlowCall();
    if (this == other)
        return true;
    if (other == null)
        return false;
    other.noteHardwareBitmapSlowCall();
    if (other.isRecycled()) {
        throw new IllegalArgumentException("Can't compare to a recycled bitmap!");
    }
    return nativeSameAs(mNativePtr, other.mNativePtr);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.getBitmap:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return The {@link android.graphics.Bitmap} held by this {@link #TYPE_BITMAP} Icon.
 * @hide
 */

Body of Frist Method:
{
    if (mType != TYPE_BITMAP) {
        throw new IllegalStateException("called getBitmap() on " + this);
    }
    return (Bitmap) mObj1;
}
Body of Second Method:
{
    if (mType != TYPE_BITMAP && mType != TYPE_ADAPTIVE_BITMAP) {
        throw new IllegalStateException("called getBitmap() on " + this);
    }
    return (Bitmap) mObj1;
}
------------------------
Find a silently evolved API code:android.graphics.Path.isRect:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the path specifies a rectangle. If so, and if rect is
 * not null, set rect to the bounds of the path. If the path does not
 * specify a rectangle, return false and ignore rect.
 *
 * @param rect If not null, returns the bounds of the path if it specifies
 * a rectangle
 * @return     true if the path specifies a rectangle
 */

Body of Frist Method:
{
    return native_isRect(mNativePath, rect);
}
Body of Second Method:
{
    return nIsRect(mNativePath, rect);
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.getStateString:COMMENT
Method Modifier: private     
Comment:/**
 * Gets a string representation of the 'sync state'.
 *
 * <p>For internal and logging use only.
 */

Body of Frist Method:
{
    if (mState == STATE_UNKNOWN) {
        return "Unknown";
    }
    StringBuilder builder = new StringBuilder();
    if ((mState & STATE_CODE_LOCK) != 0) {
        builder.append("CodeLock|");
    }
    if ((mState & STATE_BIT_SYNC) != 0) {
        builder.append("BitSync|");
    }
    if ((mState & STATE_SUBFRAME_SYNC) != 0) {
        builder.append("SubframeSync|");
    }
    if ((mState & STATE_TOW_DECODED) != 0) {
        builder.append("TowDecoded|");
    }
    if ((mState & STATE_MSEC_AMBIGUOUS) != 0) {
        builder.append("MsecAmbiguous|");
    }
    if ((mState & STATE_SYMBOL_SYNC) != 0) {
        builder.append("SymbolSync|");
    }
    if ((mState & STATE_GLO_STRING_SYNC) != 0) {
        builder.append("GloStringSync|");
    }
    if ((mState & STATE_GLO_TOD_DECODED) != 0) {
        builder.append("GloTodDecoded|");
    }
    if ((mState & STATE_BDS_D2_BIT_SYNC) != 0) {
        builder.append("BdsD2BitSync|");
    }
    if ((mState & STATE_BDS_D2_SUBFRAME_SYNC) != 0) {
        builder.append("BdsD2SubframeSync|");
    }
    if ((mState & STATE_GAL_E1BC_CODE_LOCK) != 0) {
        builder.append("GalE1bcCodeLock|");
    }
    if ((mState & STATE_GAL_E1C_2ND_CODE_LOCK) != 0) {
        builder.append("E1c2ndCodeLock|");
    }
    if ((mState & STATE_GAL_E1B_PAGE_SYNC) != 0) {
        builder.append("GalE1bPageSync|");
    }
    if ((mState & STATE_SBAS_SYNC) != 0) {
        builder.append("SbasSync|");
    }
    int remainingStates = mState & ~STATE_ALL;
    if (remainingStates > 0) {
        builder.append("Other(");
        builder.append(Integer.toBinaryString(remainingStates));
        builder.append(")|");
    }
    builder.setLength(builder.length() - 1);
    return builder.toString();
}
Body of Second Method:
{
    if (mState == STATE_UNKNOWN) {
        return "Unknown";
    }
    StringBuilder builder = new StringBuilder();
    if ((mState & STATE_CODE_LOCK) != 0) {
        builder.append("CodeLock|");
    }
    if ((mState & STATE_BIT_SYNC) != 0) {
        builder.append("BitSync|");
    }
    if ((mState & STATE_SUBFRAME_SYNC) != 0) {
        builder.append("SubframeSync|");
    }
    if ((mState & STATE_TOW_DECODED) != 0) {
        builder.append("TowDecoded|");
    }
    if ((mState & STATE_TOW_KNOWN) != 0) {
        builder.append("TowKnown|");
    }
    if ((mState & STATE_MSEC_AMBIGUOUS) != 0) {
        builder.append("MsecAmbiguous|");
    }
    if ((mState & STATE_SYMBOL_SYNC) != 0) {
        builder.append("SymbolSync|");
    }
    if ((mState & STATE_GLO_STRING_SYNC) != 0) {
        builder.append("GloStringSync|");
    }
    if ((mState & STATE_GLO_TOD_DECODED) != 0) {
        builder.append("GloTodDecoded|");
    }
    if ((mState & STATE_GLO_TOD_KNOWN) != 0) {
        builder.append("GloTodKnown|");
    }
    if ((mState & STATE_BDS_D2_BIT_SYNC) != 0) {
        builder.append("BdsD2BitSync|");
    }
    if ((mState & STATE_BDS_D2_SUBFRAME_SYNC) != 0) {
        builder.append("BdsD2SubframeSync|");
    }
    if ((mState & STATE_GAL_E1BC_CODE_LOCK) != 0) {
        builder.append("GalE1bcCodeLock|");
    }
    if ((mState & STATE_GAL_E1C_2ND_CODE_LOCK) != 0) {
        builder.append("E1c2ndCodeLock|");
    }
    if ((mState & STATE_GAL_E1B_PAGE_SYNC) != 0) {
        builder.append("GalE1bPageSync|");
    }
    if ((mState & STATE_SBAS_SYNC) != 0) {
        builder.append("SbasSync|");
    }
    int remainingStates = mState & ~STATE_ALL;
    if (remainingStates > 0) {
        builder.append("Other(");
        builder.append(Integer.toBinaryString(remainingStates));
        builder.append(")|");
    }
    builder.setLength(builder.length() - 1);
    return builder.toString();
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.setVideoProvider:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Sets the call video provider for a call.
 *
 * @param callId The unique ID of the call to set with the given call video provider.
 * @param videoProvider The call video provider instance to set on the call.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setVideoProvider(callId, videoProvider == null ? null : videoProvider.getInterface());
        } catch (RemoteException e) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setVideoProvider(callId, videoProvider == null ? null : videoProvider.getInterface(), Log.getExternalSession());
        } catch (RemoteException e) {
        }
    }
}
------------------------
Find a silently evolved API code:android.os.StatFs.getAvailableBytes:COMMENT
Method Modifier: public      
Comment:/**
 * The number of bytes that are free on the file system and available to
 * applications.
 */

Body of Frist Method:
{
    return mStat.f_bavail * mStat.f_bsize;
}
Body of Second Method:
{
    return mStat.f_bavail * mStat.f_frsize;
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.isPulsingInternal:COMMENT
Method Modifier: private     
Comment:/**
 * Internal only: This tracks whether the animation has gotten on the animation loop. Note
 * this is different than {@link #isRunning()} in that the latter tracks the time after start()
 * is called (or after start delay if any), which may be before the animation loop starts.
 */

Body of Frist Method:
{
    return mLastFrameTime > 0;
}
Body of Second Method:
{
    return mLastFrameTime >= 0;
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater.createView:COMMENT
Method Modifier: public      final       
Comment:/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */

Body of Frist Method:
{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    if (constructor != null && !verifyClassLoader(constructor)) {
        constructor = null;
        sConstructorMap.remove(name);
    }
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "<unknown>" : clazz.getName()), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
Body of Second Method:
{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    if (constructor != null && !verifyClassLoader(constructor)) {
        constructor = null;
        sConstructorMap.remove(name);
    }
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object lastContext = mConstructorArgs[0];
        if (mConstructorArgs[0] == null) {
            // Fill in the context if not already within inflation.
            mConstructorArgs[0] = mContext;
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        mConstructorArgs[0] = lastContext;
        return view;
    } catch (NoSuchMethodException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "<unknown>" : clazz.getName()), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
------------------------
Find a silently evolved API code:android.view.ViewTreeObserver.addOnDrawListener:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Register a callback to be invoked when the view tree is about to be drawn.</p>
 * <p><strong>Note:</strong> this method <strong>cannot</strong> be invoked from
 * {@link android.view.ViewTreeObserver.OnDrawListener#onDraw()}.</p>
 *
 * @param listener The callback to add
 *
 * @throws IllegalStateException If {@link #isAlive()} returns false
 */

Body of Frist Method:
{
    checkIsAlive();
    if (mOnDrawListeners == null) {
        mOnDrawListeners = new ArrayList<OnDrawListener>();
    }
    mOnDrawListeners.add(listener);
}
Body of Second Method:
{
    checkIsAlive();
    if (mOnDrawListeners == null) {
        mOnDrawListeners = new ArrayList<OnDrawListener>();
    }
    if (mInDispatchOnDraw) {
        IllegalStateException ex = new IllegalStateException("Cannot call addOnDrawListener inside of onDraw");
        if (sIllegalOnDrawModificationIsFatal) {
            throw ex;
        } else {
            Log.e("ViewTreeObserver", ex.getMessage(), ex);
        }
    }
    mOnDrawListeners.add(listener);
}
------------------------
Find a silently evolved API code:android.bluetooth.le.ScanFilter.matchesServiceUuid:COMMENT
<android.bluetooth.le.ScanFilter: boolean matchesServiceUuid(UUID,UUID,UUID)>
private     ->private     static      
Method Modifier: private     static      
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:// Check if the uuid pattern matches the particular service uuid.

Body of Frist Method:
{
    if (mask == null) {
        return uuid.equals(data);
    }
    if ((uuid.getLeastSignificantBits() & mask.getLeastSignificantBits()) != (data.getLeastSignificantBits() & mask.getLeastSignificantBits())) {
        return false;
    }
    return ((uuid.getMostSignificantBits() & mask.getMostSignificantBits()) == (data.getMostSignificantBits() & mask.getMostSignificantBits()));
}
Body of Second Method:
{
    return BitUtils.maskedEquals(data, uuid, mask);
}
------------------------
Find a silently evolved API code:android.hardware.Sensor.setType:COMMENT
Method Modifier: private     
Comment:/**
 * Sets the Type associated with the sensor.
 * NOTE: to be used only by native bindings in SensorManager.
 *
 * This allows interned static strings to be used across all representations of the Sensor. If
 * a sensor type is not referenced here, it will still be interned by the native SensorManager.
 *
 * @return {@code true} if the StringType was successfully set, {@code false} otherwise.
 */

Body of Frist Method:
{
    mType = value;
    switch(mType) {
        case TYPE_ACCELEROMETER:
            mStringType = STRING_TYPE_ACCELEROMETER;
            return true;
        case TYPE_AMBIENT_TEMPERATURE:
            mStringType = STRING_TYPE_AMBIENT_TEMPERATURE;
            return true;
        case TYPE_GAME_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GAME_ROTATION_VECTOR;
            return true;
        case TYPE_GEOMAGNETIC_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
            return true;
        case TYPE_GLANCE_GESTURE:
            mStringType = STRING_TYPE_GLANCE_GESTURE;
            return true;
        case TYPE_GRAVITY:
            mStringType = STRING_TYPE_GRAVITY;
            return true;
        case TYPE_GYROSCOPE:
            mStringType = STRING_TYPE_GYROSCOPE;
            return true;
        case TYPE_GYROSCOPE_UNCALIBRATED:
            mStringType = STRING_TYPE_GYROSCOPE_UNCALIBRATED;
            return true;
        case TYPE_HEART_RATE:
            mStringType = STRING_TYPE_HEART_RATE;
            return true;
        case TYPE_LIGHT:
            mStringType = STRING_TYPE_LIGHT;
            return true;
        case TYPE_LINEAR_ACCELERATION:
            mStringType = STRING_TYPE_LINEAR_ACCELERATION;
            return true;
        case TYPE_MAGNETIC_FIELD:
            mStringType = STRING_TYPE_MAGNETIC_FIELD;
            return true;
        case TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            mStringType = STRING_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
            return true;
        case TYPE_PICK_UP_GESTURE:
            mStringType = STRING_TYPE_PICK_UP_GESTURE;
            return true;
        case TYPE_PRESSURE:
            mStringType = STRING_TYPE_PRESSURE;
            return true;
        case TYPE_PROXIMITY:
            mStringType = STRING_TYPE_PROXIMITY;
            return true;
        case TYPE_RELATIVE_HUMIDITY:
            mStringType = STRING_TYPE_RELATIVE_HUMIDITY;
            return true;
        case TYPE_ROTATION_VECTOR:
            mStringType = STRING_TYPE_ROTATION_VECTOR;
            return true;
        case TYPE_SIGNIFICANT_MOTION:
            mStringType = STRING_TYPE_SIGNIFICANT_MOTION;
            return true;
        case TYPE_STEP_COUNTER:
            mStringType = STRING_TYPE_STEP_COUNTER;
            return true;
        case TYPE_STEP_DETECTOR:
            mStringType = STRING_TYPE_STEP_DETECTOR;
            return true;
        case TYPE_TILT_DETECTOR:
            mStringType = SENSOR_STRING_TYPE_TILT_DETECTOR;
            return true;
        case TYPE_WAKE_GESTURE:
            mStringType = STRING_TYPE_WAKE_GESTURE;
            return true;
        case TYPE_ORIENTATION:
            mStringType = STRING_TYPE_ORIENTATION;
            return true;
        case TYPE_TEMPERATURE:
            mStringType = STRING_TYPE_TEMPERATURE;
            return true;
        case TYPE_DEVICE_ORIENTATION:
            mStringType = STRING_TYPE_DEVICE_ORIENTATION;
            return true;
        case TYPE_DYNAMIC_SENSOR_META:
            mStringType = STRING_TYPE_DYNAMIC_SENSOR_META;
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    mType = value;
    switch(mType) {
        case TYPE_ACCELEROMETER:
            mStringType = STRING_TYPE_ACCELEROMETER;
            return true;
        case TYPE_AMBIENT_TEMPERATURE:
            mStringType = STRING_TYPE_AMBIENT_TEMPERATURE;
            return true;
        case TYPE_GAME_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GAME_ROTATION_VECTOR;
            return true;
        case TYPE_GEOMAGNETIC_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
            return true;
        case TYPE_GLANCE_GESTURE:
            mStringType = STRING_TYPE_GLANCE_GESTURE;
            return true;
        case TYPE_GRAVITY:
            mStringType = STRING_TYPE_GRAVITY;
            return true;
        case TYPE_GYROSCOPE:
            mStringType = STRING_TYPE_GYROSCOPE;
            return true;
        case TYPE_GYROSCOPE_UNCALIBRATED:
            mStringType = STRING_TYPE_GYROSCOPE_UNCALIBRATED;
            return true;
        case TYPE_HEART_RATE:
            mStringType = STRING_TYPE_HEART_RATE;
            return true;
        case TYPE_LIGHT:
            mStringType = STRING_TYPE_LIGHT;
            return true;
        case TYPE_LINEAR_ACCELERATION:
            mStringType = STRING_TYPE_LINEAR_ACCELERATION;
            return true;
        case TYPE_MAGNETIC_FIELD:
            mStringType = STRING_TYPE_MAGNETIC_FIELD;
            return true;
        case TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            mStringType = STRING_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
            return true;
        case TYPE_PICK_UP_GESTURE:
            mStringType = STRING_TYPE_PICK_UP_GESTURE;
            return true;
        case TYPE_PRESSURE:
            mStringType = STRING_TYPE_PRESSURE;
            return true;
        case TYPE_PROXIMITY:
            mStringType = STRING_TYPE_PROXIMITY;
            return true;
        case TYPE_RELATIVE_HUMIDITY:
            mStringType = STRING_TYPE_RELATIVE_HUMIDITY;
            return true;
        case TYPE_ROTATION_VECTOR:
            mStringType = STRING_TYPE_ROTATION_VECTOR;
            return true;
        case TYPE_SIGNIFICANT_MOTION:
            mStringType = STRING_TYPE_SIGNIFICANT_MOTION;
            return true;
        case TYPE_STEP_COUNTER:
            mStringType = STRING_TYPE_STEP_COUNTER;
            return true;
        case TYPE_STEP_DETECTOR:
            mStringType = STRING_TYPE_STEP_DETECTOR;
            return true;
        case TYPE_TILT_DETECTOR:
            mStringType = SENSOR_STRING_TYPE_TILT_DETECTOR;
            return true;
        case TYPE_WAKE_GESTURE:
            mStringType = STRING_TYPE_WAKE_GESTURE;
            return true;
        case TYPE_ORIENTATION:
            mStringType = STRING_TYPE_ORIENTATION;
            return true;
        case TYPE_TEMPERATURE:
            mStringType = STRING_TYPE_TEMPERATURE;
            return true;
        case TYPE_DEVICE_ORIENTATION:
            mStringType = STRING_TYPE_DEVICE_ORIENTATION;
            return true;
        case TYPE_DYNAMIC_SENSOR_META:
            mStringType = STRING_TYPE_DYNAMIC_SENSOR_META;
            return true;
        case TYPE_LOW_LATENCY_OFFBODY_DETECT:
            mStringType = STRING_TYPE_LOW_LATENCY_OFFBODY_DETECT;
            return true;
        case TYPE_ACCELEROMETER_UNCALIBRATED:
            mStringType = STRING_TYPE_ACCELEROMETER_UNCALIBRATED;
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.deleteStatusToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    switch(status) {
        case DELETE_SUCCEEDED:
            return "DELETE_SUCCEEDED";
        case DELETE_FAILED_INTERNAL_ERROR:
            return "DELETE_FAILED_INTERNAL_ERROR";
        case DELETE_FAILED_DEVICE_POLICY_MANAGER:
            return "DELETE_FAILED_DEVICE_POLICY_MANAGER";
        case DELETE_FAILED_USER_RESTRICTED:
            return "DELETE_FAILED_USER_RESTRICTED";
        case DELETE_FAILED_OWNER_BLOCKED:
            return "DELETE_FAILED_OWNER_BLOCKED";
        case DELETE_FAILED_ABORTED:
            return "DELETE_FAILED_ABORTED";
        default:
            return Integer.toString(status);
    }
}
Body of Second Method:
{
    final String str = deleteStatusToString(status);
    if (msg != null) {
        return str + ": " + msg;
    } else {
        return str;
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHostView.updateAppWidget:COMMENT
Method Modifier: public      
Comment:/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */

Body of Frist Method:
{
    applyRemoteViews(remoteViews);
}
Body of Second Method:
{
    applyRemoteViews(remoteViews, true);
}
------------------------
Find a silently evolved API code:android.util.EventLog.Event.getData:COMMENT
Method Modifier: public      
Comment:/**
 * @return one of Integer, Long, Float, String, null, or Object[] of same.
 */

Body of Frist Method:
{
    try {
        int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
        if (offset == 0) {
            offset = V1_PAYLOAD_START;
        }
        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
        // Just after the tag.
        mBuffer.position(offset + DATA_OFFSET);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, "Illegal entry payload: tag=" + getTag(), e);
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, "Truncated entry payload: tag=" + getTag(), e);
        return null;
    }
}
Body of Second Method:
{
    try {
        int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
        if (offset == 0) {
            offset = V1_PAYLOAD_START;
        }
        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
        if ((offset + DATA_OFFSET) >= mBuffer.limit()) {
            // no payload
            return null;
        }
        // Just after the tag.
        mBuffer.position(offset + DATA_OFFSET);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, "Illegal entry payload: tag=" + getTag(), e);
        mLastWtf = e;
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, "Truncated entry payload: tag=" + getTag(), e);
        mLastWtf = e;
        return null;
    }
}
------------------------
Find a silently evolved API code:android.location.Location.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Clears the contents of the location.
 */

Body of Frist Method:
{
    mProvider = null;
    mTime = 0;
    mElapsedRealtimeNanos = 0;
    mFieldsMask = 0;
    mLatitude = 0;
    mLongitude = 0;
    mAltitude = 0;
    mSpeed = 0;
    mBearing = 0;
    mAccuracy = 0;
    mExtras = null;
}
Body of Second Method:
{
    mProvider = null;
    mTime = 0;
    mElapsedRealtimeNanos = 0;
    mFieldsMask = 0;
    mLatitude = 0;
    mLongitude = 0;
    mAltitude = 0;
    mSpeed = 0;
    mBearing = 0;
    mHorizontalAccuracyMeters = 0;
    mVerticalAccuracyMeters = 0;
    mSpeedAccuracyMetersPerSecond = 0;
    mBearingAccuracyDegrees = 0;
    mExtras = null;
}
------------------------
Find a silently evolved API code:android.text.BidiFormatter.DirectionalityEstimator.dirTypeForward:COMMENT
Method Modifier: default     
Comment:/**
 * Returns the Character.DIRECTIONALITY_... value of the next codepoint and advances
 * charIndex. If isHtml, and the codepoint is '<' or '&', advances through the tag/entity,
 * and returns Character.DIRECTIONALITY_WHITESPACE. For an entity, it would be best to
 * figure out the actual character, and return its dirtype, but treating it as whitespace is
 * good enough for our purposes.
 *
 * @throws java.lang.IndexOutOfBoundsException if called when charIndex >= length or < 0.
 */

Body of Frist Method:
{
    lastChar = text.charAt(charIndex);
    if (Character.isHighSurrogate(lastChar)) {
        int codePoint = Character.codePointAt(text, charIndex);
        charIndex += Character.charCount(codePoint);
        return Character.getDirectionality(codePoint);
    }
    charIndex++;
    byte dirType = getCachedDirectionality(lastChar);
    if (isHtml) {
        // Process tags and entities.
        if (lastChar == '<') {
            dirType = skipTagForward();
        } else if (lastChar == '&') {
            dirType = skipEntityForward();
        }
    }
    return dirType;
}
Body of Second Method:
{
    lastChar = text.charAt(charIndex);
    if (Character.isHighSurrogate(lastChar)) {
        int codePoint = Character.codePointAt(text, charIndex);
        charIndex += Character.charCount(codePoint);
        return getDirectionality(codePoint);
    }
    charIndex++;
    byte dirType = getCachedDirectionality(lastChar);
    if (isHtml) {
        // Process tags and entities.
        if (lastChar == '<') {
            dirType = skipTagForward();
        } else if (lastChar == '&') {
            dirType = skipEntityForward();
        }
    }
    return dirType;
}
------------------------
Find a silently evolved API code:android.text.method.WordIterator.isBoundary:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    int shiftedOffset = offset - mOffsetShift;
    checkOffsetIsValid(shiftedOffset);
    return mIterator.isBoundary(shiftedOffset);
}
Body of Second Method:
{
    checkOffsetIsValid(offset);
    return mIterator.isBoundary(offset);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.startTrackingBssids:COMMENT
<android.net.wifi.WifiScanner: void startTrackingBssids(BssidInfo[],int,BssidListener)>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * set interesting access points to find
 * @param bssidInfos access points of interest
 * @param apLostThreshold number of scans needed to indicate that AP is lost
 * @param listener object provided to report events on; this object must be unique and must
 * also be provided on {@link #stopTrackingBssids}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = addListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    HotlistSettings settings = new HotlistSettings();
    settings.bssidInfos = bssidInfos;
    settings.apLostThreshold = apLostThreshold;
    mAsyncChannel.sendMessage(CMD_SET_HOTLIST, 0, key, settings);
}
Body of Second Method:
{
    throw new UnsupportedOperationException();
}
------------------------
Find a silently evolved API code:android.text.Layout.drawText:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int previousLineBottom = getLineTop(firstLine);
    int previousLineEnd = getLineStart(firstLine);
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // The baseline is the top of the following line minus the current line's descent.
    for (int lineNum = firstLine; lineNum <= lastLine; lineNum++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(lineNum + 1);
        int end = getLineVisibleEnd(lineNum, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(lineNum + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(lineNum);
        int dir = getParagraphDirection(lineNum);
        int left = 0;
        int right = mWidth;
        if (mSpannedText) {
            Spanned sp = (Spanned) buf;
            int textLength = buf.length();
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            boolean useFirstLineMargin = isFirstParaLine;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan2) {
                    int count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount();
                    int startLine = getLineForOffset(sp.getSpanStart(spans[n]));
                    // the count that is greatest
                    if (lineNum < startLine + count) {
                        useFirstLineMargin = true;
                        break;
                    }
                }
            }
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTab = getLineContainsTab(lineNum);
        // Can't tell if we have tabs for sure, currently
        if (hasTab && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);
            } else {
                x = right + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);
            }
        } else {
            int max = (int) getLineExtent(lineNum, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);
                } else {
                    x = left - max + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = ((right + left - max) >> 1) + getIndentAdjust(lineNum, Alignment.ALIGN_CENTER);
            }
        }
        paint.setHyphenEdit(getHyphen(lineNum));
        Directions directions = getLineDirections(lineNum);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTab) {
            // XXX: assumes there's nothing additional to be done
            canvas.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTab, tabStops);
            tl.draw(canvas, x, ltop, lbaseline, lbottom);
        }
        paint.setHyphenEdit(0);
    }
    TextLine.recycle(tl);
}
Body of Second Method:
{
    int previousLineBottom = getLineTop(firstLine);
    int previousLineEnd = getLineStart(firstLine);
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    final TextPaint paint = mPaint;
    CharSequence buf = mText;
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // The baseline is the top of the following line minus the current line's descent.
    for (int lineNum = firstLine; lineNum <= lastLine; lineNum++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(lineNum + 1);
        final boolean justify = isJustificationRequired(lineNum);
        int end = getLineVisibleEnd(lineNum, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(lineNum + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(lineNum);
        int dir = getParagraphDirection(lineNum);
        int left = 0;
        int right = mWidth;
        if (mSpannedText) {
            Spanned sp = (Spanned) buf;
            int textLength = buf.length();
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            boolean useFirstLineMargin = isFirstParaLine;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan2) {
                    int count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount();
                    int startLine = getLineForOffset(sp.getSpanStart(spans[n]));
                    // the count that is greatest
                    if (lineNum < startLine + count) {
                        useFirstLineMargin = true;
                        break;
                    }
                }
            }
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTab = getLineContainsTab(lineNum);
        // Can't tell if we have tabs for sure, currently
        if (hasTab && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        final int indentWidth;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                indentWidth = getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);
                x = left + indentWidth;
            } else {
                indentWidth = -getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);
                x = right - indentWidth;
            }
        } else {
            int max = (int) getLineExtent(lineNum, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    indentWidth = -getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);
                    x = right - max - indentWidth;
                } else {
                    indentWidth = getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);
                    x = left - max + indentWidth;
                }
            } else {
                // Alignment.ALIGN_CENTER
                indentWidth = getIndentAdjust(lineNum, Alignment.ALIGN_CENTER);
                max = max & ~1;
                x = ((right + left - max) >> 1) + indentWidth;
            }
        }
        paint.setHyphenEdit(getHyphen(lineNum));
        Directions directions = getLineDirections(lineNum);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTab && !justify) {
            // XXX: assumes there's nothing additional to be done
            canvas.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTab, tabStops);
            if (justify) {
                tl.justify(right - left - indentWidth);
            }
            tl.draw(canvas, x, ltop, lbaseline, lbottom);
        }
        paint.setHyphenEdit(0);
    }
    TextLine.recycle(tl);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setSubjectMatch:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Set subject match (deprecated). This is the substring to be matched against the subject of
 * the authentication server certificate.
 * @param subjectMatch substring to be matched
 * @deprecated in favor of altSubjectMatch
 */

Body of Frist Method:
{
    setFieldValue(SUBJECT_MATCH_KEY, subjectMatch, "");
}
Body of Second Method:
{
    setFieldValue(SUBJECT_MATCH_KEY, subjectMatch);
}
------------------------
Find a silently evolved API code:android.util.PathParser_Delegate.getFloats:COMMENT
Method Modifier: private     static      
Comment:/**
 * Parse the floats in the string. This is an optimized version of
 * parseFloat(s.split(",|\\s"));
 *
 * @param s the string containing a command and list of floats
 *
 * @return array of floats
 */

Body of Frist Method:
{
    if (s.charAt(0) == 'z' || s.charAt(0) == 'Z') {
        return new float[0];
    }
    try {
        float[] results = new float[s.length()];
        int count = 0;
        int startPosition = 1;
        int endPosition;
        ExtractFloatResult result = new ExtractFloatResult();
        int totalLength = s.length();
        // number.
        while (startPosition < totalLength) {
            extract(s, startPosition, result);
            endPosition = result.mEndPosition;
            if (startPosition < endPosition) {
                results[count++] = Float.parseFloat(s.substring(startPosition, endPosition));
            }
            if (result.mEndWithNegOrDot) {
                // Keep the '-' or '.' sign with next number.
                startPosition = endPosition;
            } else {
                startPosition = endPosition + 1;
            }
        }
        return Arrays.copyOf(results, count);
    } catch (NumberFormatException e) {
        throw new RuntimeException("error in parsing \"" + s + "\"", e);
    }
}
Body of Second Method:
{
    if (s.charAt(0) == 'z' || s.charAt(0) == 'Z') {
        return new float[0];
    }
    try {
        float[] results = new float[s.length()];
        int count = 0;
        int startPosition = 1;
        int endPosition;
        ExtractFloatResult result = new ExtractFloatResult();
        int totalLength = s.length();
        // number.
        while (startPosition < totalLength) {
            extract(s, startPosition, result);
            endPosition = result.mEndPosition;
            if (startPosition < endPosition) {
                results[count++] = Float.parseFloat(s.substring(startPosition, endPosition));
            }
            if (result.mEndWithNegOrDot) {
                // Keep the '-' or '.' sign with next number.
                startPosition = endPosition;
            } else {
                startPosition = endPosition + 1;
            }
        }
        return Arrays.copyOf(results, count);
    } catch (NumberFormatException e) {
        assert false : "error in parsing \"" + s + "\"" + e;
        return new float[0];
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.recycle:COMMENT
Method Modifier: public      
Comment:/**
 * Return an instance back to be reused.
 * <p>
 * <strong>Note:</strong> You must not touch the object after calling this function.
 * </p>
 *
 * @throws IllegalStateException If the info is already recycled.
 */

Body of Frist Method:
{
    clear();
    sPool.release(this);
}
Body of Second Method:
{
    clear();
    sPool.release(this);
    if (sNumInstancesInUse != null) {
        sNumInstancesInUse.decrementAndGet();
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getPersistedUriPermissions:COMMENT
Method Modifier: public      
Comment:/**
 * Return list of all URI permission grants that have been persisted by the
 * calling app. That is, the returned permissions have been granted
 * <em>to</em> the calling app. Only persistable grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 *
 * @see #takePersistableUriPermission(Uri, int)
 * @see #releasePersistableUriPermission(Uri, int)
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getPersistedUriPermissions(mPackageName, true).getList();
    } catch (RemoteException e) {
        throw new RuntimeException("Activity manager has died", e);
    }
}
Body of Second Method:
{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, true).getList();
    } catch (RemoteException e) {
        throw new RuntimeException("Activity manager has died", e);
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setPhase2Method:COMMENT
Method Modifier: public      
Comment:/**
 * Set Phase 2 authentication method. Sets the inner authentication method to be used in
 * phase 2 after setting up a secure channel
 * @param phase2Method is the inner authentication method and can be one of {@link Phase2#NONE},
 * {@link Phase2#PAP}, {@link Phase2#MSCHAP}, {@link Phase2#MSCHAPV2},
 * {@link Phase2#GTC}
 * @throws IllegalArgumentException on an invalid phase2 method
 */

Body of Frist Method:
{
    switch(phase2Method) {
        case Phase2.NONE:
        case Phase2.PAP:
        case Phase2.MSCHAP:
        case Phase2.MSCHAPV2:
        case Phase2.GTC:
            mPhase2Method = phase2Method;
            break;
        default:
            throw new IllegalArgumentException("Unknown Phase 2 method");
    }
}
Body of Second Method:
{
    switch(phase2Method) {
        case Phase2.NONE:
        case Phase2.PAP:
        case Phase2.MSCHAP:
        case Phase2.MSCHAPV2:
        case Phase2.GTC:
        case Phase2.SIM:
        case Phase2.AKA:
        case Phase2.AKA_PRIME:
            mPhase2Method = phase2Method;
            break;
        default:
            throw new IllegalArgumentException("Unknown Phase 2 method");
    }
}
------------------------
Find a silently evolved API code:android.graphics.Outline.setConvexPath:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the Constructs an Outline from a
 * {@link android.graphics.Path#isConvex() convex path}.
 */

Body of Frist Method:
{
    if (convexPath.isEmpty()) {
        setEmpty();
        return;
    }
    if (!convexPath.isConvex()) {
        throw new IllegalArgumentException("path must be convex");
    }
    mMode = MODE_CONVEX_PATH;
    mPath.set(convexPath);
    mRect.setEmpty();
    mRadius = RADIUS_UNDEFINED;
}
Body of Second Method:
{
    if (convexPath.isEmpty()) {
        setEmpty();
        return;
    }
    if (!convexPath.isConvex()) {
        throw new IllegalArgumentException("path must be convex");
    }
    if (mPath == null) {
        mPath = new Path();
    }
    mMode = MODE_CONVEX_PATH;
    mPath.set(convexPath);
    mRect.setEmpty();
    mRadius = RADIUS_UNDEFINED;
}
------------------------
Find a silently evolved API code:android.widget.ImageView.setImageResourceAsync:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide *
 */

Body of Frist Method:
{
    return new ImageDrawableCallback(getContext().getDrawable(resId), null, resId);
}
Body of Second Method:
{
    Drawable d = null;
    if (resId != 0) {
        try {
            d = getContext().getDrawable(resId);
        } catch (Exception e) {
            Log.w(LOG_TAG, "Unable to find resource: " + resId, e);
            resId = 0;
        }
    }
    return new ImageDrawableCallback(d, null, resId);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.writeDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT, AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.addValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Add new stats entry, copying from given {@link Entry}. The {@link Entry}
 * object can be recycled across multiple calls.
 */

Body of Frist Method:
{
    if (size >= capacity) {
        final int newLength = Math.max(size, 10) * 3 / 2;
        iface = Arrays.copyOf(iface, newLength);
        uid = Arrays.copyOf(uid, newLength);
        set = Arrays.copyOf(set, newLength);
        tag = Arrays.copyOf(tag, newLength);
        roaming = Arrays.copyOf(roaming, newLength);
        rxBytes = Arrays.copyOf(rxBytes, newLength);
        rxPackets = Arrays.copyOf(rxPackets, newLength);
        txBytes = Arrays.copyOf(txBytes, newLength);
        txPackets = Arrays.copyOf(txPackets, newLength);
        operations = Arrays.copyOf(operations, newLength);
        capacity = newLength;
    }
    iface[size] = entry.iface;
    uid[size] = entry.uid;
    set[size] = entry.set;
    tag[size] = entry.tag;
    roaming[size] = entry.roaming;
    rxBytes[size] = entry.rxBytes;
    rxPackets[size] = entry.rxPackets;
    txBytes[size] = entry.txBytes;
    txPackets[size] = entry.txPackets;
    operations[size] = entry.operations;
    size++;
    return this;
}
Body of Second Method:
{
    if (size >= capacity) {
        final int newLength = Math.max(size, 10) * 3 / 2;
        iface = Arrays.copyOf(iface, newLength);
        uid = Arrays.copyOf(uid, newLength);
        set = Arrays.copyOf(set, newLength);
        tag = Arrays.copyOf(tag, newLength);
        metered = Arrays.copyOf(metered, newLength);
        roaming = Arrays.copyOf(roaming, newLength);
        rxBytes = Arrays.copyOf(rxBytes, newLength);
        rxPackets = Arrays.copyOf(rxPackets, newLength);
        txBytes = Arrays.copyOf(txBytes, newLength);
        txPackets = Arrays.copyOf(txPackets, newLength);
        operations = Arrays.copyOf(operations, newLength);
        capacity = newLength;
    }
    iface[size] = entry.iface;
    uid[size] = entry.uid;
    set[size] = entry.set;
    tag[size] = entry.tag;
    metered[size] = entry.metered;
    roaming[size] = entry.roaming;
    rxBytes[size] = entry.rxBytes;
    rxPackets[size] = entry.rxPackets;
    txBytes[size] = entry.txBytes;
    txPackets[size] = entry.txPackets;
    operations[size] = entry.operations;
    size++;
    return this;
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.NfcFCardEmulation.isValidNfcid2:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (nfcid2 == null) {
        return false;
    }
    if (nfcid2.length() != 16) {
        Log.e(TAG, "NFCID2 " + nfcid2 + " is not a valid NFCID2.");
        return false;
    }
    // check if the the value starts with "02FE"
    if (!nfcid2.toUpperCase().startsWith("02FE")) {
        Log.e(TAG, "NFCID2 " + nfcid2 + " is not a valid NFCID2.");
        return false;
    }
    try {
        Long.valueOf(nfcid2, 16);
    } catch (NumberFormatException e) {
        Log.e(TAG, "NFCID2 " + nfcid2 + " is not a valid NFCID2.");
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (nfcid2 == null) {
        return false;
    }
    if (nfcid2.length() != 16) {
        Log.e(TAG, "NFCID2 " + nfcid2 + " is not a valid NFCID2.");
        return false;
    }
    // check if the the value starts with "02FE"
    if (!nfcid2.toUpperCase().startsWith("02FE")) {
        Log.e(TAG, "NFCID2 " + nfcid2 + " is not a valid NFCID2.");
        return false;
    }
    try {
        Long.parseLong(nfcid2, 16);
    } catch (NumberFormatException e) {
        Log.e(TAG, "NFCID2 " + nfcid2 + " is not a valid NFCID2.");
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.measureHorizontal:COMMENT
Method Modifier: default     
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #HORIZONTAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

Body of Frist Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    boolean skippedMeasure = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    int usedExcessSpace = 0;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.width == 0 && lp.weight > 0;
        if (widthMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // later if we have space to distribute.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeWidthSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.UNSPECIFIED);
                final int freeHeightSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.UNSPECIFIED);
                child.measure(freeWidthSpec, freeHeightSpec);
            } else {
                skippedMeasure = true;
            }
        } else {
            if (useExcessSpace) {
                // The widthMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal width. We'll restore the original width of 0
                // after measurement.
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedWidth = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, usedWidth, heightMeasureSpec, 0);
            final int childWidth = child.getMeasuredWidth();
            if (useExcessSpace) {
                // Restore the original width and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.width = 0;
                usedExcessSpace += childWidth;
            }
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = widthSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : usedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childWidth;
                if (mUseLargestChild && widthMode != MeasureSpec.EXACTLY) {
                    childWidth = largestChildWidth;
                } else if (lp.width == 0 && (!mAllowInconsistentMeasurement || widthMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childWidth = share;
                } else {
                    // This child had some intrinsic width to which we
                    // need to add its share of excess space.
                    childWidth = child.getMeasuredWidth() + share;
                }
                final int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childWidth), MeasureSpec.EXACTLY);
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
Body of Second Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    boolean skippedMeasure = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    int usedExcessSpace = 0;
    int nonSkippedChildCount = 0;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        nonSkippedChildCount++;
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.width == 0 && lp.weight > 0;
        if (widthMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // later if we have space to distribute.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeWidthSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.UNSPECIFIED);
                final int freeHeightSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.UNSPECIFIED);
                child.measure(freeWidthSpec, freeHeightSpec);
            } else {
                skippedMeasure = true;
            }
        } else {
            if (useExcessSpace) {
                // The widthMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal width. We'll restore the original width of 0
                // after measurement.
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedWidth = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, usedWidth, heightMeasureSpec, 0);
            final int childWidth = child.getMeasuredWidth();
            if (useExcessSpace) {
                // Restore the original width and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.width = 0;
                usedExcessSpace += childWidth;
            }
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (nonSkippedChildCount > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = widthSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : usedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childWidth;
                if (mUseLargestChild && widthMode != MeasureSpec.EXACTLY) {
                    childWidth = largestChildWidth;
                } else if (lp.width == 0 && (!mAllowInconsistentMeasurement || widthMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childWidth = share;
                } else {
                    // This child had some intrinsic width to which we
                    // need to add its share of excess space.
                    childWidth = child.getMeasuredWidth() + share;
                }
                final int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childWidth), MeasureSpec.EXACTLY);
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.transform:COMMENT
Method Modifier: public      final       
Comment:/**
 * Applies a transformation matrix to all of the points in the event.
 *
 * @param matrix The transformation matrix to apply.
 */

Body of Frist Method:
{
    if (matrix == null) {
        throw new IllegalArgumentException("matrix must not be null");
    }
    nativeTransform(mNativePtr, matrix);
}
Body of Second Method:
{
    if (matrix == null) {
        throw new IllegalArgumentException("matrix must not be null");
    }
    nativeTransform(mNativePtr, matrix.native_instance);
}
------------------------
Find a silently evolved API code:android.hardware.location.ContextHubManager.findNanoAppOnHub:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Find a specified nano app on the system
 *
 * @param hubHandle handle of hub to search for nano app
 * @param filter filter specifying the search criteria for app
 *
 * @see NanoAppFilter
 *
 * @return int[] Array of handles to any found nano apps
 */

Body of Frist Method:
{
    int[] retVal = null;
    try {
        retVal = getBinder().findNanoAppOnHub(hubHandle, filter);
    } catch (RemoteException e) {
        Log.w(TAG, "Could not query nanoApp instance :" + e);
    }
    return retVal;
}
Body of Second Method:
{
    try {
        return mService.findNanoAppOnHub(hubHandle, filter);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.preference.PreferenceActivity.hasHeaders:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if this activity is currently showing the header list.
 */

Body of Frist Method:
{
    return getListView().getVisibility() == View.VISIBLE && mPreferenceManager == null;
}
Body of Second Method:
{
    return mHeadersContainer != null && mHeadersContainer.getVisibility() == View.VISIBLE;
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.setRingbackRequested:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Asks Telecom to start or stop a ringback tone for a call.
 *
 * @param callId The unique ID of the call whose ringback is being changed.
 * @param ringback Whether Telecom should start playing a ringback tone.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setRingbackRequested(callId, ringback);
        } catch (RemoteException e) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setRingbackRequested(callId, ringback, Log.getExternalSession());
        } catch (RemoteException e) {
        }
    }
}
------------------------
Find a silently evolved API code:android.provider.DocumentsContract.renameDocument:COMMENT
Method Modifier: public      static      
Comment:/**
 * Change the display name of an existing document.
 * <p>
 * If the underlying provider needs to create a new
 * {@link Document#COLUMN_DOCUMENT_ID} to represent the updated display
 * name, that new document is returned and the original document is no
 * longer valid. Otherwise, the original document is returned.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_RENAME}
 * @param displayName updated name for document
 * @return the existing or new document after the rename, or {@code null} if
 * failed.
 */

Body of Frist Method:
{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return renameDocument(client, documentUri, displayName);
    } catch (Exception e) {
        Log.w(TAG, "Failed to rename document", e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}
Body of Second Method:
{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return renameDocument(client, documentUri, displayName);
    } catch (Exception e) {
        Log.w(TAG, "Failed to rename document", e);
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path.quadTo:COMMENT
Method Modifier: public      
Comment:/**
 * Add a quadratic bezier from the last point, approaching control point
 * (x1,y1), and ending at (x2,y2). If no moveTo() call has been made for
 * this contour, the first point is automatically set to (0,0).
 *
 * @param x1 The x-coordinate of the control point on a quadratic curve
 * @param y1 The y-coordinate of the control point on a quadratic curve
 * @param x2 The x-coordinate of the end point on a quadratic curve
 * @param y2 The y-coordinate of the end point on a quadratic curve
 */

Body of Frist Method:
{
    isSimplePath = false;
    native_quadTo(mNativePath, x1, y1, x2, y2);
}
Body of Second Method:
{
    isSimplePath = false;
    nQuadTo(mNativePath, x1, y1, x2, y2);
}
------------------------
Find a silently evolved API code:android.nfc.NdefRecord.getByteLength:COMMENT
Method Modifier: default     
Comment:/**
 * Get byte length of serialized record.
 */

Body of Frist Method:
{
    int length = 3 + mType.length + mId.length + mPayload.length;
    boolean sr = mPayload.length < 256;
    boolean il = mId.length > 0;
    if (!sr)
        length += 3;
    if (il)
        length += 1;
    return length;
}
Body of Second Method:
{
    int length = 3 + mType.length + mId.length + mPayload.length;
    boolean sr = mPayload.length < 256;
    boolean il = mTnf == TNF_EMPTY ? true : mId.length > 0;
    if (!sr)
        length += 3;
    if (il)
        length += 1;
    return length;
}
------------------------
Find a silently evolved API code:android.graphics.Path.addArc:COMMENT
Method Modifier: public      
Comment:/**
 * Add the specified arc to the path as a new contour.
 *
 * @param startAngle Starting angle (in degrees) where the arc begins
 * @param sweepAngle Sweep angle (in degrees) measured clockwise
 */

Body of Frist Method:
{
    isSimplePath = false;
    native_addArc(mNativePath, left, top, right, bottom, startAngle, sweepAngle);
}
Body of Second Method:
{
    isSimplePath = false;
    nAddArc(mNativePath, left, top, right, bottom, startAngle, sweepAngle);
}
------------------------
Find a silently evolved API code:android.preference.Preference.onBindView:COMMENT
Method Modifier: protected   
Comment:/**
 * Binds the created View to the data for this Preference.
 * <p>
 * This is a good place to grab references to custom Views in the layout and
 * set properties on them.
 * <p>
 * Make sure to call through to the superclass's implementation.
 *
 * @param view The View that shows this Preference.
 * @see #onCreateView(ViewGroup)
 */

Body of Frist Method:
{
    final TextView titleView = (TextView) view.findViewById(com.android.internal.R.id.title);
    if (titleView != null) {
        final CharSequence title = getTitle();
        if (!TextUtils.isEmpty(title)) {
            titleView.setText(title);
            titleView.setVisibility(View.VISIBLE);
        } else {
            titleView.setVisibility(View.GONE);
        }
    }
    final TextView summaryView = (TextView) view.findViewById(com.android.internal.R.id.summary);
    if (summaryView != null) {
        final CharSequence summary = getSummary();
        if (!TextUtils.isEmpty(summary)) {
            summaryView.setText(summary);
            summaryView.setVisibility(View.VISIBLE);
        } else {
            summaryView.setVisibility(View.GONE);
        }
    }
    final ImageView imageView = (ImageView) view.findViewById(com.android.internal.R.id.icon);
    if (imageView != null) {
        if (mIconResId != 0 || mIcon != null) {
            if (mIcon == null) {
                mIcon = getContext().getDrawable(mIconResId);
            }
            if (mIcon != null) {
                imageView.setImageDrawable(mIcon);
            }
        }
        imageView.setVisibility(mIcon != null ? View.VISIBLE : View.GONE);
    }
    final View imageFrame = view.findViewById(com.android.internal.R.id.icon_frame);
    if (imageFrame != null) {
        imageFrame.setVisibility(mIcon != null ? View.VISIBLE : View.GONE);
    }
    if (mShouldDisableView) {
        setEnabledStateOnViews(view, isEnabled());
    }
}
Body of Second Method:
{
    final TextView titleView = (TextView) view.findViewById(com.android.internal.R.id.title);
    if (titleView != null) {
        final CharSequence title = getTitle();
        if (!TextUtils.isEmpty(title)) {
            titleView.setText(title);
            titleView.setVisibility(View.VISIBLE);
            if (mHasSingleLineTitleAttr) {
                titleView.setSingleLine(mSingleLineTitle);
            }
        } else {
            titleView.setVisibility(View.GONE);
        }
    }
    final TextView summaryView = (TextView) view.findViewById(com.android.internal.R.id.summary);
    if (summaryView != null) {
        final CharSequence summary = getSummary();
        if (!TextUtils.isEmpty(summary)) {
            summaryView.setText(summary);
            summaryView.setVisibility(View.VISIBLE);
        } else {
            summaryView.setVisibility(View.GONE);
        }
    }
    final ImageView imageView = (ImageView) view.findViewById(com.android.internal.R.id.icon);
    if (imageView != null) {
        if (mIconResId != 0 || mIcon != null) {
            if (mIcon == null) {
                mIcon = getContext().getDrawable(mIconResId);
            }
            if (mIcon != null) {
                imageView.setImageDrawable(mIcon);
            }
        }
        if (mIcon != null) {
            imageView.setVisibility(View.VISIBLE);
        } else {
            imageView.setVisibility(mIconSpaceReserved ? View.INVISIBLE : View.GONE);
        }
    }
    final View imageFrame = view.findViewById(com.android.internal.R.id.icon_frame);
    if (imageFrame != null) {
        if (mIcon != null) {
            imageFrame.setVisibility(View.VISIBLE);
        } else {
            imageFrame.setVisibility(mIconSpaceReserved ? View.INVISIBLE : View.GONE);
        }
    }
    if (mShouldDisableView) {
        setEnabledStateOnViews(view, isEnabled());
    }
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.setVideoState:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Sets the video state associated with a call.
 *
 * Valid values: {@link VideoProfile#STATE_BIDIRECTIONAL},
 * {@link VideoProfile#STATE_AUDIO_ONLY},
 * {@link VideoProfile#STATE_TX_ENABLED},
 * {@link VideoProfile#STATE_RX_ENABLED}.
 *
 * @param callId The unique ID of the call to set the video state for.
 * @param videoState The video state.
 */

Body of Frist Method:
{
    Log.v(this, "setVideoState: %d", videoState);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setVideoState(callId, videoState);
        } catch (RemoteException ignored) {
        }
    }
}
Body of Second Method:
{
    Log.v(this, "setVideoState: %d", videoState);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setVideoState(callId, videoState, Log.getExternalSession());
        } catch (RemoteException ignored) {
        }
    }
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.onConfigureWindow:COMMENT
Method Modifier: public      
Comment:/**
 * Update the given window's parameters for the given mode.  This is called
 * when the window is first displayed and each time the fullscreen or
 * candidates only mode changes.
 *
 * <p>The default implementation makes the layout for the window
 * MATCH_PARENT x MATCH_PARENT when in fullscreen mode, and
 * MATCH_PARENT x WRAP_CONTENT when in non-fullscreen mode.
 *
 * @param win The input method's window.
 * @param isFullscreen If true, the window is running in fullscreen mode
 * and intended to cover the entire application display.
 * @param isCandidatesOnly If true, the window is only showing the
 * candidates view and none of the rest of its UI.  This is mutually
 * exclusive with fullscreen mode.
 */

Body of Frist Method:
{
    final int currentHeight = mWindow.getWindow().getAttributes().height;
    final int newHeight = isFullscreen ? MATCH_PARENT : WRAP_CONTENT;
    if (mIsInputViewShown && currentHeight != newHeight) {
        Log.w(TAG, "Window size has been changed. This may cause jankiness of resizing window: " + currentHeight + " -> " + newHeight);
    }
    mWindow.getWindow().setLayout(MATCH_PARENT, newHeight);
}
Body of Second Method:
{
    final int currentHeight = mWindow.getWindow().getAttributes().height;
    final int newHeight = isFullscreen ? MATCH_PARENT : WRAP_CONTENT;
    if (mIsInputViewShown && currentHeight != newHeight) {
        if (DEBUG) {
            Log.w(TAG, "Window size has been changed. This may cause jankiness of resizing " + "window: " + currentHeight + " -> " + newHeight);
        }
    }
    mWindow.getWindow().setLayout(MATCH_PARENT, newHeight);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.takePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(uri, "uri");
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "uri");
    try {
        ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.createScaledBitmap:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a new bitmap, scaled from an existing bitmap, when possible. If the
 * specified width and height are the same as the current width and height of
 * the source bitmap, the source bitmap is returned and no new bitmap is
 * created.
 *
 * @param src       The source bitmap.
 * @param dstWidth  The new bitmap's desired width.
 * @param dstHeight The new bitmap's desired height.
 * @param filter    true if the source should be filtered.
 * @return The new scaled bitmap or the source bitmap if no scaling is required.
 * @throws IllegalArgumentException if width is <= 0, or height is <= 0
 */

Body of Frist Method:
{
    Matrix m;
    synchronized (Bitmap.class) {
        // small pool of just 1 matrix
        m = sScaleMatrix;
        sScaleMatrix = null;
    }
    if (m == null) {
        m = new Matrix();
    }
    final int width = src.getWidth();
    final int height = src.getHeight();
    final float sx = dstWidth / (float) width;
    final float sy = dstHeight / (float) height;
    m.setScale(sx, sy);
    Bitmap b = Bitmap.createBitmap(src, 0, 0, width, height, m, filter);
    synchronized (Bitmap.class) {
        // do we need to check for null? why not just assign everytime?
        if (sScaleMatrix == null) {
            sScaleMatrix = m;
        }
    }
    return b;
}
Body of Second Method:
{
    Matrix m = new Matrix();
    final int width = src.getWidth();
    final int height = src.getHeight();
    if (width != dstWidth || height != dstHeight) {
        final float sx = dstWidth / (float) width;
        final float sy = dstHeight / (float) height;
        m.setScale(sx, sy);
    }
    return Bitmap.createBitmap(src, 0, 0, width, height, m, filter);
}
------------------------
Find a silently evolved API code:android.graphics.Matrix.setTranslate:COMMENT
Method Modifier: public      
Comment:/**
 * Set the matrix to translate by (dx, dy).
 */

Body of Frist Method:
{
    native_setTranslate(native_instance, dx, dy);
}
Body of Second Method:
{
    nSetTranslate(native_instance, dx, dy);
}
------------------------
Find a silently evolved API code:android.media.PlayerBase.baseRelease:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * To be called from a subclass release or finalize method.
 * Releases AppOps related resources.
 */

Body of Frist Method:
{
    try {
        mAppOps.stopWatchingMode(mAppOpsCallback);
    } catch (RemoteException e) {
    // nothing to do here, the object is supposed to be released anyway
    }
}
Body of Second Method:
{
    if (DEBUG) {
        Log.v(TAG, "baseRelease() piid=" + mPlayerIId + " state=" + mState);
    }
    try {
        synchronized (mLock) {
            if (mState != AudioPlaybackConfiguration.PLAYER_STATE_RELEASED) {
                getService().releasePlayer(mPlayerIId);
                mState = AudioPlaybackConfiguration.PLAYER_STATE_RELEASED;
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, the player will still be tracked", e);
    }
    try {
        if (mAppOps != null) {
            mAppOps.stopWatchingMode(mAppOpsCallback);
        }
    } catch (Exception e) {
    // nothing to do here, the object is supposed to be released anyway
    }
}
------------------------
Find a silently evolved API code:android.content.ClipDescription.toShortStringTypesOnly:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    boolean first = true;
    for (int i = 0; i < mMimeTypes.length; i++) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append(mMimeTypes[i]);
    }
    return !first;
}
Body of Second Method:
{
    boolean first = true;
    final int size = mMimeTypes.size();
    for (int i = 0; i < size; i++) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append(mMimeTypes.get(i));
    }
    return !first;
}
------------------------
Find a silently evolved API code:android.net.NetworkCapabilities.maybeMarkCapabilitiesRestricted:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes the NET_CAPABILITY_NOT_RESTRICTED capability if all the capabilities it provides are
 * typically provided by restricted networks.
 *
 * TODO: consider:
 * - Renaming it to guessRestrictedCapability and make it set the
 * restricted capability bit in addition to clearing it.
 * @hide
 */

Body of Frist Method:
{
    // network is restricted.
    if ((mNetworkCapabilities & ~(DEFAULT_CAPABILITIES | RESTRICTED_CAPABILITIES)) == 0 && // internet-less network will get marked restricted.
    (mNetworkCapabilities & RESTRICTED_CAPABILITIES) != 0) {
        removeCapability(NET_CAPABILITY_NOT_RESTRICTED);
    }
}
Body of Second Method:
{
    // Verify there aren't any unrestricted capabilities.  If there are we say
    // the whole thing is unrestricted.
    final boolean hasUnrestrictedCapabilities = ((mNetworkCapabilities & UNRESTRICTED_CAPABILITIES) != 0);
    // Must have at least some restricted capabilities.
    final boolean hasRestrictedCapabilities = ((mNetworkCapabilities & RESTRICTED_CAPABILITIES) != 0);
    if (hasRestrictedCapabilities && !hasUnrestrictedCapabilities) {
        removeCapability(NET_CAPABILITY_NOT_RESTRICTED);
    }
}
------------------------
Find a silently evolved API code:android.app.TabActivity.onContentChanged:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Updates the screen state (current list and other views) when the
 * content changes.
 *
 * @see Activity#onContentChanged()
 */

Body of Frist Method:
{
    super.onContentChanged();
    mTabHost = (TabHost) findViewById(com.android.internal.R.id.tabhost);
    if (mTabHost == null) {
        throw new RuntimeException("Your content must have a TabHost whose id attribute is " + "'android.R.id.tabhost'");
    }
    mTabHost.setup(getLocalActivityManager());
}
Body of Second Method:
{
    super.onContentChanged();
    mTabHost = findViewById(com.android.internal.R.id.tabhost);
    if (mTabHost == null) {
        throw new RuntimeException("Your content must have a TabHost whose id attribute is " + "'android.R.id.tabhost'");
    }
    mTabHost.setup(getLocalActivityManager());
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.ScanData.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (mResults != null) {
        dest.writeInt(mId);
        dest.writeInt(mFlags);
        dest.writeInt(mBucketsScanned);
        dest.writeInt(mResults.length);
        for (int i = 0; i < mResults.length; i++) {
            ScanResult result = mResults[i];
            result.writeToParcel(dest, flags);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (mResults != null) {
        dest.writeInt(mId);
        dest.writeInt(mFlags);
        dest.writeInt(mBucketsScanned);
        dest.writeInt(mAllChannelsScanned ? 1 : 0);
        dest.writeInt(mResults.length);
        for (int i = 0; i < mResults.length; i++) {
            ScanResult result = mResults[i];
            result.writeToParcel(dest, flags);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.animation.AnimatorInflater.parseAnimatorFromTypeArray:COMMENT
Method Modifier: private     static      
Comment:/**
 * @param anim The animator, must not be null
 * @param arrayAnimator Incoming typed array for Animator's attributes.
 * @param arrayObjectAnimator Incoming typed array for Object Animator's
 * attributes.
 * @param pixelSize The relative pixel size, used to calculate the
 * maximum error for path animations.
 */

Body of Frist Method:
{
    long duration = arrayAnimator.getInt(R.styleable.Animator_duration, 300);
    long startDelay = arrayAnimator.getInt(R.styleable.Animator_startOffset, 0);
    int valueType = arrayAnimator.getInt(R.styleable.Animator_valueType, VALUE_TYPE_UNDEFINED);
    if (valueType == VALUE_TYPE_UNDEFINED) {
        valueType = inferValueTypeFromValues(arrayAnimator, R.styleable.Animator_valueFrom, R.styleable.Animator_valueTo);
    }
    PropertyValuesHolder pvh = getPVH(arrayAnimator, valueType, R.styleable.Animator_valueFrom, R.styleable.Animator_valueTo, "");
    if (pvh != null) {
        anim.setValues(pvh);
    }
    anim.setDuration(duration);
    anim.setStartDelay(startDelay);
    if (arrayAnimator.hasValue(R.styleable.Animator_repeatCount)) {
        anim.setRepeatCount(arrayAnimator.getInt(R.styleable.Animator_repeatCount, 0));
    }
    if (arrayAnimator.hasValue(R.styleable.Animator_repeatMode)) {
        anim.setRepeatMode(arrayAnimator.getInt(R.styleable.Animator_repeatMode, ValueAnimator.RESTART));
    }
    if (arrayObjectAnimator != null) {
        setupObjectAnimator(anim, arrayObjectAnimator, valueType == VALUE_TYPE_FLOAT, pixelSize);
    }
}
Body of Second Method:
{
    long duration = arrayAnimator.getInt(R.styleable.Animator_duration, 300);
    long startDelay = arrayAnimator.getInt(R.styleable.Animator_startOffset, 0);
    int valueType = arrayAnimator.getInt(R.styleable.Animator_valueType, VALUE_TYPE_UNDEFINED);
    if (valueType == VALUE_TYPE_UNDEFINED) {
        valueType = inferValueTypeFromValues(arrayAnimator, R.styleable.Animator_valueFrom, R.styleable.Animator_valueTo);
    }
    PropertyValuesHolder pvh = getPVH(arrayAnimator, valueType, R.styleable.Animator_valueFrom, R.styleable.Animator_valueTo, "");
    if (pvh != null) {
        anim.setValues(pvh);
    }
    anim.setDuration(duration);
    anim.setStartDelay(startDelay);
    if (arrayAnimator.hasValue(R.styleable.Animator_repeatCount)) {
        anim.setRepeatCount(arrayAnimator.getInt(R.styleable.Animator_repeatCount, 0));
    }
    if (arrayAnimator.hasValue(R.styleable.Animator_repeatMode)) {
        anim.setRepeatMode(arrayAnimator.getInt(R.styleable.Animator_repeatMode, ValueAnimator.RESTART));
    }
    if (arrayObjectAnimator != null) {
        setupObjectAnimator(anim, arrayObjectAnimator, valueType, pixelSize);
    }
}
------------------------
Find a silently evolved API code:android.text.method.BaseKeyListener.getOffsetForBackspaceKey:COMMENT
Method Modifier: private     static      
Comment:// Returns the start offset to be deleted by a backspace key from the given offset.

Body of Frist Method:
{
    if (offset <= 1) {
        return 0;
    }
    // Initial state
    final int STATE_START = 0;
    // The offset is immediately before line feed.
    final int STATE_LF = 1;
    // The offset is immediately before a KEYCAP.
    final int STATE_BEFORE_KEYCAP = 2;
    // The offset is immediately before a variation selector and a KEYCAP.
    final int STATE_BEFORE_VS_AND_KEYCAP = 3;
    // The offset is immediately before an emoji modifier.
    final int STATE_BEFORE_EMOJI_MODIFIER = 4;
    // The offset is immediately before a variation selector and an emoji modifier.
    final int STATE_BEFORE_VS_AND_EMOJI_MODIFIER = 5;
    // The offset is immediately before a variation selector.
    final int STATE_BEFORE_VS = 6;
    // The offset is immediately before an emoji.
    final int STATE_BEFORE_EMOJI = 7;
    // The offset is immediately before a ZWJ that were seen before a ZWJ emoji.
    final int STATE_BEFORE_ZWJ = 8;
    // The offset is immediately before a variation selector and a ZWJ that were seen before a
    // ZWJ emoji.
    final int STATE_BEFORE_VS_AND_ZWJ = 9;
    // The number of following RIS code points is odd.
    final int STATE_ODD_NUMBERED_RIS = 10;
    // The number of following RIS code points is even.
    final int STATE_EVEN_NUMBERED_RIS = 11;
    // The state machine has been stopped.
    final int STATE_FINISHED = 12;
    // Char count to be deleted by backspace.
    int deleteCharCount = 0;
    // Char count of previous variation selector.
    int lastSeenVSCharCount = 0;
    int state = STATE_START;
    int tmpOffset = offset;
    do {
        final int codePoint = Character.codePointBefore(text, tmpOffset);
        tmpOffset -= Character.charCount(codePoint);
        switch(state) {
            case STATE_START:
                deleteCharCount = Character.charCount(codePoint);
                if (codePoint == LINE_FEED) {
                    state = STATE_LF;
                } else if (isVariationSelector(codePoint)) {
                    state = STATE_BEFORE_VS;
                } else if (Emoji.isRegionalIndicatorSymbol(codePoint)) {
                    state = STATE_ODD_NUMBERED_RIS;
                } else if (Emoji.isEmojiModifier(codePoint)) {
                    state = STATE_BEFORE_EMOJI_MODIFIER;
                } else if (codePoint == Emoji.COMBINING_ENCLOSING_KEYCAP) {
                    state = STATE_BEFORE_KEYCAP;
                } else if (Emoji.isEmoji(codePoint)) {
                    state = STATE_BEFORE_EMOJI;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            case STATE_LF:
                if (codePoint == CARRIAGE_RETURN) {
                    ++deleteCharCount;
                }
                state = STATE_FINISHED;
            case STATE_ODD_NUMBERED_RIS:
                if (Emoji.isRegionalIndicatorSymbol(codePoint)) {
                    deleteCharCount += 2;
                    /* Char count of RIS */
                    state = STATE_EVEN_NUMBERED_RIS;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            case STATE_EVEN_NUMBERED_RIS:
                if (Emoji.isRegionalIndicatorSymbol(codePoint)) {
                    deleteCharCount -= 2;
                    /* Char count of RIS */
                    state = STATE_ODD_NUMBERED_RIS;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            case STATE_BEFORE_KEYCAP:
                if (isVariationSelector(codePoint)) {
                    lastSeenVSCharCount = Character.charCount(codePoint);
                    state = STATE_BEFORE_VS_AND_KEYCAP;
                    break;
                }
                if (Emoji.isKeycapBase(codePoint)) {
                    deleteCharCount += Character.charCount(codePoint);
                }
                state = STATE_FINISHED;
                break;
            case STATE_BEFORE_VS_AND_KEYCAP:
                if (Emoji.isKeycapBase(codePoint)) {
                    deleteCharCount += lastSeenVSCharCount + Character.charCount(codePoint);
                }
                state = STATE_FINISHED;
                break;
            case STATE_BEFORE_EMOJI_MODIFIER:
                if (isVariationSelector(codePoint)) {
                    lastSeenVSCharCount = Character.charCount(codePoint);
                    state = STATE_BEFORE_VS_AND_EMOJI_MODIFIER;
                    break;
                } else if (Emoji.isEmojiModifierBase(codePoint)) {
                    deleteCharCount += Character.charCount(codePoint);
                }
                state = STATE_FINISHED;
                break;
            case STATE_BEFORE_VS_AND_EMOJI_MODIFIER:
                if (Emoji.isEmojiModifierBase(codePoint)) {
                    deleteCharCount += lastSeenVSCharCount + Character.charCount(codePoint);
                }
                state = STATE_FINISHED;
                break;
            case STATE_BEFORE_VS:
                if (Emoji.isEmoji(codePoint)) {
                    deleteCharCount += Character.charCount(codePoint);
                    state = STATE_BEFORE_EMOJI;
                    break;
                }
                if (!isVariationSelector(codePoint) && UCharacter.getCombiningClass(codePoint) == 0) {
                    deleteCharCount += Character.charCount(codePoint);
                }
                state = STATE_FINISHED;
                break;
            case STATE_BEFORE_EMOJI:
                if (codePoint == Emoji.ZERO_WIDTH_JOINER) {
                    state = STATE_BEFORE_ZWJ;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            case STATE_BEFORE_ZWJ:
                if (Emoji.isEmoji(codePoint)) {
                    // +1 for ZWJ.
                    deleteCharCount += Character.charCount(codePoint) + 1;
                    state = Emoji.isEmojiModifier(codePoint) ? STATE_BEFORE_EMOJI_MODIFIER : STATE_BEFORE_EMOJI;
                } else if (isVariationSelector(codePoint)) {
                    lastSeenVSCharCount = Character.charCount(codePoint);
                    state = STATE_BEFORE_VS_AND_ZWJ;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            case STATE_BEFORE_VS_AND_ZWJ:
                if (Emoji.isEmoji(codePoint)) {
                    // +1 for ZWJ.
                    deleteCharCount += lastSeenVSCharCount + 1 + Character.charCount(codePoint);
                    lastSeenVSCharCount = 0;
                    state = STATE_BEFORE_EMOJI;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            default:
                throw new IllegalArgumentException("state " + state + " is unknown");
        }
    } while (tmpOffset > 0 && state != STATE_FINISHED);
    return adjustReplacementSpan(text, offset - deleteCharCount, true);
}
Body of Second Method:
{
    if (offset <= 1) {
        return 0;
    }
    // Initial state
    final int STATE_START = 0;
    // The offset is immediately before line feed.
    final int STATE_LF = 1;
    // The offset is immediately before a KEYCAP.
    final int STATE_BEFORE_KEYCAP = 2;
    // The offset is immediately before a variation selector and a KEYCAP.
    final int STATE_BEFORE_VS_AND_KEYCAP = 3;
    // The offset is immediately before an emoji modifier.
    final int STATE_BEFORE_EMOJI_MODIFIER = 4;
    // The offset is immediately before a variation selector and an emoji modifier.
    final int STATE_BEFORE_VS_AND_EMOJI_MODIFIER = 5;
    // The offset is immediately before a variation selector.
    final int STATE_BEFORE_VS = 6;
    // The offset is immediately before an emoji.
    final int STATE_BEFORE_EMOJI = 7;
    // The offset is immediately before a ZWJ that were seen before a ZWJ emoji.
    final int STATE_BEFORE_ZWJ = 8;
    // The offset is immediately before a variation selector and a ZWJ that were seen before a
    // ZWJ emoji.
    final int STATE_BEFORE_VS_AND_ZWJ = 9;
    // The number of following RIS code points is odd.
    final int STATE_ODD_NUMBERED_RIS = 10;
    // The number of following RIS code points is even.
    final int STATE_EVEN_NUMBERED_RIS = 11;
    // The offset is in emoji tag sequence.
    final int STATE_IN_TAG_SEQUENCE = 12;
    // The state machine has been stopped.
    final int STATE_FINISHED = 13;
    // Char count to be deleted by backspace.
    int deleteCharCount = 0;
    // Char count of previous variation selector.
    int lastSeenVSCharCount = 0;
    int state = STATE_START;
    int tmpOffset = offset;
    do {
        final int codePoint = Character.codePointBefore(text, tmpOffset);
        tmpOffset -= Character.charCount(codePoint);
        switch(state) {
            case STATE_START:
                deleteCharCount = Character.charCount(codePoint);
                if (codePoint == LINE_FEED) {
                    state = STATE_LF;
                } else if (isVariationSelector(codePoint)) {
                    state = STATE_BEFORE_VS;
                } else if (Emoji.isRegionalIndicatorSymbol(codePoint)) {
                    state = STATE_ODD_NUMBERED_RIS;
                } else if (Emoji.isEmojiModifier(codePoint)) {
                    state = STATE_BEFORE_EMOJI_MODIFIER;
                } else if (codePoint == Emoji.COMBINING_ENCLOSING_KEYCAP) {
                    state = STATE_BEFORE_KEYCAP;
                } else if (Emoji.isEmoji(codePoint)) {
                    state = STATE_BEFORE_EMOJI;
                } else if (codePoint == Emoji.CANCEL_TAG) {
                    state = STATE_IN_TAG_SEQUENCE;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            case STATE_LF:
                if (codePoint == CARRIAGE_RETURN) {
                    ++deleteCharCount;
                }
                state = STATE_FINISHED;
                break;
            case STATE_ODD_NUMBERED_RIS:
                if (Emoji.isRegionalIndicatorSymbol(codePoint)) {
                    deleteCharCount += 2;
                    /* Char count of RIS */
                    state = STATE_EVEN_NUMBERED_RIS;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            case STATE_EVEN_NUMBERED_RIS:
                if (Emoji.isRegionalIndicatorSymbol(codePoint)) {
                    deleteCharCount -= 2;
                    /* Char count of RIS */
                    state = STATE_ODD_NUMBERED_RIS;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            case STATE_BEFORE_KEYCAP:
                if (isVariationSelector(codePoint)) {
                    lastSeenVSCharCount = Character.charCount(codePoint);
                    state = STATE_BEFORE_VS_AND_KEYCAP;
                    break;
                }
                if (Emoji.isKeycapBase(codePoint)) {
                    deleteCharCount += Character.charCount(codePoint);
                }
                state = STATE_FINISHED;
                break;
            case STATE_BEFORE_VS_AND_KEYCAP:
                if (Emoji.isKeycapBase(codePoint)) {
                    deleteCharCount += lastSeenVSCharCount + Character.charCount(codePoint);
                }
                state = STATE_FINISHED;
                break;
            case STATE_BEFORE_EMOJI_MODIFIER:
                if (isVariationSelector(codePoint)) {
                    lastSeenVSCharCount = Character.charCount(codePoint);
                    state = STATE_BEFORE_VS_AND_EMOJI_MODIFIER;
                    break;
                } else if (Emoji.isEmojiModifierBase(codePoint)) {
                    deleteCharCount += Character.charCount(codePoint);
                }
                state = STATE_FINISHED;
                break;
            case STATE_BEFORE_VS_AND_EMOJI_MODIFIER:
                if (Emoji.isEmojiModifierBase(codePoint)) {
                    deleteCharCount += lastSeenVSCharCount + Character.charCount(codePoint);
                }
                state = STATE_FINISHED;
                break;
            case STATE_BEFORE_VS:
                if (Emoji.isEmoji(codePoint)) {
                    deleteCharCount += Character.charCount(codePoint);
                    state = STATE_BEFORE_EMOJI;
                    break;
                }
                if (!isVariationSelector(codePoint) && UCharacter.getCombiningClass(codePoint) == 0) {
                    deleteCharCount += Character.charCount(codePoint);
                }
                state = STATE_FINISHED;
                break;
            case STATE_BEFORE_EMOJI:
                if (codePoint == Emoji.ZERO_WIDTH_JOINER) {
                    state = STATE_BEFORE_ZWJ;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            case STATE_BEFORE_ZWJ:
                if (Emoji.isEmoji(codePoint)) {
                    // +1 for ZWJ.
                    deleteCharCount += Character.charCount(codePoint) + 1;
                    state = Emoji.isEmojiModifier(codePoint) ? STATE_BEFORE_EMOJI_MODIFIER : STATE_BEFORE_EMOJI;
                } else if (isVariationSelector(codePoint)) {
                    lastSeenVSCharCount = Character.charCount(codePoint);
                    state = STATE_BEFORE_VS_AND_ZWJ;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            case STATE_BEFORE_VS_AND_ZWJ:
                if (Emoji.isEmoji(codePoint)) {
                    // +1 for ZWJ.
                    deleteCharCount += lastSeenVSCharCount + 1 + Character.charCount(codePoint);
                    lastSeenVSCharCount = 0;
                    state = STATE_BEFORE_EMOJI;
                } else {
                    state = STATE_FINISHED;
                }
                break;
            case STATE_IN_TAG_SEQUENCE:
                if (Emoji.isTagSpecChar(codePoint)) {
                    deleteCharCount += 2;
                /* Char count of emoji tag spec character. */
                // Keep the same state.
                } else if (Emoji.isEmoji(codePoint)) {
                    deleteCharCount += Character.charCount(codePoint);
                    state = STATE_FINISHED;
                } else {
                    // Couldn't find tag_base character. Delete the last tag_term character.
                    // for U+E007F
                    deleteCharCount = 2;
                    state = STATE_FINISHED;
                }
                // TODO: Need handle emoji variation selectors. Issue 35224297
                break;
            default:
                throw new IllegalArgumentException("state " + state + " is unknown");
        }
    } while (tmpOffset > 0 && state != STATE_FINISHED);
    return adjustReplacementSpan(text, offset - deleteCharCount, true);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.readOutOfBandData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Read the local Out of Band Pairing Data
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return Pair<byte[], byte[]> of Hash and Randomizer
 *
 * @hide
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return null;
    /*
        try {
            byte[] hash;
            byte[] randomizer;

            byte[] ret = null;
            mServiceLock.readLock().lock();
            if (mService != null) mService.readOutOfBandData();

            if (ret  == null || ret.length != 32) return null;

            hash = Arrays.copyOfRange(ret, 0, 16);
            randomizer = Arrays.copyOfRange(ret, 16, 32);

            if (DBG) {
                Log.d(TAG, "readOutOfBandData:" + Arrays.toString(hash) +
                  ":" + Arrays.toString(randomizer));
            }
            return new Pair<byte[], byte[]>(hash, randomizer);

        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        } finally {
            mServiceLock.readLock().unlock();
        }
        */
    return null;
}
Body of Second Method:
{
    return null;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.getTag:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Convert a key string into the equivalent native tag.
 *
 * @throws IllegalArgumentException if the key was not recognized
 * @throws NullPointerException if the key was null
 *
 * @hide
 */

Body of Frist Method:
{
    return nativeGetTagFromKey(key);
}
Body of Second Method:
{
    return nativeGetTagFromKey(key, vendorId);
}
------------------------
Find a silently evolved API code:android.transition.Fade.createAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Utility method to handle creating and running the Animator.
 */

Body of Frist Method:
{
    if (startAlpha == endAlpha) {
        return null;
    }
    view.setTransitionAlpha(startAlpha);
    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", endAlpha);
    if (DBG) {
        Log.d(LOG_TAG, "Created animator " + anim);
    }
    final FadeAnimatorListener listener = new FadeAnimatorListener(view);
    anim.addListener(listener);
    addListener(new TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            view.setTransitionAlpha(1);
        }
    });
    return anim;
}
Body of Second Method:
{
    if (startAlpha == endAlpha) {
        return null;
    }
    view.setTransitionAlpha(startAlpha);
    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", endAlpha);
    if (DBG) {
        Log.d(LOG_TAG, "Created animator " + anim);
    }
    final FadeAnimatorListener listener = new FadeAnimatorListener(view);
    anim.addListener(listener);
    addListener(new TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            view.setTransitionAlpha(1);
            transition.removeListener(this);
        }
    });
    return anim;
}
------------------------
Find a silently evolved API code:android.net.Network.maybeInitHttpClient:COMMENT
Method Modifier: private     
Comment:// out) ConnectionPools.

Body of Frist Method:
{
    synchronized (mLock) {
        if (mNetwork == null) {
            mNetwork = new com.android.okhttp.internal.Network() {

                @Override
                public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
                    return Network.this.getAllByName(host);
                }
            };
        }
        if (mConnectionPool == null) {
            mConnectionPool = new ConnectionPool(httpMaxConnections, httpKeepAliveDurationMs);
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (mDns == null) {
            mDns = new Dns() {

                @Override
                public List<InetAddress> lookup(String hostname) throws UnknownHostException {
                    return Arrays.asList(Network.this.getAllByName(hostname));
                }
            };
        }
        if (mConnectionPool == null) {
            mConnectionPool = new ConnectionPool(httpMaxConnections, httpKeepAliveDurationMs, TimeUnit.MILLISECONDS);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.setCurrentSpellChecker:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        if (sci == null) {
            throw new NullPointerException("SpellCheckerInfo is null.");
        }
        sService.setCurrentSpellChecker(null, sci.getId());
    } catch (RemoteException e) {
        Log.e(TAG, "Error in setCurrentSpellChecker: " + e);
    }
}
Body of Second Method:
{
    try {
        if (sci == null) {
            throw new NullPointerException("SpellCheckerInfo is null.");
        }
        mService.setCurrentSpellChecker(null, sci.getId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Matrix.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Set the matrix to identity
 */

Body of Frist Method:
{
    native_reset(native_instance);
}
Body of Second Method:
{
    nReset(native_instance);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.closeProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */

Body of Frist Method:
{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
    }
}
Body of Second Method:
{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.INPUT_HOST:
            BluetoothInputHost iHost = (BluetoothInputHost) proxy;
            iHost.close();
            break;
    }
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfEditor.getPageCropBox:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the crop box of a given page in mils (1/72").
 *
 * @param pageIndex The page index.
 * @param outCropBox The crop box output.
 */

Body of Frist Method:
{
    throwIfClosed();
    throwIfOutCropBoxNull(outCropBox);
    throwIfPageNotInDocument(pageIndex);
    return nativeGetPageCropBox(mNativeDocument, pageIndex, outCropBox);
}
Body of Second Method:
{
    throwIfClosed();
    throwIfOutCropBoxNull(outCropBox);
    throwIfPageNotInDocument(pageIndex);
    synchronized (PdfRenderer.sPdfiumLock) {
        return nativeGetPageCropBox(mNativeDocument, pageIndex, outCropBox);
    }
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.addConferenceCall:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Indicates that a new conference call has been created.
 *
 * @param callId The unique ID of the conference call.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.addConferenceCall(callId, parcelableConference);
        } catch (RemoteException ignored) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.addConferenceCall(callId, parcelableConference, Log.getExternalSession());
        } catch (RemoteException ignored) {
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isMasterMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * get master mute state.
 *
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.isMasterMute();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.isMasterMute();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.dump:COMMENT
Method Modifier: protected   
Comment:/**
 * Performs a dump of the InputMethodService's internal state.  Override
 * to add your own information to the dump.
 */

Body of Frist Method:
{
    final Printer p = new PrintWriterPrinter(fout);
    p.println("Input method service state for " + this + ":");
    p.println("  mWindowCreated=" + mWindowCreated + " mWindowAdded=" + mWindowAdded);
    p.println("  mWindowVisible=" + mWindowVisible + " mWindowWasVisible=" + mWindowWasVisible + " mInShowWindow=" + mInShowWindow);
    p.println("  Configuration=" + getResources().getConfiguration());
    p.println("  mToken=" + mToken);
    p.println("  mInputBinding=" + mInputBinding);
    p.println("  mInputConnection=" + mInputConnection);
    p.println("  mStartedInputConnection=" + mStartedInputConnection);
    p.println("  mInputStarted=" + mInputStarted + " mInputViewStarted=" + mInputViewStarted + " mCandidatesViewStarted=" + mCandidatesViewStarted);
    if (mInputEditorInfo != null) {
        p.println("  mInputEditorInfo:");
        mInputEditorInfo.dump(p, "    ");
    } else {
        p.println("  mInputEditorInfo: null");
    }
    p.println("  mShowInputRequested=" + mShowInputRequested + " mLastShowInputRequested=" + mLastShowInputRequested + " mShowInputFlags=0x" + Integer.toHexString(mShowInputFlags));
    p.println("  mCandidatesVisibility=" + mCandidatesVisibility + " mFullscreenApplied=" + mFullscreenApplied + " mIsFullscreen=" + mIsFullscreen + " mExtractViewHidden=" + mExtractViewHidden);
    if (mExtractedText != null) {
        p.println("  mExtractedText:");
        p.println("    text=" + mExtractedText.text.length() + " chars" + " startOffset=" + mExtractedText.startOffset);
        p.println("    selectionStart=" + mExtractedText.selectionStart + " selectionEnd=" + mExtractedText.selectionEnd + " flags=0x" + Integer.toHexString(mExtractedText.flags));
    } else {
        p.println("  mExtractedText: null");
    }
    p.println("  mExtractedToken=" + mExtractedToken);
    p.println("  mIsInputViewShown=" + mIsInputViewShown + " mStatusIcon=" + mStatusIcon);
    p.println("Last computed insets:");
    p.println("  contentTopInsets=" + mTmpInsets.contentTopInsets + " visibleTopInsets=" + mTmpInsets.visibleTopInsets + " touchableInsets=" + mTmpInsets.touchableInsets + " touchableRegion=" + mTmpInsets.touchableRegion);
    p.println(" mShouldClearInsetOfPreviousIme=" + mShouldClearInsetOfPreviousIme);
    p.println(" mSettingsObserver=" + mSettingsObserver);
}
Body of Second Method:
{
    final Printer p = new PrintWriterPrinter(fout);
    p.println("Input method service state for " + this + ":");
    p.println("  mWindowCreated=" + mWindowCreated + " mWindowAdded=" + mWindowAdded);
    p.println("  mWindowVisible=" + mWindowVisible + " mWindowWasVisible=" + mWindowWasVisible + " mInShowWindow=" + mInShowWindow);
    p.println("  Configuration=" + getResources().getConfiguration());
    p.println("  mToken=" + mToken);
    p.println("  mInputBinding=" + mInputBinding);
    p.println("  mInputConnection=" + mInputConnection);
    p.println("  mStartedInputConnection=" + mStartedInputConnection);
    p.println("  mInputStarted=" + mInputStarted + " mInputViewStarted=" + mInputViewStarted + " mCandidatesViewStarted=" + mCandidatesViewStarted);
    p.println("  mStartInputToken=" + mStartInputToken);
    if (mInputEditorInfo != null) {
        p.println("  mInputEditorInfo:");
        mInputEditorInfo.dump(p, "    ");
    } else {
        p.println("  mInputEditorInfo: null");
    }
    p.println("  mShowInputRequested=" + mShowInputRequested + " mLastShowInputRequested=" + mLastShowInputRequested + " mShowInputFlags=0x" + Integer.toHexString(mShowInputFlags));
    p.println("  mCandidatesVisibility=" + mCandidatesVisibility + " mFullscreenApplied=" + mFullscreenApplied + " mIsFullscreen=" + mIsFullscreen + " mExtractViewHidden=" + mExtractViewHidden);
    if (mExtractedText != null) {
        p.println("  mExtractedText:");
        p.println("    text=" + mExtractedText.text.length() + " chars" + " startOffset=" + mExtractedText.startOffset);
        p.println("    selectionStart=" + mExtractedText.selectionStart + " selectionEnd=" + mExtractedText.selectionEnd + " flags=0x" + Integer.toHexString(mExtractedText.flags));
    } else {
        p.println("  mExtractedText: null");
    }
    p.println("  mExtractedToken=" + mExtractedToken);
    p.println("  mIsInputViewShown=" + mIsInputViewShown + " mStatusIcon=" + mStatusIcon);
    p.println("Last computed insets:");
    p.println("  contentTopInsets=" + mTmpInsets.contentTopInsets + " visibleTopInsets=" + mTmpInsets.visibleTopInsets + " touchableInsets=" + mTmpInsets.touchableInsets + " touchableRegion=" + mTmpInsets.touchableRegion);
    p.println(" mShouldClearInsetOfPreviousIme=" + mShouldClearInsetOfPreviousIme);
    p.println(" mSettingsObserver=" + mSettingsObserver);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getOutgoingPersistedUriPermissions:COMMENT
Method Modifier: public      
Comment:/**
 * Return list of all persisted URI permission grants that are hosted by the
 * calling app. That is, the returned permissions have been granted
 * <em>from</em> the calling app. Only grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getPersistedUriPermissions(mPackageName, false).getList();
    } catch (RemoteException e) {
        throw new RuntimeException("Activity manager has died", e);
    }
}
Body of Second Method:
{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, false).getList();
    } catch (RemoteException e) {
        throw new RuntimeException("Activity manager has died", e);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path.rLineTo:COMMENT
Method Modifier: public      
Comment:/**
 * Same as lineTo, but the coordinates are considered relative to the last
 * point on this contour. If there is no previous point, then a moveTo(0,0)
 * is inserted automatically.
 *
 * @param dx The amount to add to the x-coordinate of the previous point on
 * this contour, to specify a line
 * @param dy The amount to add to the y-coordinate of the previous point on
 * this contour, to specify a line
 */

Body of Frist Method:
{
    isSimplePath = false;
    native_rLineTo(mNativePath, dx, dy);
}
Body of Second Method:
{
    isSimplePath = false;
    nRLineTo(mNativePath, dx, dy);
}
------------------------
Find a silently evolved API code:android.text.method.EditorState.setByString:COMMENT
Method Modifier: public      
Comment:// Setup editor state with string. Please see class description for string format.

Body of Frist Method:
{
    final StringBuilder sb = new StringBuilder();
    int replacementSpanStart = -1;
    int replacementSpanEnd = -1;
    mSelectionStart = -1;
    mSelectionEnd = -1;
    final String[] tokens = string.split(" +");
    for (String token : tokens) {
        if (token.startsWith("'") && token.endsWith("'")) {
            for (int i = 1; i < token.length() - 1; ++i) {
                final char ch = token.charAt(1);
                if (!isGraphicAscii(ch)) {
                    throw new IllegalArgumentException("Only printable characters can be in single quote. " + "Use U+" + Integer.toHexString(ch).toUpperCase() + " instead");
                }
            }
            sb.append(token.substring(1, token.length() - 1));
        } else if (token.startsWith("U+")) {
            final int codePoint = Integer.parseInt(token.substring(2), 16);
            if (codePoint < 0 || 0x10FFFF < codePoint) {
                throw new IllegalArgumentException("Invalid code point is specified:" + token);
            }
            sb.append(Character.toChars(codePoint));
        } else if (token.equals(CURSOR)) {
            if (mSelectionStart != -1 || mSelectionEnd != -1) {
                throw new IllegalArgumentException("Two or more cursor/selection positions are specified.");
            }
            mSelectionStart = mSelectionEnd = sb.length();
        } else if (token.equals(SELECTION_START)) {
            if (mSelectionStart != -1) {
                throw new IllegalArgumentException("Two or more cursor/selection positions are specified.");
            }
            mSelectionStart = sb.length();
        } else if (token.equals(SELECTION_END)) {
            if (mSelectionEnd != -1) {
                throw new IllegalArgumentException("Two or more cursor/selection positions are specified.");
            }
            mSelectionEnd = sb.length();
        } else if (token.equals(REPLACEMENT_SPAN_START)) {
            if (replacementSpanStart != -1) {
                throw new IllegalArgumentException("Only one replacement span is supported");
            }
            replacementSpanStart = sb.length();
        } else if (token.equals(REPLACEMENT_SPAN_END)) {
            if (replacementSpanEnd != -1) {
                throw new IllegalArgumentException("Only one replacement span is supported");
            }
            replacementSpanEnd = sb.length();
        } else {
            throw new IllegalArgumentException("Unknown or invalid token: " + token);
        }
    }
    if (mSelectionStart == -1 || mSelectionEnd == -1) {
        if (mSelectionEnd != -1) {
            throw new IllegalArgumentException("Selection start position doesn't exist.");
        } else if (mSelectionStart != -1) {
            throw new IllegalArgumentException("Selection end position doesn't exist.");
        } else {
            throw new IllegalArgumentException("At least cursor position or selection range must be specified.");
        }
    } else if (mSelectionStart > mSelectionEnd) {
        throw new IllegalArgumentException("Selection start position appears after end position.");
    }
    final Spannable spannable = new SpannableString(sb.toString());
    if (replacementSpanStart != -1 || replacementSpanEnd != -1) {
        if (replacementSpanStart == -1) {
            throw new IllegalArgumentException("ReplacementSpan start position doesn't exist.");
        }
        if (replacementSpanEnd == -1) {
            throw new IllegalArgumentException("ReplacementSpan end position doesn't exist.");
        }
        if (replacementSpanStart > replacementSpanEnd) {
            throw new IllegalArgumentException("ReplacementSpan start position appears after end position.");
        }
        spannable.setSpan(new MockReplacementSpan(), replacementSpanStart, replacementSpanEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
    mText = Editable.Factory.getInstance().newEditable(spannable);
}
Body of Second Method:
{
    final StringBuilder sb = new StringBuilder();
    int replacementSpanStart = -1;
    int replacementSpanEnd = -1;
    mSelectionStart = -1;
    mSelectionEnd = -1;
    final String[] tokens = string.split(" +");
    for (String token : tokens) {
        if (token.startsWith("'") && token.endsWith("'")) {
            for (int i = 1; i < token.length() - 1; ++i) {
                final char ch = token.charAt(1);
                if (!isGraphicAscii(ch)) {
                    throw new IllegalArgumentException("Only printable characters can be in single quote. " + "Use U+" + Integer.toHexString(ch).toUpperCase() + " instead");
                }
            }
            sb.append(token.substring(1, token.length() - 1));
        } else if (token.startsWith("U+")) {
            final int codePoint = Integer.parseInt(token.substring(2), 16);
            if (codePoint < 0 || 0x10FFFF < codePoint) {
                throw new IllegalArgumentException("Invalid code point is specified:" + token);
            }
            sb.append(Character.toChars(codePoint));
        } else if (token.equals(CURSOR)) {
            if (mSelectionStart != -1 || mSelectionEnd != -1) {
                throw new IllegalArgumentException("Two or more cursor/selection positions are specified.");
            }
            mSelectionStart = mSelectionEnd = sb.length();
        } else if (token.equals(SELECTION_START)) {
            if (mSelectionStart != -1) {
                throw new IllegalArgumentException("Two or more cursor/selection positions are specified.");
            }
            mSelectionStart = sb.length();
        } else if (token.equals(SELECTION_END)) {
            if (mSelectionEnd != -1) {
                throw new IllegalArgumentException("Two or more cursor/selection positions are specified.");
            }
            mSelectionEnd = sb.length();
        } else if (token.equals(REPLACEMENT_SPAN_START)) {
            if (replacementSpanStart != -1) {
                throw new IllegalArgumentException("Only one replacement span is supported");
            }
            replacementSpanStart = sb.length();
        } else if (token.equals(REPLACEMENT_SPAN_END)) {
            if (replacementSpanEnd != -1) {
                throw new IllegalArgumentException("Only one replacement span is supported");
            }
            replacementSpanEnd = sb.length();
        } else {
            throw new IllegalArgumentException("Unknown or invalid token: " + token);
        }
    }
    if (mSelectionStart == -1 || mSelectionEnd == -1) {
        if (mSelectionEnd != -1) {
            throw new IllegalArgumentException("Selection start position doesn't exist.");
        } else if (mSelectionStart != -1) {
            throw new IllegalArgumentException("Selection end position doesn't exist.");
        } else {
            throw new IllegalArgumentException("At least cursor position or selection range must be specified.");
        }
    } else if (mSelectionStart > mSelectionEnd) {
        throw new IllegalArgumentException("Selection start position appears after end position.");
    }
    final Spannable spannable = new SpannableString(sb.toString());
    if (replacementSpanStart != -1 || replacementSpanEnd != -1) {
        if (replacementSpanStart == -1) {
            throw new IllegalArgumentException("ReplacementSpan start position doesn't exist.");
        }
        if (replacementSpanEnd == -1) {
            throw new IllegalArgumentException("ReplacementSpan end position doesn't exist.");
        }
        if (replacementSpanStart > replacementSpanEnd) {
            throw new IllegalArgumentException("ReplacementSpan start position appears after end position.");
        }
        ReplacementSpan mockReplacementSpan = mock(ReplacementSpan.class);
        when(mockReplacementSpan.getSize(any(), any(), any(), any(), any())).thenReturn(0);
        doNothing().when(mockReplacementSpan).draw(any(), any(), any(), any(), any(), any(), any(), any(), any());
        spannable.setSpan(mockReplacementSpan, replacementSpanStart, replacementSpanEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
    mText = Editable.Factory.getInstance().newEditable(spannable);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setBluetoothScoOn:COMMENT
Method Modifier: public      
Comment:/**
 * Request use of Bluetooth SCO headset for communications.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param on set <var>true</var> to use bluetooth SCO for communications;
 * <var>false</var> to not use bluetooth SCO for communications
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setBluetoothScoOn(on);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.setBluetoothScoOn(on);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getAllocationByteCount:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the size of the allocated memory used to store this bitmap's pixels.
 *
 * <p>This can be larger than the result of {@link #getByteCount()} if a bitmap is reused to
 * decode other bitmaps of smaller size, or by manual reconfiguration. See {@link
 * #reconfigure(int, int, Config)}, {@link #setWidth(int)}, {@link #setHeight(int)}, {@link
 * #setConfig(Bitmap.Config)}, and {@link BitmapFactory.Options#inBitmap
 * BitmapFactory.Options.inBitmap}. If a bitmap is not modified in this way, this value will be
 * the same as that returned by {@link #getByteCount()}.</p>
 *
 * <p>This value will not change over the lifetime of a Bitmap.</p>
 *
 * @see #reconfigure(int, int, Config)
 */

Body of Frist Method:
{
    if (mBuffer == null) {
        // so alloc size is always content size
        return getByteCount();
    }
    return mBuffer.length;
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getAllocationByteCount() on a recycle()'d bitmap! " + "This is undefined behavior!");
        return 0;
    }
    return nativeGetAllocationByteCount(mNativePtr);
}
------------------------
Find a silently evolved API code:android.telecom.PhoneAccount.capabilitiesToString:COMMENT
Method Modifier: private     
Comment:/**
 * Generates a string representation of a capabilities bitmask.
 *
 * @param capabilities The capabilities bitmask.
 * @return String representation of the capabilities bitmask.
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING)) {
        sb.append("Video ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE)) {
        sb.append("Presence ");
    }
    if (hasCapabilities(CAPABILITY_CALL_PROVIDER)) {
        sb.append("CallProvider ");
    }
    if (hasCapabilities(CAPABILITY_CALL_SUBJECT)) {
        sb.append("CallSubject ");
    }
    if (hasCapabilities(CAPABILITY_CONNECTION_MANAGER)) {
        sb.append("ConnectionMgr ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_CALLS_ONLY)) {
        sb.append("EmergOnly ");
    }
    if (hasCapabilities(CAPABILITY_MULTI_USER)) {
        sb.append("MultiUser ");
    }
    if (hasCapabilities(CAPABILITY_PLACE_EMERGENCY_CALLS)) {
        sb.append("PlaceEmerg ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
        sb.append("EmergVideo ");
    }
    if (hasCapabilities(CAPABILITY_SIM_SUBSCRIPTION)) {
        sb.append("SimSub ");
    }
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    if (hasCapabilities(CAPABILITY_SELF_MANAGED)) {
        sb.append("SelfManaged ");
    }
    if (hasCapabilities(CAPABILITY_SUPPORTS_VIDEO_CALLING)) {
        sb.append("SuppVideo ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING)) {
        sb.append("Video ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE)) {
        sb.append("Presence ");
    }
    if (hasCapabilities(CAPABILITY_CALL_PROVIDER)) {
        sb.append("CallProvider ");
    }
    if (hasCapabilities(CAPABILITY_CALL_SUBJECT)) {
        sb.append("CallSubject ");
    }
    if (hasCapabilities(CAPABILITY_CONNECTION_MANAGER)) {
        sb.append("ConnectionMgr ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_CALLS_ONLY)) {
        sb.append("EmergOnly ");
    }
    if (hasCapabilities(CAPABILITY_MULTI_USER)) {
        sb.append("MultiUser ");
    }
    if (hasCapabilities(CAPABILITY_PLACE_EMERGENCY_CALLS)) {
        sb.append("PlaceEmerg ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
        sb.append("EmergVideo ");
    }
    if (hasCapabilities(CAPABILITY_SIM_SUBSCRIPTION)) {
        sb.append("SimSub ");
    }
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.getNumberOfLayers:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the number of layers contained within this layer drawable.
 *
 * @return The number of layers.
 */

Body of Frist Method:
{
    return mLayerState.mNum;
}
Body of Second Method:
{
    return mLayerState.mNumChildren;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.translate:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcat the current matrix with the specified translation
 *
 * @param dx The distance to translate in X
 * @param dy The distance to translate in Y
 */

Body of Frist Method:
{
    native_translate(mNativeCanvasWrapper, dx, dy);
}
Body of Second Method:
{
    if (dx == 0.0f && dy == 0.0f)
        return;
    nTranslate(mNativeCanvasWrapper, dx, dy);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.freeCaches:COMMENT
<android.graphics.Canvas: void freeCaches()>
public      static      native      hidden      ->public      static      hidden      
Method Modifier: public      static      native      hidden      
Method Modifier: Yes         Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          Yes         
Comment:/**
 * Free up as much memory as possible from private caches (e.g. fonts, images)
 *
 * @hide
 */

Body of Frist Method:

Body of Second Method:
{
    nFreeCaches();
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setSecondaryProgress:COMMENT
Method Modifier: public      
Comment:/**
 * <p>
 * Set the current secondary progress to the specified value. Does not do
 * anything if the progress bar is in indeterminate mode.
 * </p>
 *
 * @param secondaryProgress the new secondary progress, between 0 and {@link #getMax()}
 * @see #setIndeterminate(boolean)
 * @see #isIndeterminate()
 * @see #getSecondaryProgress()
 * @see #incrementSecondaryProgressBy(int)
 */

Body of Frist Method:
{
    if (mIndeterminate) {
        return;
    }
    if (secondaryProgress < 0) {
        secondaryProgress = 0;
    }
    if (secondaryProgress > mMax) {
        secondaryProgress = mMax;
    }
    if (secondaryProgress != mSecondaryProgress) {
        mSecondaryProgress = secondaryProgress;
        refreshProgress(R.id.secondaryProgress, mSecondaryProgress, false, false);
    }
}
Body of Second Method:
{
    if (mIndeterminate) {
        return;
    }
    if (secondaryProgress < mMin) {
        secondaryProgress = mMin;
    }
    if (secondaryProgress > mMax) {
        secondaryProgress = mMax;
    }
    if (secondaryProgress != mSecondaryProgress) {
        mSecondaryProgress = secondaryProgress;
        refreshProgress(R.id.secondaryProgress, mSecondaryProgress, false, false);
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getNai:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    return getNai(getDefaultSim());
}
Body of Second Method:
{
    int[] subId = SubscriptionManager.getSubId(slotIndex);
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        String nai = info.getNaiForSubscriber(subId[0], mContext.getOpPackageName());
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Rlog.v(TAG, "Nai = " + nai);
        }
        return nai;
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getSmsSendCapable:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get SMS send capable from system property for the default phone.
 *
 * @param defaultValue default value
 * @return SMS send capable
 *
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    return getSmsSendCapableForPhone(phoneId, defaultValue);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    return getSmsSendCapableForPhone(phoneId, defaultValue);
}
------------------------
Find a silently evolved API code:android.renderscript.ScriptIntrinsicHistogram.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create an intrinsic for calculating the histogram of an uchar
 * or uchar4 image.
 *
 * Supported elements types are
 * {@link Element#U8_4}, {@link Element#U8_3},
 * {@link Element#U8_2}, {@link Element#U8}
 *
 * @param rs The RenderScript context
 * @param e Element type for inputs
 *
 * @return ScriptIntrinsicHistogram
 */

Body of Frist Method:
{
    if ((!e.isCompatible(Element.U8_4(rs))) && (!e.isCompatible(Element.U8_3(rs))) && (!e.isCompatible(Element.U8_2(rs))) && (!e.isCompatible(Element.U8(rs)))) {
        throw new RSIllegalArgumentException("Unsuported element type.");
    }
    long id = rs.nScriptIntrinsicCreate(9, e.getID(rs));
    ScriptIntrinsicHistogram sib = new ScriptIntrinsicHistogram(id, rs);
    return sib;
}
Body of Second Method:
{
    if ((!e.isCompatible(Element.U8_4(rs))) && (!e.isCompatible(Element.U8_3(rs))) && (!e.isCompatible(Element.U8_2(rs))) && (!e.isCompatible(Element.U8(rs)))) {
        throw new RSIllegalArgumentException("Unsupported element type.");
    }
    long id = rs.nScriptIntrinsicCreate(9, e.getID(rs));
    ScriptIntrinsicHistogram sib = new ScriptIntrinsicHistogram(id, rs);
    return sib;
}
------------------------
Find a silently evolved API code:android.view.RenderNode.isValid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether the RenderNode's display list content is currently usable.
 * If this returns false, the display list should be re-recorded prior to replaying it.
 *
 * @return boolean true if the display list is able to be replayed, false otherwise.
 */

Body of Frist Method:
{
    return mValid;
}
Body of Second Method:
{
    return nIsValid(mNativeRenderNode);
}
------------------------
Find a silently evolved API code:android.net.LocalSocketImpl.create:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a socket in the underlying OS.
 *
 * @param sockType either {@link LocalSocket#SOCKET_DGRAM}, {@link LocalSocket#SOCKET_STREAM}
 * or {@link LocalSocket#SOCKET_SEQPACKET}
 * @throws IOException
 */

Body of Frist Method:
{
    // need this for LocalServerSocket.accept()
    if (fd == null) {
        int osType;
        switch(sockType) {
            case LocalSocket.SOCKET_DGRAM:
                osType = OsConstants.SOCK_DGRAM;
                break;
            case LocalSocket.SOCKET_STREAM:
                osType = OsConstants.SOCK_STREAM;
                break;
            case LocalSocket.SOCKET_SEQPACKET:
                osType = OsConstants.SOCK_SEQPACKET;
                break;
            default:
                throw new IllegalStateException("unknown sockType");
        }
        try {
            fd = Os.socket(OsConstants.AF_UNIX, osType, 0);
            mFdCreatedInternally = true;
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
    }
}
Body of Second Method:
{
    if (fd != null) {
        throw new IOException("LocalSocketImpl already has an fd");
    }
    int osType;
    switch(sockType) {
        case LocalSocket.SOCKET_DGRAM:
            osType = OsConstants.SOCK_DGRAM;
            break;
        case LocalSocket.SOCKET_STREAM:
            osType = OsConstants.SOCK_STREAM;
            break;
        case LocalSocket.SOCKET_SEQPACKET:
            osType = OsConstants.SOCK_SEQPACKET;
            break;
        default:
            throw new IllegalStateException("unknown sockType");
    }
    try {
        fd = Os.socket(OsConstants.AF_UNIX, osType, 0);
        mFdCreatedInternally = true;
    } catch (ErrnoException e) {
        e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.startBluetoothSco:COMMENT
Method Modifier: public      
Comment:/**
 * Start bluetooth SCO audio connection.
 * <p>Requires Permission:
 * {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
 * <p>This method can be used by applications wanting to send and received audio
 * to/from a bluetooth SCO headset while the phone is not in call.
 * <p>As the SCO connection establishment can take several seconds,
 * applications should not rely on the connection to be available when the method
 * returns but instead register to receive the intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED}
 * and wait for the state to be {@link #SCO_AUDIO_STATE_CONNECTED}.
 * <p>As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky, the application can check the SCO
 * audio state before calling startBluetoothSco() by reading the intent returned by the receiver
 * registration. If the state is already CONNECTED, no state change will be received via the
 * intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()
 * so that the connection stays active in case the current initiator stops the connection.
 * <p>Unless the connection is already active as described above, the state will always
 * transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection
 * succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected).
 * <p>When finished with the SCO connection or if the establishment fails, the application must
 * call {@link #stopBluetoothSco()} to clear the request and turn down the bluetooth connection.
 * <p>Even if a SCO connection is established, the following restrictions apply on audio
 * output streams so that they can be routed to SCO headset:
 * <ul>
 * <li> the stream type must be {@link #STREAM_VOICE_CALL} </li>
 * <li> the format must be mono </li>
 * <li> the sampling must be 16kHz or 8kHz </li>
 * </ul>
 * <p>The following restrictions apply on input streams:
 * <ul>
 * <li> the format must be mono </li>
 * <li> the sampling must be 8kHz </li>
 * </ul>
 * <p>Note that the phone application always has the priority on the usage of the SCO
 * connection for telephony. If this method is called while the phone is in call
 * it will be ignored. Similarly, if a call is received or sent while an application
 * is using the SCO connection, the connection will be lost for the application and NOT
 * returned automatically when the call ends.
 * <p>NOTE: up to and including API version
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}, this method initiates a virtual
 * voice call to the bluetooth headset.
 * After API version {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2} only a raw SCO audio
 * connection is established.
 * @see #stopBluetoothSco()
 * @see #ACTION_SCO_AUDIO_STATE_UPDATED
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.startBluetoothSco(mICallBack, getContext().getApplicationInfo().targetSdkVersion);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.startBluetoothSco(mICallBack, getContext().getApplicationInfo().targetSdkVersion);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.groupedByUid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return total statistics grouped by {@link #uid}; doesn't mutate the
 * original structure.
 */

Body of Frist Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.iface = IFACE_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    entry.roaming = ROAMING_ALL;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.uid = uid[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        entry.operations = operations[i];
        stats.combineValues(entry);
    }
    return stats;
}
Body of Second Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.iface = IFACE_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    entry.metered = METERED_ALL;
    entry.roaming = ROAMING_ALL;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.uid = uid[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        entry.operations = operations[i];
        stats.combineValues(entry);
    }
    return stats;
}
------------------------
Find a silently evolved API code:android.webkit.CookieSyncManager.createInstance:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Create a singleton CookieSyncManager within a context
 * @param context
 * @return CookieSyncManager
 */

Body of Frist Method:
{
    if (context == null) {
        throw new IllegalArgumentException("Invalid context argument");
    }
    setGetInstanceIsAllowed();
    return getInstance();
}
Body of Second Method:
{
    synchronized (sLock) {
        if (context == null) {
            throw new IllegalArgumentException("Invalid context argument");
        }
        setGetInstanceIsAllowed();
        return getInstance();
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.releasePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(uri, "uri");
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "uri");
    try {
        ActivityManager.getService().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.os.StrictMode.ViolationInfo.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Dump a ViolationInfo instance to a Printer.
 */

Body of Frist Method:
{
    crashInfo.dump(pw, prefix);
    pw.println(prefix + "policy: " + policy);
    if (durationMillis != -1) {
        pw.println(prefix + "durationMillis: " + durationMillis);
    }
    if (numInstances != -1) {
        pw.println(prefix + "numInstances: " + numInstances);
    }
    if (violationNumThisLoop != 0) {
        pw.println(prefix + "violationNumThisLoop: " + violationNumThisLoop);
    }
    if (numAnimationsRunning != 0) {
        pw.println(prefix + "numAnimationsRunning: " + numAnimationsRunning);
    }
    pw.println(prefix + "violationUptimeMillis: " + violationUptimeMillis);
    if (broadcastIntentAction != null) {
        pw.println(prefix + "broadcastIntentAction: " + broadcastIntentAction);
    }
    if (tags != null) {
        int index = 0;
        for (String tag : tags) {
            pw.println(prefix + "tag[" + (index++) + "]: " + tag);
        }
    }
}
Body of Second Method:
{
    if (crashInfo != null) {
        crashInfo.dump(pw, prefix);
    }
    pw.println(prefix + "policy: " + policy);
    if (durationMillis != -1) {
        pw.println(prefix + "durationMillis: " + durationMillis);
    }
    if (numInstances != -1) {
        pw.println(prefix + "numInstances: " + numInstances);
    }
    if (violationNumThisLoop != 0) {
        pw.println(prefix + "violationNumThisLoop: " + violationNumThisLoop);
    }
    if (numAnimationsRunning != 0) {
        pw.println(prefix + "numAnimationsRunning: " + numAnimationsRunning);
    }
    pw.println(prefix + "violationUptimeMillis: " + violationUptimeMillis);
    if (broadcastIntentAction != null) {
        pw.println(prefix + "broadcastIntentAction: " + broadcastIntentAction);
    }
    if (tags != null) {
        int index = 0;
        for (String tag : tags) {
            pw.println(prefix + "tag[" + (index++) + "]: " + tag);
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.loadDrawableInner:COMMENT
Method Modifier: private     
Comment:/**
 * Do the heavy lifting of loading the drawable, but stop short of applying any tint.
 */

Body of Frist Method:
{
    switch(mType) {
        case TYPE_BITMAP:
            return new BitmapDrawable(context.getResources(), getBitmap());
        case TYPE_RESOURCE:
            if (getResources() == null) {
                // figure out where to load resources from
                String resPackage = getResPackage();
                if (TextUtils.isEmpty(resPackage)) {
                    // if none is specified, try the given context
                    resPackage = context.getPackageName();
                }
                if ("android".equals(resPackage)) {
                    mObj1 = Resources.getSystem();
                } else {
                    final PackageManager pm = context.getPackageManager();
                    try {
                        ApplicationInfo ai = pm.getApplicationInfo(resPackage, PackageManager.GET_UNINSTALLED_PACKAGES);
                        if (ai != null) {
                            mObj1 = pm.getResourcesForApplication(ai);
                        } else {
                            break;
                        }
                    } catch (PackageManager.NameNotFoundException e) {
                        Log.e(TAG, String.format("Unable to find pkg=%s for icon %s", resPackage, this), e);
                        break;
                    }
                }
            }
            try {
                return getResources().getDrawable(getResId(), context.getTheme());
            } catch (RuntimeException e) {
                Log.e(TAG, String.format("Unable to load resource 0x%08x from pkg=%s", getResId(), getResPackage()), e);
            }
            break;
        case TYPE_DATA:
            return new BitmapDrawable(context.getResources(), BitmapFactory.decodeByteArray(getDataBytes(), getDataOffset(), getDataLength()));
        case TYPE_URI:
            final Uri uri = getUri();
            final String scheme = uri.getScheme();
            InputStream is = null;
            if (ContentResolver.SCHEME_CONTENT.equals(scheme) || ContentResolver.SCHEME_FILE.equals(scheme)) {
                try {
                    is = context.getContentResolver().openInputStream(uri);
                } catch (Exception e) {
                    Log.w(TAG, "Unable to load image from URI: " + uri, e);
                }
            } else {
                try {
                    is = new FileInputStream(new File(mString1));
                } catch (FileNotFoundException e) {
                    Log.w(TAG, "Unable to load image from path: " + uri, e);
                }
            }
            if (is != null) {
                return new BitmapDrawable(context.getResources(), BitmapFactory.decodeStream(is));
            }
            break;
    }
    return null;
}
Body of Second Method:
{
    switch(mType) {
        case TYPE_BITMAP:
            return new BitmapDrawable(context.getResources(), getBitmap());
        case TYPE_ADAPTIVE_BITMAP:
            return new AdaptiveIconDrawable(null, new BitmapDrawable(context.getResources(), getBitmap()));
        case TYPE_RESOURCE:
            if (getResources() == null) {
                // figure out where to load resources from
                String resPackage = getResPackage();
                if (TextUtils.isEmpty(resPackage)) {
                    // if none is specified, try the given context
                    resPackage = context.getPackageName();
                }
                if ("android".equals(resPackage)) {
                    mObj1 = Resources.getSystem();
                } else {
                    final PackageManager pm = context.getPackageManager();
                    try {
                        ApplicationInfo ai = pm.getApplicationInfo(resPackage, PackageManager.MATCH_UNINSTALLED_PACKAGES);
                        if (ai != null) {
                            mObj1 = pm.getResourcesForApplication(ai);
                        } else {
                            break;
                        }
                    } catch (PackageManager.NameNotFoundException e) {
                        Log.e(TAG, String.format("Unable to find pkg=%s for icon %s", resPackage, this), e);
                        break;
                    }
                }
            }
            try {
                return getResources().getDrawable(getResId(), context.getTheme());
            } catch (RuntimeException e) {
                Log.e(TAG, String.format("Unable to load resource 0x%08x from pkg=%s", getResId(), getResPackage()), e);
            }
            break;
        case TYPE_DATA:
            return new BitmapDrawable(context.getResources(), BitmapFactory.decodeByteArray(getDataBytes(), getDataOffset(), getDataLength()));
        case TYPE_URI:
            final Uri uri = getUri();
            final String scheme = uri.getScheme();
            InputStream is = null;
            if (ContentResolver.SCHEME_CONTENT.equals(scheme) || ContentResolver.SCHEME_FILE.equals(scheme)) {
                try {
                    is = context.getContentResolver().openInputStream(uri);
                } catch (Exception e) {
                    Log.w(TAG, "Unable to load image from URI: " + uri, e);
                }
            } else {
                try {
                    is = new FileInputStream(new File(mString1));
                } catch (FileNotFoundException e) {
                    Log.w(TAG, "Unable to load image from path: " + uri, e);
                }
            }
            if (is != null) {
                return new BitmapDrawable(context.getResources(), BitmapFactory.decodeStream(is));
            }
            break;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setSimOperatorName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC for the default phone.
 *
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    setSimOperatorNameForPhone(phoneId, name);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    setSimOperatorNameForPhone(phoneId, name);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.concat:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcat the current matrix with the specified matrix. If the specified
 * matrix is null, this method does nothing.
 *
 * @param matrix The matrix to preconcatenate with the current matrix
 */

Body of Frist Method:
{
    if (matrix != null)
        native_concat(mNativeCanvasWrapper, matrix.native_instance);
}
Body of Second Method:
{
    if (matrix != null)
        nConcat(mNativeCanvasWrapper, matrix.native_instance);
}
------------------------
Find a silently evolved API code:android.widget.AbsSeekBar.performAccessibilityActionInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (super.performAccessibilityActionInternal(action, arguments)) {
        return true;
    }
    if (!isEnabled()) {
        return false;
    }
    switch(action) {
        case R.id.accessibilityActionSetProgress:
            {
                if (!canUserSetProgress()) {
                    return false;
                }
                if (arguments == null || !arguments.containsKey(AccessibilityNodeInfo.ACTION_ARGUMENT_PROGRESS_VALUE)) {
                    return false;
                }
                float value = arguments.getFloat(AccessibilityNodeInfo.ACTION_ARGUMENT_PROGRESS_VALUE);
                return setProgressInternal((int) value, true, true);
            }
        case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
        case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
            {
                if (!canUserSetProgress()) {
                    return false;
                }
                int increment = Math.max(1, Math.round((float) getMax() / 20));
                if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
                    increment = -increment;
                }
                // Let progress bar handle clamping values.
                if (setProgressInternal(getProgress() + increment, true, true)) {
                    onKeyChange();
                    return true;
                }
                return false;
            }
    }
    return false;
}
Body of Second Method:
{
    if (super.performAccessibilityActionInternal(action, arguments)) {
        return true;
    }
    if (!isEnabled()) {
        return false;
    }
    switch(action) {
        case R.id.accessibilityActionSetProgress:
            {
                if (!canUserSetProgress()) {
                    return false;
                }
                if (arguments == null || !arguments.containsKey(AccessibilityNodeInfo.ACTION_ARGUMENT_PROGRESS_VALUE)) {
                    return false;
                }
                float value = arguments.getFloat(AccessibilityNodeInfo.ACTION_ARGUMENT_PROGRESS_VALUE);
                return setProgressInternal((int) value, true, true);
            }
        case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
        case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
            {
                if (!canUserSetProgress()) {
                    return false;
                }
                int range = getMax() - getMin();
                int increment = Math.max(1, Math.round((float) range / 20));
                if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
                    increment = -increment;
                }
                // Let progress bar handle clamping values.
                if (setProgressInternal(getProgress() + increment, true, true)) {
                    onKeyChange();
                    return true;
                }
                return false;
            }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.recycle:COMMENT
Method Modifier: public      
Comment:/**
 * Free the native object associated with this bitmap, and clear the
 * reference to the pixel data. This will not free the pixel data synchronously;
 * it simply allows it to be garbage collected if there are no other references.
 * The bitmap is marked as "dead", meaning it will throw an exception if
 * getPixels() or setPixels() is called, and will draw nothing. This operation
 * cannot be reversed, so it should only be called if you are sure there are no
 * further uses for the bitmap. This is an advanced call, and normally need
 * not be called, since the normal GC process will free up this memory when
 * there are no more references to this bitmap.
 */

Body of Frist Method:
{
    if (!mRecycled && mNativePtr != 0) {
        if (nativeRecycle(mNativePtr)) {
            // return value indicates whether native pixel object was actually recycled.
            // false indicates that it is still in use at the native level and these
            // objects should not be collected now. They will be collected later when the
            // Bitmap itself is collected.
            mBuffer = null;
            mNinePatchChunk = null;
        }
        mRecycled = true;
    }
}
Body of Second Method:
{
    if (!mRecycled && mNativePtr != 0) {
        if (nativeRecycle(mNativePtr)) {
            // return value indicates whether native pixel object was actually recycled.
            // false indicates that it is still in use at the native level and these
            // objects should not be collected now. They will be collected later when the
            // Bitmap itself is collected.
            mNinePatchChunk = null;
        }
        mRecycled = true;
    }
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivitiesAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Like {@link #execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)},
 * but accepts an array of activities to be started.  Note that active
 * {@link ActivityMonitor} objects only match against the first activity in
 * the array.
 *
 * {@hide}
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intents[0])) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        String[] resolvedTypes = new String[intents.length];
        for (int i = 0; i < intents.length; i++) {
            intents[i].migrateExtraStreamToClipData();
            intents[i].prepareToLeaveProcess(who);
            resolvedTypes[i] = intents[i].resolveTypeIfNeeded(who.getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivities(whoThread, who.getBasePackageName(), intents, resolvedTypes, token, options, userId);
        checkStartActivityResult(result, intents[0]);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                ActivityResult result = null;
                if (am.ignoreMatchingSpecificIntents()) {
                    result = am.onStartActivity(intents[0]);
                }
                if (result != null) {
                    am.mHits++;
                    return;
                } else if (am.match(who, null, intents[0])) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        String[] resolvedTypes = new String[intents.length];
        for (int i = 0; i < intents.length; i++) {
            intents[i].migrateExtraStreamToClipData();
            intents[i].prepareToLeaveProcess(who);
            resolvedTypes[i] = intents[i].resolveTypeIfNeeded(who.getContentResolver());
        }
        int result = ActivityManager.getService().startActivities(whoThread, who.getBasePackageName(), intents, resolvedTypes, token, options, userId);
        checkStartActivityResult(result, intents[0]);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
}
------------------------
Find a silently evolved API code:android.view.animation.AnimationSet.addAnimation:COMMENT
Method Modifier: public      
Comment:/**
 * Add a child animation to this animation set.
 * The transforms of the child animations are applied in the order
 * that they were added
 * @param a Animation to add.
 */

Body of Frist Method:
{
    mAnimations.add(a);
    boolean noMatrix = (mFlags & PROPERTY_MORPH_MATRIX_MASK) == 0;
    if (noMatrix && a.willChangeTransformationMatrix()) {
        mFlags |= PROPERTY_MORPH_MATRIX_MASK;
    }
    boolean changeBounds = (mFlags & PROPERTY_CHANGE_BOUNDS_MASK) == 0;
    if (changeBounds && a.willChangeBounds()) {
        mFlags |= PROPERTY_CHANGE_BOUNDS_MASK;
    }
    if ((mFlags & PROPERTY_DURATION_MASK) == PROPERTY_DURATION_MASK) {
        mLastEnd = mStartOffset + mDuration;
    } else {
        if (mAnimations.size() == 1) {
            mDuration = a.getStartOffset() + a.getDuration();
            mLastEnd = mStartOffset + mDuration;
        } else {
            mLastEnd = Math.max(mLastEnd, a.getStartOffset() + a.getDuration());
            mDuration = mLastEnd - mStartOffset;
        }
    }
    mDirty = true;
}
Body of Second Method:
{
    mAnimations.add(a);
    boolean noMatrix = (mFlags & PROPERTY_MORPH_MATRIX_MASK) == 0;
    if (noMatrix && a.willChangeTransformationMatrix()) {
        mFlags |= PROPERTY_MORPH_MATRIX_MASK;
    }
    boolean changeBounds = (mFlags & PROPERTY_CHANGE_BOUNDS_MASK) == 0;
    if (changeBounds && a.willChangeBounds()) {
        mFlags |= PROPERTY_CHANGE_BOUNDS_MASK;
    }
    if ((mFlags & PROPERTY_DURATION_MASK) == PROPERTY_DURATION_MASK) {
        mLastEnd = mStartOffset + mDuration;
    } else {
        if (mAnimations.size() == 1) {
            mDuration = a.getStartOffset() + a.getDuration();
            mLastEnd = mStartOffset + mDuration;
        } else {
            mLastEnd = Math.max(mLastEnd, mStartOffset + a.getStartOffset() + a.getDuration());
            mDuration = mLastEnd - mStartOffset;
        }
    }
    mDirty = true;
}
------------------------
Find a silently evolved API code:android.graphics.Path.rQuadTo:COMMENT
Method Modifier: public      
Comment:/**
 * Same as quadTo, but the coordinates are considered relative to the last
 * point on this contour. If there is no previous point, then a moveTo(0,0)
 * is inserted automatically.
 *
 * @param dx1 The amount to add to the x-coordinate of the last point on
 * this contour, for the control point of a quadratic curve
 * @param dy1 The amount to add to the y-coordinate of the last point on
 * this contour, for the control point of a quadratic curve
 * @param dx2 The amount to add to the x-coordinate of the last point on
 * this contour, for the end point of a quadratic curve
 * @param dy2 The amount to add to the y-coordinate of the last point on
 * this contour, for the end point of a quadratic curve
 */

Body of Frist Method:
{
    isSimplePath = false;
    native_rQuadTo(mNativePath, dx1, dy1, dx2, dy2);
}
Body of Second Method:
{
    isSimplePath = false;
    nRQuadTo(mNativePath, dx1, dy1, dx2, dy2);
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.putExtra:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Adds an extra associated with a {@code Connection}.
 *
 * @param callId The unique ID of the call.
 * @param key The extra key.
 * @param value The extra value.
 */

Body of Frist Method:
{
    Log.v(this, "putExtra: %s %s=%d", callId, key, value);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            Bundle bundle = new Bundle();
            bundle.putInt(key, value);
            adapter.putExtras(callId, bundle);
        } catch (RemoteException ignored) {
        }
    }
}
Body of Second Method:
{
    Log.v(this, "putExtra: %s %s=%d", callId, key, value);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            Bundle bundle = new Bundle();
            bundle.putInt(key, value);
            adapter.putExtras(callId, bundle, Log.getExternalSession());
        } catch (RemoteException ignored) {
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfEditor.setPageCropBox:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the crop box of a given page in mils (1/72").
 *
 * @param pageIndex The page index.
 * @param cropBox The crop box.
 */

Body of Frist Method:
{
    throwIfClosed();
    throwIfCropBoxNull(cropBox);
    throwIfPageNotInDocument(pageIndex);
    nativeSetPageCropBox(mNativeDocument, pageIndex, cropBox);
}
Body of Second Method:
{
    throwIfClosed();
    throwIfCropBoxNull(cropBox);
    throwIfPageNotInDocument(pageIndex);
    synchronized (PdfRenderer.sPdfiumLock) {
        nativeSetPageCropBox(mNativeDocument, pageIndex, cropBox);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Matrix.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true iff obj is a Matrix and its values equal our values.
 */

Body of Frist Method:
{
    // if (obj == this) return true;     -- NaN value would mean matrix != itself
    if (!(obj instanceof Matrix))
        return false;
    return native_equals(native_instance, ((Matrix) obj).native_instance);
}
Body of Second Method:
{
    // if (obj == this) return true; -- NaN value would mean matrix != itself
    if (!(obj instanceof Matrix)) {
        return false;
    }
    return nEquals(native_instance, ((Matrix) obj).native_instance);
}
------------------------
Find a silently evolved API code:android.text.method.WordIterator.isOnPunctuation:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Indicates if the provided offset is at a punctuation character
 * as defined by {@link #isPunctuation(int)}.
 *
 * @param offset the offset to check from.
 * @return Whether the offset is at a punctuation character.
 */

Body of Frist Method:
{
    final int shiftedOffset = offset - mOffsetShift;
    if (shiftedOffset >= 0 && shiftedOffset < mString.length()) {
        final int codePoint = mString.codePointAt(shiftedOffset);
        return isPunctuation(codePoint);
    }
    return false;
}
Body of Second Method:
{
    if (mStart <= offset && offset < mEnd) {
        final int codePoint = Character.codePointAt(mCharSeq, offset);
        return isPunctuation(codePoint);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current volume index for a particular stream.
 *
 * @param streamType The stream type whose volume index is returned.
 * @return The current volume index for the stream.
 * @see #getStreamMaxVolume(int)
 * @see #setStreamVolume(int, int, int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getStreamVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.getStreamVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CaptureRequest.readFromParcel:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Expand this object from a Parcel.
 * Hidden since this breaks the immutability of CaptureRequest, but is
 * needed to receive CaptureRequests with aidl.
 *
 * @param in The parcel from which the object should be read
 * @hide
 */

Body of Frist Method:
{
    mSettings.readFromParcel(in);
    mSurfaceSet.clear();
    Parcelable[] parcelableArray = in.readParcelableArray(Surface.class.getClassLoader());
    if (parcelableArray == null) {
        return;
    }
    for (Parcelable p : parcelableArray) {
        Surface s = (Surface) p;
        mSurfaceSet.add(s);
    }
    mIsReprocess = (in.readInt() == 0) ? false : true;
    mReprocessableSessionId = CameraCaptureSession.SESSION_ID_NONE;
}
Body of Second Method:
{
    mSettings.readFromParcel(in);
    setNativeInstance(mSettings);
    mSurfaceSet.clear();
    Parcelable[] parcelableArray = in.readParcelableArray(Surface.class.getClassLoader());
    if (parcelableArray == null) {
        return;
    }
    for (Parcelable p : parcelableArray) {
        Surface s = (Surface) p;
        mSurfaceSet.add(s);
    }
    mIsReprocess = (in.readInt() == 0) ? false : true;
    mReprocessableSessionId = CameraCaptureSession.SESSION_ID_NONE;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isAudioFocusExclusive:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Checks whether the current audio focus is exclusive.
 * @return true if the top of the audio focus stack requested focus
 * with {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE}
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getCurrentAudioFocus() == AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.getCurrentAudioFocus() == AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.inflateLayers:COMMENT
Method Modifier: private     
Comment:/**
 * Inflates child layers using the specified parser.
 */

Body of Frist Method:
{
    final LayerState state = mLayerState;
    final int innerDepth = parser.getDepth() + 1;
    int type;
    int depth;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth || !parser.getName().equals("item")) {
            continue;
        }
        final ChildDrawable layer = new ChildDrawable(state.mDensity);
        final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.LayerDrawableItem);
        updateLayerFromTypedArray(layer, a);
        a.recycle();
        // element.
        if (layer.mDrawable == null && (layer.mThemeAttrs == null || layer.mThemeAttrs[R.styleable.LayerDrawableItem_drawable] == 0)) {
            while ((type = parser.next()) == XmlPullParser.TEXT) {
            }
            if (type != XmlPullParser.START_TAG) {
                throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'drawable' attribute or " + "child tag defining a drawable");
            }
            layer.mDrawable = Drawable.createFromXmlInner(r, parser, attrs, theme);
        }
        if (layer.mDrawable != null) {
            state.mChildrenChangingConfigurations |= layer.mDrawable.getChangingConfigurations();
            layer.mDrawable.setCallback(this);
        }
        addLayer(layer);
    }
}
Body of Second Method:
{
    final LayerState state = mLayerState;
    final int innerDepth = parser.getDepth() + 1;
    int type;
    int depth;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth || !parser.getName().equals("item")) {
            continue;
        }
        final ChildDrawable layer = new ChildDrawable(state.mDensity);
        final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.LayerDrawableItem);
        updateLayerFromTypedArray(layer, a);
        a.recycle();
        // first one.
        if (layer.mDrawable == null && (layer.mThemeAttrs == null || layer.mThemeAttrs[R.styleable.LayerDrawableItem_drawable] == 0)) {
            while ((type = parser.next()) == XmlPullParser.TEXT) {
            }
            if (type != XmlPullParser.START_TAG) {
                throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'drawable' attribute or " + "child tag defining a drawable");
            }
            // We found a child drawable. Take ownership.
            layer.mDrawable = Drawable.createFromXmlInner(r, parser, attrs, theme);
            layer.mDrawable.setCallback(this);
            state.mChildrenChangingConfigurations |= layer.mDrawable.getChangingConfigurations();
        }
        addLayer(layer);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.close:COMMENT
Method Modifier: public      
Comment:/**
 * Close this Bluetooth GATT client.
 *
 * Application should call this method as early as possible after it is done with
 * this GATT client.
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "close()");
    unregisterApp();
    mConnState = CONN_STATE_CLOSED;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "close()");
    unregisterApp();
    mConnState = CONN_STATE_CLOSED;
    mAuthRetryState = AUTH_RETRY_STATE_IDLE;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.getAnchor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node that anchors this window to another.
 *
 * @return The anchor node, or {@code null} if none exists.
 */

Body of Frist Method:
{
    if ((mConnectionId == UNDEFINED) || (mAnchorId == UNDEFINED) || (mParentId == UNDEFINED)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mParentId, mAnchorId, true, 0);
}
Body of Second Method:
{
    if ((mConnectionId == UNDEFINED_WINDOW_ID) || (mAnchorId == UNDEFINED_WINDOW_ID) || (mParentId == UNDEFINED_WINDOW_ID)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mParentId, mAnchorId, true, 0, null);
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.fillInNotifierBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set intent notifier Bundle based on SignalStrength
 *
 * @param m intent notifier Bundle
 * @hide
 */

Body of Frist Method:
{
    m.putInt("GsmSignalStrength", mGsmSignalStrength);
    m.putInt("GsmBitErrorRate", mGsmBitErrorRate);
    m.putInt("CdmaDbm", mCdmaDbm);
    m.putInt("CdmaEcio", mCdmaEcio);
    m.putInt("EvdoDbm", mEvdoDbm);
    m.putInt("EvdoEcio", mEvdoEcio);
    m.putInt("EvdoSnr", mEvdoSnr);
    m.putInt("LteSignalStrength", mLteSignalStrength);
    m.putInt("LteRsrp", mLteRsrp);
    m.putInt("LteRsrq", mLteRsrq);
    m.putInt("LteRssnr", mLteRssnr);
    m.putInt("LteCqi", mLteCqi);
    m.putInt("TdScdma", mTdScdmaRscp);
    m.putBoolean("isGsm", Boolean.valueOf(isGsm));
}
Body of Second Method:
{
    m.putInt("GsmSignalStrength", mGsmSignalStrength);
    m.putInt("GsmBitErrorRate", mGsmBitErrorRate);
    m.putInt("CdmaDbm", mCdmaDbm);
    m.putInt("CdmaEcio", mCdmaEcio);
    m.putInt("EvdoDbm", mEvdoDbm);
    m.putInt("EvdoEcio", mEvdoEcio);
    m.putInt("EvdoSnr", mEvdoSnr);
    m.putInt("LteSignalStrength", mLteSignalStrength);
    m.putInt("LteRsrp", mLteRsrp);
    m.putInt("LteRsrq", mLteRsrq);
    m.putInt("LteRssnr", mLteRssnr);
    m.putInt("LteCqi", mLteCqi);
    m.putInt("lteRsrpBoost", mLteRsrpBoost);
    m.putInt("TdScdma", mTdScdmaRscp);
    m.putBoolean("isGsm", isGsm);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.changeApplicationBluetoothState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Enable control of the Bluetooth Adapter for a single application.
 *
 * <p>Some applications need to use Bluetooth for short periods of time to
 * transfer data but don't want all the associated implications like
 * automatic connection to headsets etc.
 *
 * <p> Multiple applications can call this. This is reference counted and
 * Bluetooth disabled only when no one else is using it. There will be no UI
 * shown to the user while bluetooth is being enabled. Any user action will
 * override this call. For example, if user wants Bluetooth on and the last
 * user of this API wanted to disable Bluetooth, Bluetooth will not be
 * turned off.
 *
 * <p> This API is only meant to be used by internal applications. Third
 * party applications but use {@link #enable} and {@link #disable} APIs.
 *
 * <p> If this API returns true, it means the callback will be called.
 * The callback will be called with the current state of Bluetooth.
 * If the state is not what was requested, an internal error would be the
 * reason. If Bluetooth is already on and if this function is called to turn
 * it on, the api will return true and a callback will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @param on True for on, false for off.
 * @param callback The callback to notify changes to the state.
 * @hide
 */

Body of Frist Method:
{
    if (callback == null)
        return false;
    /*
        try {
            mServiceLock.readLock().lock();
            if (mService != null) {
                return mService.changeApplicationBluetoothState(on, new
                    StateChangeCallbackWrapper(callback), new Binder());
            }
        } catch (RemoteException e) {
            Log.e(TAG, "changeBluetoothState", e);
        } finally {
            mServiceLock.readLock().unlock();
        }
        */
    return false;
}
Body of Second Method:
{
    return false;
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.setOnHold:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Sets a call's state to be on hold.
 *
 * @param callId - The unique ID of the call whose state is changing to be on hold.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setOnHold(callId);
        } catch (RemoteException e) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.setOnHold(callId, Log.getExternalSession());
        } catch (RemoteException e) {
        }
    }
}
------------------------
Find a silently evolved API code:android.os.Looper.dump:COMMENT
Method Modifier: public      
Comment:/**
 * Dumps the state of the looper for debugging purposes.
 *
 * @param pw A printer to receive the contents of the dump.
 * @param prefix A prefix to prepend to each line which is printed.
 */

Body of Frist Method:
{
    pw.println(prefix + toString());
    mQueue.dump(pw, prefix + "  ");
}
Body of Second Method:
{
    pw.println(prefix + toString());
    mQueue.dump(pw, prefix + "  ", null);
}
------------------------
Find a silently evolved API code:android.graphics.Path.lineTo:COMMENT
Method Modifier: public      
Comment:/**
 * Add a line from the last point to the specified point (x,y).
 * If no moveTo() call has been made for this contour, the first point is
 * automatically set to (0,0).
 *
 * @param x The x-coordinate of the end of a line
 * @param y The y-coordinate of the end of a line
 */

Body of Frist Method:
{
    isSimplePath = false;
    native_lineTo(mNativePath, x, y);
}
Body of Second Method:
{
    isSimplePath = false;
    nLineTo(mNativePath, x, y);
}
------------------------
Find a silently evolved API code:android.preference.Preference.setWidgetLayoutResource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the layout for the controllable widget portion of this Preference. This
 * is inflated into the main layout. For example, a {@link CheckBoxPreference}
 * would specify a custom layout (consisting of just the CheckBox) here,
 * instead of creating its own main layout.
 *
 * @param widgetLayoutResId The layout resource ID to be inflated into the
 * main layout.
 * @see #setLayoutResource(int)
 */

Body of Frist Method:
{
    if (widgetLayoutResId != mWidgetLayoutResId) {
        // Layout changed
        mCanRecycleLayout = false;
    }
    mWidgetLayoutResId = widgetLayoutResId;
}
Body of Second Method:
{
    if (widgetLayoutResId != mWidgetLayoutResId) {
        // Layout changed
        mRecycleEnabled = false;
    }
    mWidgetLayoutResId = widgetLayoutResId;
}
------------------------
Find a silently evolved API code:android.text.method.WordIterator.getEnd:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * If the <code>offset</code> is within a word or on a word boundary that can only be
 * considered the end of a word (e.g. word_ where "_" is any character that would not be
 * considered part of the word) then this returns the index of the last character plus one
 * of that word.
 *
 * If the offset is on a word boundary that can be considered the start and end of a
 * word, e.g. AABB (where AA and BB are both words) and the offset is the boundary
 * between AA and BB, and getNextWordEndOnTwoWordBoundary is true then this would return
 * the end of the next word, BB. Otherwise it would return the current offset, the end
 * of AA.
 *
 * Returns BreakIterator.DONE if there is no next boundary.
 *
 * @throws IllegalArgumentException is offset is not valid.
 */

Body of Frist Method:
{
    final int shiftedOffset = offset - mOffsetShift;
    checkOffsetIsValid(shiftedOffset);
    if (isAfterLetterOrDigit(shiftedOffset)) {
        if (mIterator.isBoundary(shiftedOffset) && (!isOnLetterOrDigit(shiftedOffset) || !getNextWordEndOnTwoWordBoundary)) {
            return shiftedOffset + mOffsetShift;
        } else {
            return mIterator.following(shiftedOffset) + mOffsetShift;
        }
    } else {
        if (isOnLetterOrDigit(shiftedOffset)) {
            return mIterator.following(shiftedOffset) + mOffsetShift;
        }
    }
    return BreakIterator.DONE;
}
Body of Second Method:
{
    checkOffsetIsValid(offset);
    if (isAfterLetterOrDigit(offset)) {
        if (mIterator.isBoundary(offset) && (!isOnLetterOrDigit(offset) || !getNextWordEndOnTwoWordBoundary)) {
            return offset;
        } else {
            return mIterator.following(offset);
        }
    } else {
        if (isOnLetterOrDigit(offset)) {
            return mIterator.following(offset);
        }
    }
    return BreakIterator.DONE;
}
------------------------
Find a silently evolved API code:android.mtp.MtpDevice.close:COMMENT
Method Modifier: public      
Comment:/**
 * Closes all resources related to the MtpDevice object.
 * After this is called, the object can not be used until {@link #open} is called again
 * with a new {@link android.hardware.usb.UsbDeviceConnection}.
 */

Body of Frist Method:
{
    native_close();
}
Body of Second Method:
{
    synchronized (mLock) {
        if (mConnection != null) {
            mCloseGuard.close();
            native_close();
            mConnection.close();
            mConnection = null;
        }
    }
}
------------------------
Find a silently evolved API code:android.text.TextLine.getOffsetBeforeAfter:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Returns the next valid offset within this directional run, skipping
 * conjuncts and zero-width characters.  This should not be called to walk
 * off the end of the line, since the returned values might not be valid
 * on neighboring lines.  If the returned offset is less than zero or
 * greater than the line length, the offset should be recomputed on the
 * preceding or following line, respectively.
 *
 * @param runIndex the run index
 * @param runStart the start of the run
 * @param runLimit the limit of the run
 * @param runIsRtl true if the run is right-to-left
 * @param offset the offset
 * @param after true if the new offset should logically follow the provided
 * offset
 * @return the new offset
 */

Body of Frist Method:
{
    if (runIndex < 0 || offset == (after ? mLen : 0)) {
        // return accurate values.  These are a guess.
        if (after) {
            return TextUtils.getOffsetAfter(mText, offset + mStart) - mStart;
        }
        return TextUtils.getOffsetBefore(mText, offset + mStart) - mStart;
    }
    TextPaint wp = mWorkPaint;
    wp.set(mPaint);
    int spanStart = runStart;
    int spanLimit;
    if (mSpanned == null) {
        spanLimit = runLimit;
    } else {
        int target = after ? offset + 1 : offset;
        int limit = mStart + runLimit;
        while (true) {
            spanLimit = mSpanned.nextSpanTransition(mStart + spanStart, limit, MetricAffectingSpan.class) - mStart;
            if (spanLimit >= target) {
                break;
            }
            spanStart = spanLimit;
        }
        MetricAffectingSpan[] spans = mSpanned.getSpans(mStart + spanStart, mStart + spanLimit, MetricAffectingSpan.class);
        spans = TextUtils.removeEmptySpans(spans, mSpanned, MetricAffectingSpan.class);
        if (spans.length > 0) {
            ReplacementSpan replacement = null;
            for (int j = 0; j < spans.length; j++) {
                MetricAffectingSpan span = spans[j];
                if (span instanceof ReplacementSpan) {
                    replacement = (ReplacementSpan) span;
                } else {
                    span.updateMeasureState(wp);
                }
            }
            if (replacement != null) {
                // the start or end of this span.
                return after ? spanLimit : spanStart;
            }
        }
    }
    int dir = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
    int cursorOpt = after ? Paint.CURSOR_AFTER : Paint.CURSOR_BEFORE;
    if (mCharsValid) {
        return wp.getTextRunCursor(mChars, spanStart, spanLimit - spanStart, dir, offset, cursorOpt);
    } else {
        return wp.getTextRunCursor(mText, mStart + spanStart, mStart + spanLimit, dir, mStart + offset, cursorOpt) - mStart;
    }
}
Body of Second Method:
{
    if (runIndex < 0 || offset == (after ? mLen : 0)) {
        // return accurate values.  These are a guess.
        if (after) {
            return TextUtils.getOffsetAfter(mText, offset + mStart) - mStart;
        }
        return TextUtils.getOffsetBefore(mText, offset + mStart) - mStart;
    }
    TextPaint wp = mWorkPaint;
    wp.set(mPaint);
    wp.setWordSpacing(mAddedWidth);
    int spanStart = runStart;
    int spanLimit;
    if (mSpanned == null) {
        spanLimit = runLimit;
    } else {
        int target = after ? offset + 1 : offset;
        int limit = mStart + runLimit;
        while (true) {
            spanLimit = mSpanned.nextSpanTransition(mStart + spanStart, limit, MetricAffectingSpan.class) - mStart;
            if (spanLimit >= target) {
                break;
            }
            spanStart = spanLimit;
        }
        MetricAffectingSpan[] spans = mSpanned.getSpans(mStart + spanStart, mStart + spanLimit, MetricAffectingSpan.class);
        spans = TextUtils.removeEmptySpans(spans, mSpanned, MetricAffectingSpan.class);
        if (spans.length > 0) {
            ReplacementSpan replacement = null;
            for (int j = 0; j < spans.length; j++) {
                MetricAffectingSpan span = spans[j];
                if (span instanceof ReplacementSpan) {
                    replacement = (ReplacementSpan) span;
                } else {
                    span.updateMeasureState(wp);
                }
            }
            if (replacement != null) {
                // the start or end of this span.
                return after ? spanLimit : spanStart;
            }
        }
    }
    int dir = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
    int cursorOpt = after ? Paint.CURSOR_AFTER : Paint.CURSOR_BEFORE;
    if (mCharsValid) {
        return wp.getTextRunCursor(mChars, spanStart, spanLimit - spanStart, dir, offset, cursorOpt);
    } else {
        return wp.getTextRunCursor(mText, mStart + spanStart, mStart + spanLimit, dir, mStart + offset, cursorOpt) - mStart;
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getAidForAppType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return the application ID for the app type like {@link APPTYPE_CSIM}.
 *
 * Requires that the calling app has READ_PRIVILEGED_PHONE_STATE permission
 *
 * @param appType the uicc app type like {@link APPTYPE_CSIM}
 * @return Application ID for specificied app type or null if no uicc or error.
 * @hide
 */

Body of Frist Method:
{
    return getAidForAppType(getDefaultSubscription(), appType);
}
Body of Second Method:
{
    return getAidForAppType(getSubId(), appType);
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setBasebandVersion:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set baseband version for the default phone.
 *
 * @param version baseband version
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    setBasebandVersionForPhone(phoneId, version);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    setBasebandVersionForPhone(phoneId, version);
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.isSpellCheckerEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return sService.isSpellCheckerEnabled();
    } catch (RemoteException e) {
        Log.e(TAG, "Error in isSpellCheckerEnabled:" + e);
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isSpellCheckerEnabled();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.security.keystore.KeyProtection.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds an instance of {@link KeyProtection}.
 *
 * @throws IllegalArgumentException if a required field is missing
 */

Body of Frist Method:
{
    return new KeyProtection(mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mEncryptionPaddings, mSignaturePaddings, mDigests, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment);
}
Body of Second Method:
{
    return new KeyProtection(mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mEncryptionPaddings, mSignaturePaddings, mDigests, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mBoundToSecureUserId, mCriticalToDeviceEncryption);
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.onTimeChanged:COMMENT
Method Modifier: private     
Comment:/**
 * Propagate the time change
 */

Body of Frist Method:
{
    mDelegator.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
    if (mOnTimeChangedListener != null) {
        mOnTimeChangedListener.onTimeChanged(mDelegator, getHour(), getMinute());
    }
}
Body of Second Method:
{
    mDelegator.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
    if (mOnTimeChangedListener != null) {
        mOnTimeChangedListener.onTimeChanged(mDelegator, getHour(), getMinute());
    }
    if (mAutoFillChangeListener != null) {
        mAutoFillChangeListener.onTimeChanged(mDelegator, getHour(), getMinute());
    }
}
------------------------
Find a silently evolved API code:android.app.SearchDialog.createContentView:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * We recreate the dialog view each time it becomes visible so as to limit
 * the scope of any problems with the contained resources.
 */

Body of Frist Method:
{
    setContentView(com.android.internal.R.layout.search_bar);
    // get the view elements for local access
    mSearchView = (SearchView) findViewById(com.android.internal.R.id.search_view);
    mSearchView.setIconified(false);
    mSearchView.setOnCloseListener(mOnCloseListener);
    mSearchView.setOnQueryTextListener(mOnQueryChangeListener);
    mSearchView.setOnSuggestionListener(mOnSuggestionSelectionListener);
    mSearchView.onActionViewExpanded();
    mCloseSearch = findViewById(com.android.internal.R.id.closeButton);
    mCloseSearch.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    // TODO: Move the badge logic to SearchView or move the badge to search_bar.xml
    mBadgeLabel = (TextView) mSearchView.findViewById(com.android.internal.R.id.search_badge);
    mSearchAutoComplete = (AutoCompleteTextView) mSearchView.findViewById(com.android.internal.R.id.search_src_text);
    mAppIcon = (ImageView) findViewById(com.android.internal.R.id.search_app_icon);
    mSearchPlate = mSearchView.findViewById(com.android.internal.R.id.search_plate);
    mWorkingSpinner = getContext().getDrawable(com.android.internal.R.drawable.search_spinner);
    // TODO: Restore the spinner for slow suggestion lookups
    // mSearchAutoComplete.setCompoundDrawablesWithIntrinsicBounds(
    // null, null, mWorkingSpinner, null);
    setWorking(false);
    // pre-hide all the extraneous elements
    mBadgeLabel.setVisibility(View.GONE);
    // Additional adjustments to make Dialog work for Search
    mSearchAutoCompleteImeOptions = mSearchAutoComplete.getImeOptions();
}
Body of Second Method:
{
    setContentView(com.android.internal.R.layout.search_bar);
    // get the view elements for local access
    mSearchView = findViewById(com.android.internal.R.id.search_view);
    mSearchView.setIconified(false);
    mSearchView.setOnCloseListener(mOnCloseListener);
    mSearchView.setOnQueryTextListener(mOnQueryChangeListener);
    mSearchView.setOnSuggestionListener(mOnSuggestionSelectionListener);
    mSearchView.onActionViewExpanded();
    mCloseSearch = findViewById(com.android.internal.R.id.closeButton);
    mCloseSearch.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    // TODO: Move the badge logic to SearchView or move the badge to search_bar.xml
    mBadgeLabel = (TextView) mSearchView.findViewById(com.android.internal.R.id.search_badge);
    mSearchAutoComplete = (AutoCompleteTextView) mSearchView.findViewById(com.android.internal.R.id.search_src_text);
    mAppIcon = findViewById(com.android.internal.R.id.search_app_icon);
    mSearchPlate = mSearchView.findViewById(com.android.internal.R.id.search_plate);
    mWorkingSpinner = getContext().getDrawable(com.android.internal.R.drawable.search_spinner);
    // TODO: Restore the spinner for slow suggestion lookups
    // mSearchAutoComplete.setCompoundDrawablesWithIntrinsicBounds(
    // null, null, mWorkingSpinner, null);
    setWorking(false);
    // pre-hide all the extraneous elements
    mBadgeLabel.setVisibility(View.GONE);
    // Additional adjustments to make Dialog work for Search
    mSearchAutoCompleteImeOptions = mSearchAutoComplete.getImeOptions();
}
------------------------
Find a silently evolved API code:android.widget.GridView.isCandidateSelection:COMMENT
Method Modifier: private     
Comment:/**
 * Is childIndex a candidate for next focus given the direction the focus
 * change is coming from?
 * @param childIndex The index to check.
 * @param direction The direction, one of
 * {FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD, FOCUS_BACKWARD}
 * @return Whether childIndex is a candidate.
 */

Body of Frist Method:
{
    final int count = getChildCount();
    final int invertedIndex = count - 1 - childIndex;
    int rowStart;
    int rowEnd;
    if (!mStackFromBottom) {
        rowStart = childIndex - (childIndex % mNumColumns);
        rowEnd = Math.max(rowStart + mNumColumns - 1, count);
    } else {
        rowEnd = count - 1 - (invertedIndex - (invertedIndex % mNumColumns));
        rowStart = Math.max(0, rowEnd - mNumColumns + 1);
    }
    switch(direction) {
        case View.FOCUS_RIGHT:
            // edge
            return childIndex == rowStart;
        case View.FOCUS_DOWN:
            // coming from top; only valid if in top row
            return rowStart == 0;
        case View.FOCUS_LEFT:
            // coming from right, must be on right edge
            return childIndex == rowEnd;
        case View.FOCUS_UP:
            // coming from bottom, need to be in last row
            return rowEnd == count - 1;
        case View.FOCUS_FORWARD:
            // coming from top-left, need to be first in top row
            return childIndex == rowStart && rowStart == 0;
        case View.FOCUS_BACKWARD:
            // coming from bottom-right, need to be last in bottom row
            return childIndex == rowEnd && rowEnd == count - 1;
        default:
            throw new IllegalArgumentException("direction must be one of " + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, " + "FOCUS_FORWARD, FOCUS_BACKWARD}.");
    }
}
Body of Second Method:
{
    final int count = getChildCount();
    final int invertedIndex = count - 1 - childIndex;
    int rowStart;
    int rowEnd;
    if (!mStackFromBottom) {
        rowStart = childIndex - (childIndex % mNumColumns);
        rowEnd = Math.min(rowStart + mNumColumns - 1, count);
    } else {
        rowEnd = count - 1 - (invertedIndex - (invertedIndex % mNumColumns));
        rowStart = Math.max(0, rowEnd - mNumColumns + 1);
    }
    switch(direction) {
        case View.FOCUS_RIGHT:
            // edge
            return childIndex == rowStart;
        case View.FOCUS_DOWN:
            // coming from top; only valid if in top row
            return rowStart == 0;
        case View.FOCUS_LEFT:
            // coming from right, must be on right edge
            return childIndex == rowEnd;
        case View.FOCUS_UP:
            // coming from bottom, need to be in last row
            return rowEnd == count - 1;
        case View.FOCUS_FORWARD:
            // coming from top-left, need to be first in top row
            return childIndex == rowStart && rowStart == 0;
        case View.FOCUS_BACKWARD:
            // coming from bottom-right, need to be last in bottom row
            return childIndex == rowEnd && rowEnd == count - 1;
        default:
            throw new IllegalArgumentException("direction must be one of " + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, " + "FOCUS_FORWARD, FOCUS_BACKWARD}.");
    }
}
------------------------
Find a silently evolved API code:android.os.StrictMode.writeGatheredViolationsToParcel:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    ArrayList<ViolationInfo> violations = gatheredViolations.get();
    if (violations == null) {
        p.writeInt(0);
    } else {
        p.writeInt(violations.size());
        for (int i = 0; i < violations.size(); ++i) {
            int start = p.dataPosition();
            violations.get(i).writeToParcel(p, 0);
            int size = p.dataPosition() - start;
            if (size > 10 * 1024) {
                Slog.d(TAG, "Wrote violation #" + i + " of " + violations.size() + ": " + (p.dataPosition() - start) + " bytes");
            }
        }
        if (LOG_V)
            Log.d(TAG, "wrote violations to response parcel; num=" + violations.size());
        // somewhat redundant, as we're about to null the threadlocal
        violations.clear();
    }
    gatheredViolations.set(null);
}
Body of Second Method:
{
    ArrayList<ViolationInfo> violations = gatheredViolations.get();
    if (violations == null) {
        p.writeInt(0);
    } else {
        // To avoid taking up too much transaction space, only include
        // details for the first 3 violations. Deep inside, CrashInfo
        // will truncate each stack trace to ~20kB.
        final int size = Math.min(violations.size(), 3);
        p.writeInt(size);
        for (int i = 0; i < size; i++) {
            violations.get(i).writeToParcel(p, 0);
        }
    }
    gatheredViolations.set(null);
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbInterface.setEndpoints:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Only used by UsbService implementation
 * @hide
 */

Body of Frist Method:
{
    mEndpoints = endpoints;
}
Body of Second Method:
{
    mEndpoints = Preconditions.checkArrayElementsNotNull(endpoints, "endpoints");
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfRenderer.Page.render:COMMENT
Method Modifier: public      
Comment:/**
 * Renders a page to a bitmap.
 * <p>
 * You may optionally specify a rectangular clip in the bitmap bounds. No rendering
 * outside the clip will be performed, hence it is your responsibility to initialize
 * the bitmap outside the clip.
 * </p>
 * <p>
 * You may optionally specify a matrix to transform the content from page coordinates
 * which are in points (1/72") to bitmap coordinates which are in pixels. If this
 * matrix is not provided this method will apply a transformation that will fit the
 * whole page to the destination clip if provided or the destination bitmap if no
 * clip is provided.
 * </p>
 * <p>
 * The clip and transformation are useful for implementing tile rendering where the
 * destination bitmap contains a portion of the image, for example when zooming.
 * Another useful application is for printing where the size of the bitmap holding
 * the page is too large and a client can render the page in stripes.
 * </p>
 * <p>
 * <strong>Note: </strong> The destination bitmap format must be
 * {@link Config#ARGB_8888 ARGB}.
 * </p>
 * <p>
 * <strong>Note: </strong> The optional transformation matrix must be affine as per
 * {@link android.graphics.Matrix#isAffine() Matrix.isAffine()}. Hence, you can specify
 * rotation, scaling, translation but not a perspective transformation.
 * </p>
 *
 * @param destination Destination bitmap to which to render.
 * @param destClip Optional clip in the bitmap bounds.
 * @param transform Optional transformation to apply when rendering.
 * @param renderMode The render mode.
 *
 * @see #RENDER_MODE_FOR_DISPLAY
 * @see #RENDER_MODE_FOR_PRINT
 */

Body of Frist Method:
{
    if (destination.getConfig() != Config.ARGB_8888) {
        throw new IllegalArgumentException("Unsupported pixel format");
    }
    if (destClip != null) {
        if (destClip.left < 0 || destClip.top < 0 || destClip.right > destination.getWidth() || destClip.bottom > destination.getHeight()) {
            throw new IllegalArgumentException("destBounds not in destination");
        }
    }
    if (transform != null && !transform.isAffine()) {
        throw new IllegalArgumentException("transform not affine");
    }
    if (renderMode != RENDER_MODE_FOR_PRINT && renderMode != RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Unsupported render mode");
    }
    if (renderMode == RENDER_MODE_FOR_PRINT && renderMode == RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Only single render mode supported");
    }
    final int contentLeft = (destClip != null) ? destClip.left : 0;
    final int contentTop = (destClip != null) ? destClip.top : 0;
    final int contentRight = (destClip != null) ? destClip.right : destination.getWidth();
    final int contentBottom = (destClip != null) ? destClip.bottom : destination.getHeight();
    final long transformPtr = (transform != null) ? transform.native_instance : 0;
    nativeRenderPage(mNativeDocument, mNativePage, destination, contentLeft, contentTop, contentRight, contentBottom, transformPtr, renderMode);
}
Body of Second Method:
{
    if (mNativePage == 0) {
        throw new NullPointerException();
    }
    destination = Preconditions.checkNotNull(destination, "bitmap null");
    if (destination.getConfig() != Config.ARGB_8888) {
        throw new IllegalArgumentException("Unsupported pixel format");
    }
    if (destClip != null) {
        if (destClip.left < 0 || destClip.top < 0 || destClip.right > destination.getWidth() || destClip.bottom > destination.getHeight()) {
            throw new IllegalArgumentException("destBounds not in destination");
        }
    }
    if (transform != null && !transform.isAffine()) {
        throw new IllegalArgumentException("transform not affine");
    }
    if (renderMode != RENDER_MODE_FOR_PRINT && renderMode != RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Unsupported render mode");
    }
    if (renderMode == RENDER_MODE_FOR_PRINT && renderMode == RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Only single render mode supported");
    }
    final int contentLeft = (destClip != null) ? destClip.left : 0;
    final int contentTop = (destClip != null) ? destClip.top : 0;
    final int contentRight = (destClip != null) ? destClip.right : destination.getWidth();
    final int contentBottom = (destClip != null) ? destClip.bottom : destination.getHeight();
    // If transform is not set, stretch page to whole clipped area
    if (transform == null) {
        int clipWidth = contentRight - contentLeft;
        int clipHeight = contentBottom - contentTop;
        transform = new Matrix();
        transform.postScale((float) clipWidth / getWidth(), (float) clipHeight / getHeight());
        transform.postTranslate(contentLeft, contentTop);
    }
    final long transformPtr = transform.native_instance;
    synchronized (sPdfiumLock) {
        nativeRenderPage(mNativeDocument, mNativePage, destination, contentLeft, contentTop, contentRight, contentBottom, transformPtr, renderMode);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.Builder.setLegacyStreamType:COMMENT
Method Modifier: public      
Comment:/**
 * Sets attributes as inferred from the legacy stream types.
 * Use this method when building an {@link AudioAttributes} instance to initialize some of
 * the attributes by information derived from a legacy stream type.
 * @param streamType one of {@link AudioManager#STREAM_VOICE_CALL},
 * {@link AudioManager#STREAM_SYSTEM}, {@link AudioManager#STREAM_RING},
 * {@link AudioManager#STREAM_MUSIC}, {@link AudioManager#STREAM_ALARM},
 * or {@link AudioManager#STREAM_NOTIFICATION}.
 * @return the same Builder instance.
 */

Body of Frist Method:
{
    return setInternalLegacyStreamType(streamType);
}
Body of Second Method:
{
    if (streamType == AudioManager.STREAM_ACCESSIBILITY) {
        throw new IllegalArgumentException("STREAM_ACCESSIBILITY is not a legacy stream " + "type that was used for audio playback");
    }
    return setInternalLegacyStreamType(streamType);
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getCarrierPackageNamesForIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return getCarrierPackageNamesForIntentAndPhone(intent, getDefaultPhone());
}
Body of Second Method:
{
    return getCarrierPackageNamesForIntentAndPhone(intent, getPhoneId());
}
------------------------
Find a silently evolved API code:android.widget.CompoundButton.setChecked:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */

Body of Frist Method:
{
    if (mChecked != checked) {
        mChecked = checked;
        refreshDrawableState();
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        mBroadcasting = false;
    }
}
Body of Second Method:
{
    if (mChecked != checked) {
        mCheckedFromResource = false;
        mChecked = checked;
        refreshDrawableState();
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        final AutofillManager afm = mContext.getSystemService(AutofillManager.class);
        if (afm != null) {
            afm.notifyValueChanged(this);
        }
        mBroadcasting = false;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getDomainSuffixMatch:COMMENT
Method Modifier: public      
Comment:/**
 * Get the domain_suffix_match value. See setDomSuffixMatch.
 * @return The domain value.
 */

Body of Frist Method:
{
    return getFieldValue(DOM_SUFFIX_MATCH_KEY, "");
}
Body of Second Method:
{
    return getFieldValue(DOM_SUFFIX_MATCH_KEY);
}
------------------------
Find a silently evolved API code:android.view.Display.getDisplayAdjustments:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the compatibility info used by this display instance.
 *
 * @return The display adjustments holder, or null if none is required.
 * @hide
 */

Body of Frist Method:
{
    return mDisplayAdjustments;
}
Body of Second Method:
{
    if (mResources != null) {
        final DisplayAdjustments currentAdjustements = mResources.getDisplayAdjustments();
        if (!mDisplayAdjustments.equals(currentAdjustements)) {
            mDisplayAdjustments = new DisplayAdjustments(currentAdjustements);
        }
    }
    return mDisplayAdjustments;
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.getValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return specific stats entry.
 */

Body of Frist Method:
{
    final Entry entry = recycle != null ? recycle : new Entry();
    entry.iface = iface[i];
    entry.uid = uid[i];
    entry.set = set[i];
    entry.tag = tag[i];
    entry.roaming = roaming[i];
    entry.rxBytes = rxBytes[i];
    entry.rxPackets = rxPackets[i];
    entry.txBytes = txBytes[i];
    entry.txPackets = txPackets[i];
    entry.operations = operations[i];
    return entry;
}
Body of Second Method:
{
    final Entry entry = recycle != null ? recycle : new Entry();
    entry.iface = iface[i];
    entry.uid = uid[i];
    entry.set = set[i];
    entry.tag = tag[i];
    entry.metered = metered[i];
    entry.roaming = roaming[i];
    entry.rxBytes = rxBytes[i];
    entry.rxPackets = rxPackets[i];
    entry.txBytes = txBytes[i];
    entry.txPackets = txPackets[i];
    entry.operations = operations[i];
    return entry;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.clearMutated:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.clearMutated();
    final ChildDrawable[] array = mLayerState.mChildren;
    final int N = mLayerState.mNum;
    for (int i = 0; i < N; i++) {
        final Drawable dr = array[i].mDrawable;
        if (dr != null) {
            dr.clearMutated();
        }
    }
    mMutated = false;
}
Body of Second Method:
{
    super.clearMutated();
    final ChildDrawable[] array = mLayerState.mChildren;
    final int N = mLayerState.mNumChildren;
    for (int i = 0; i < N; i++) {
        final Drawable dr = array[i].mDrawable;
        if (dr != null) {
            dr.clearMutated();
        }
    }
    mMutated = false;
}
------------------------
Find a silently evolved API code:android.view.Display.getMetrics:COMMENT
Method Modifier: public      
Comment:/**
 * Gets display metrics that describe the size and density of this display.
 * The size returned by this method does not necessarily represent the
 * actual raw size (native resolution) of the display.
 * <p>
 * 1. The returned size may be adjusted to exclude certain system decor elements
 * that are always visible.
 * </p><p>
 * 2. It may be scaled to provide compatibility with older applications that
 * were originally designed for smaller displays.
 * </p><p>
 * 3. It can be different depending on the WindowManager to which the display belongs.
 * </p><p>
 * - If requested from non-Activity context (e.g. Application context via
 * {@code (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE)})
 * metrics will report the size of the entire display based on current rotation and with
 * subtracted system decoration areas.
 * </p><p>
 * - If requested from activity (either using {@code getWindowManager()} or
 * {@code (WindowManager) getSystemService(Context.WINDOW_SERVICE)}) resulting metrics will
 * correspond to current app window metrics. In this case the size can be smaller than physical
 * size in multi-window mode.
 * </p>
 *
 * @param outMetrics A {@link DisplayMetrics} object to receive the metrics.
 */

Body of Frist Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(outMetrics, mDisplayAdjustments);
    }
}
Body of Second Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(outMetrics, getDisplayAdjustments());
    }
}
------------------------
Find a silently evolved API code:android.app.FragmentController.dispatchPictureInPictureModeChanged:COMMENT
Method Modifier: public      
Comment:/**
 * Lets all Fragments managed by the controller's FragmentManager know the picture-in-picture
 * mode of the activity changed.
 * <p>Call when the picture-in-picture mode of the activity changed.
 *
 * @see Fragment#onPictureInPictureModeChanged
 */

Body of Frist Method:
{
    mHost.mFragmentManager.dispatchPictureInPictureModeChanged(isInPictureInPictureMode);
}
Body of Second Method:
{
    mHost.mFragmentManager.dispatchPictureInPictureModeChanged(isInPictureInPictureMode, newConfig);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.bindListen:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, "bindListen fail, reason: bluetooth is off");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket ");
            mSocket = new LocalSocket(fd);
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket.getInputStream() ");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, "channel: " + channel);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, "bindListen, close mPfd: " + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
        return -1;
    }
    return ret;
}
Body of Second Method:
{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, "bindListen fail, reason: bluetooth is off");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (fd == null) {
                Log.e(TAG, "bindListen(), null file descriptor");
                return -1;
            }
            if (DBG)
                Log.d(TAG, "bindListen(), Create LocalSocket");
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket.getInputStream()");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, "channel: " + channel);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, "bindListen, close mPfd: " + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
        return -1;
    }
    return ret;
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.getAppWidgetInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */

Body of Frist Method:
{
    if (mService == null) {
        return null;
    }
    try {
        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            convertSizesToPixels(info);
        }
        return info;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (mService == null) {
        return null;
    }
    try {
        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            info.updateDimensions(mDisplayMetrics);
        }
        return info;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.findDrawableByLayerId:COMMENT
Method Modifier: public      
Comment:/**
 * Looks for a layer with the given ID and returns its {@link Drawable}.
 * <p>
 * If multiple layers are found for the given ID, returns the
 * {@link Drawable} for the matching layer at the highest index.
 *
 * @param id The layer ID to search for.
 * @return The {@link Drawable} for the highest-indexed layer that has the
 * given ID, or null if not found.
 */

Body of Frist Method:
{
    final ChildDrawable[] layers = mLayerState.mChildren;
    for (int i = mLayerState.mNum - 1; i >= 0; i--) {
        if (layers[i].mId == id) {
            return layers[i].mDrawable;
        }
    }
    return null;
}
Body of Second Method:
{
    final ChildDrawable[] layers = mLayerState.mChildren;
    for (int i = mLayerState.mNumChildren - 1; i >= 0; i--) {
        if (layers[i].mId == id) {
            return layers[i].mDrawable;
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.text.BidiFormatter.DirectionalityEstimator.getCachedDirectionality:COMMENT
Method Modifier: private     static      
Comment:/**
 * Gets the bidi character class, i.e. Character.getDirectionality(), of a given char, using
 * a cache for speed. Not designed for supplementary codepoints, whose results we do not
 * cache.
 */

Body of Frist Method:
{
    return c < DIR_TYPE_CACHE_SIZE ? DIR_TYPE_CACHE[c] : Character.getDirectionality(c);
}
Body of Second Method:
{
    return c < DIR_TYPE_CACHE_SIZE ? DIR_TYPE_CACHE[c] : getDirectionality(c);
}
------------------------
Find a silently evolved API code:android.widget.CalendarViewLegacyDelegate.WeekView.drawWeekSeparators:COMMENT
Method Modifier: private     
Comment:/**
 * Draws a horizontal line for separating the weeks.
 *
 * @param canvas The canvas to draw on.
 */

Body of Frist Method:
{
    // If it is the topmost fully visible child do not draw separator line
    int firstFullyVisiblePosition = mListView.getFirstVisiblePosition();
    if (mListView.getChildAt(0).getTop() < 0) {
        firstFullyVisiblePosition++;
    }
    if (firstFullyVisiblePosition == mWeek) {
        return;
    }
    mDrawPaint.setColor(mWeekSeparatorLineColor);
    mDrawPaint.setStrokeWidth(mWeekSeperatorLineWidth);
    float startX;
    float stopX;
    if (isLayoutRtl()) {
        startX = 0;
        stopX = mShowWeekNumber ? mWidth - mWidth / mNumCells : mWidth;
    } else {
        startX = mShowWeekNumber ? mWidth / mNumCells : 0;
        stopX = mWidth;
    }
    canvas.drawLine(startX, 0, stopX, 0, mDrawPaint);
}
Body of Second Method:
{
    // If it is the topmost fully visible child do not draw separator line
    int firstFullyVisiblePosition = mListView.getFirstVisiblePosition();
    if (mListView.getChildAt(0).getTop() < 0) {
        firstFullyVisiblePosition++;
    }
    if (firstFullyVisiblePosition == mWeek) {
        return;
    }
    mDrawPaint.setColor(mWeekSeparatorLineColor);
    mDrawPaint.setStrokeWidth(mWeekSeparatorLineWidth);
    float startX;
    float stopX;
    if (isLayoutRtl()) {
        startX = 0;
        stopX = mShowWeekNumber ? mWidth - mWidth / mNumCells : mWidth;
    } else {
        startX = mShowWeekNumber ? mWidth / mNumCells : 0;
        stopX = mWidth;
    }
    canvas.drawLine(startX, 0, stopX, 0, mDrawPaint);
}
------------------------
Find a silently evolved API code:android.os.StrictMode.VmPolicy.Builder.detectAll:COMMENT
Method Modifier: public      
Comment:/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of
 * SQLite cursors, Activities, and other closable objects
 * but will likely expand in future releases.
 */

Body of Frist Method:
{
    int flags = DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS | DETECT_VM_REGISTRATION_LEAKS | DETECT_VM_FILE_URI_EXPOSURE;
    // for apps to mark sockets that should be ignored
    if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
        flags |= DETECT_VM_CLEARTEXT_NETWORK;
    }
    return enable(flags);
}
Body of Second Method:
{
    detectLeakedSqlLiteObjects();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectActivityLeaks();
        detectLeakedClosableObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN) {
        detectLeakedRegistrationObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        detectFileUriExposure();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        // facility for apps to mark sockets that should be ignored
        if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
            detectCleartextNetwork();
        }
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectContentUriWithoutPermission();
        detectUntaggedSockets();
    }
    return this;
}
------------------------
Find a silently evolved API code:android.mtp.MtpDevice.open:COMMENT
Method Modifier: public      
Comment:/**
 * Opens the MTP device.  Once the device is open it takes ownership of the
 * {@link android.hardware.usb.UsbDeviceConnection}.
 * The connection will be closed when you call {@link #close()}
 * The connection will also be closed if this method fails.
 *
 * @param connection an open {@link android.hardware.usb.UsbDeviceConnection} for the device
 * @return true if the device was successfully opened.
 */

Body of Frist Method:
{
    boolean result = native_open(mDevice.getDeviceName(), connection.getFileDescriptor());
    if (!result) {
        connection.close();
    }
    return result;
}
Body of Second Method:
{
    boolean result = false;
    Context context = connection.getContext();
    synchronized (mLock) {
        if (context != null) {
            UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);
            if (!userManager.hasUserRestriction(UserManager.DISALLOW_USB_FILE_TRANSFER)) {
                result = native_open(mDevice.getDeviceName(), connection.getFileDescriptor());
            }
        }
        if (!result) {
            connection.close();
        } else {
            mConnection = connection;
            mCloseGuard.open("close");
        }
    }
    return result;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getUiSoundsStreamType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the stream type whose volume is driving the UI sounds volume.
 * UI sounds are screen lock/unlock, camera shutter, key clicks...
 * It is assumed that this stream type is also tied to ringer mode changes.
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getUiSoundsStreamType();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.getUiSoundsStreamType();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.Builder.setInternalLegacyStreamType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * For internal framework use only, enables building from hidden stream types.
 * @param streamType
 * @return the same Builder instance.
 */

Body of Frist Method:
{
    switch(streamType) {
        case AudioSystem.STREAM_VOICE_CALL:
            mContentType = CONTENT_TYPE_SPEECH;
            break;
        case AudioSystem.STREAM_SYSTEM_ENFORCED:
            mFlags |= FLAG_AUDIBILITY_ENFORCED;
        // intended fall through, attributes in common with STREAM_SYSTEM
        case AudioSystem.STREAM_SYSTEM:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_RING:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_MUSIC:
            mContentType = CONTENT_TYPE_MUSIC;
            break;
        case AudioSystem.STREAM_ALARM:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_NOTIFICATION:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_BLUETOOTH_SCO:
            mContentType = CONTENT_TYPE_SPEECH;
            mFlags |= FLAG_SCO;
            break;
        case AudioSystem.STREAM_DTMF:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_TTS:
            mContentType = CONTENT_TYPE_SPEECH;
            break;
        default:
            Log.e(TAG, "Invalid stream type " + streamType + " for AudioAttributes");
    }
    mUsage = usageForLegacyStreamType(streamType);
    return this;
}
Body of Second Method:
{
    switch(streamType) {
        case AudioSystem.STREAM_VOICE_CALL:
            mContentType = CONTENT_TYPE_SPEECH;
            break;
        case AudioSystem.STREAM_SYSTEM_ENFORCED:
            mFlags |= FLAG_AUDIBILITY_ENFORCED;
        // intended fall through, attributes in common with STREAM_SYSTEM
        case AudioSystem.STREAM_SYSTEM:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_RING:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_MUSIC:
            mContentType = CONTENT_TYPE_MUSIC;
            break;
        case AudioSystem.STREAM_ALARM:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_NOTIFICATION:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_BLUETOOTH_SCO:
            mContentType = CONTENT_TYPE_SPEECH;
            mFlags |= FLAG_SCO;
            break;
        case AudioSystem.STREAM_DTMF:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_TTS:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_ACCESSIBILITY:
            mContentType = CONTENT_TYPE_SPEECH;
            break;
        default:
            Log.e(TAG, "Invalid stream type " + streamType + " for AudioAttributes");
    }
    mUsage = usageForStreamType(streamType);
    return this;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.SurfaceUtils.checkHighSpeedSurfaceFormat:COMMENT
Method Modifier: private     static      
Comment:/**
 * A high speed output surface can only be preview or hardware encoder surface.
 *
 * @param surface The high speed output surface to be checked.
 */

Body of Frist Method:
{
    // TODO: remove this override since the default format should be
    // ImageFormat.PRIVATE. b/9487482
    // HAL_PIXEL_FORMAT_RGBA_8888 from graphics.h
    final int HAL_FORMAT_RGB_START = 1;
    // HAL_PIXEL_FORMAT_BGRA_8888 from graphics.h
    final int HAL_FORMAT_RGB_END = 5;
    int surfaceFormat = SurfaceUtils.getSurfaceFormat(surface);
    if (surfaceFormat >= HAL_FORMAT_RGB_START && surfaceFormat <= HAL_FORMAT_RGB_END) {
        surfaceFormat = ImageFormat.PRIVATE;
    }
    if (surfaceFormat != ImageFormat.PRIVATE) {
        throw new IllegalArgumentException("Surface format(" + surfaceFormat + ") is not" + " for preview or hardware video encoding!");
    }
}
Body of Second Method:
{
    int surfaceFormat = SurfaceUtils.getSurfaceFormat(surface);
    if (surfaceFormat != ImageFormat.PRIVATE) {
        throw new IllegalArgumentException("Surface format(" + surfaceFormat + ") is not" + " for preview or hardware video encoding!");
    }
}
------------------------
Find a silently evolved API code:javax.obex.ClientOperation.continueOperation:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Continues the operation since there is no data to read.
 * @param sendEmpty <code>true</code> if the operation should send an empty
 * packet or not send anything if there is no data to send
 * @param inStream <code>true</code> if the stream is input stream or is
 * output stream
 * @throws IOException if an IO error occurs
 */

Body of Frist Method:
{
    if (mGetOperation) {
        if ((inStream) && (!mOperationDone)) {
            // to deal with inputstream in get operation
            mParent.sendRequest(ObexHelper.OBEX_OPCODE_GET_FINAL, null, mReplyHeader, mPrivateInput, mSrmActive);
            /*
                  * Determine if that was not the last packet in the operation
                  */
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            } else {
                checkForSrm();
            }
            return true;
        } else if ((!inStream) && (!mOperationDone)) {
            if (mPrivateInput == null) {
                mPrivateInput = new PrivateInputStream(this);
            }
            sendRequest(ObexHelper.OBEX_OPCODE_GET);
            return true;
        } else if (mOperationDone) {
            return false;
        }
    } else {
        // PUT operation
        if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in put operation
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            sendRequest(ObexHelper.OBEX_OPCODE_PUT);
            return true;
        } else if ((inStream) && (!mOperationDone)) {
            // How to deal with inputstream  in put operation ?
            return false;
        } else if (mOperationDone) {
            return false;
        }
    }
    return false;
}
Body of Second Method:
{
    if (mGetOperation) {
        if ((inStream) && (!mOperationDone)) {
            // to deal with inputstream in get operation
            mParent.sendRequest(ObexHelper.OBEX_OPCODE_GET_FINAL, null, mReplyHeader, mPrivateInput, mSrmActive);
            /*
                  * Determine if that was not the last packet in the operation
                  */
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            } else {
                checkForSrm();
            }
            return true;
        } else if ((!inStream) && (!mOperationDone)) {
            if (mPrivateInput == null) {
                mPrivateInput = new PrivateInputStream(this);
            }
            if (!mGetFinalFlag) {
                sendRequest(ObexHelper.OBEX_OPCODE_GET);
            } else {
                sendRequest(ObexHelper.OBEX_OPCODE_GET_FINAL);
            }
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            }
            return true;
        } else if (mOperationDone) {
            return false;
        }
    } else {
        // PUT operation
        if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in put operation
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            sendRequest(ObexHelper.OBEX_OPCODE_PUT);
            return true;
        } else if ((inStream) && (!mOperationDone)) {
            // How to deal with inputstream  in put operation ?
            return false;
        } else if (mOperationDone) {
            return false;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.widget.NumberPicker.removeAllCallbacks:COMMENT
Method Modifier: private     
Comment:/**
 * Removes all pending callback from the message queue.
 */

Body of Frist Method:
{
    if (mChangeCurrentByOneFromLongPressCommand != null) {
        removeCallbacks(mChangeCurrentByOneFromLongPressCommand);
    }
    if (mSetSelectionCommand != null) {
        removeCallbacks(mSetSelectionCommand);
    }
    if (mBeginSoftInputOnLongPressCommand != null) {
        removeCallbacks(mBeginSoftInputOnLongPressCommand);
    }
    mPressedStateHelper.cancel();
}
Body of Second Method:
{
    if (mChangeCurrentByOneFromLongPressCommand != null) {
        removeCallbacks(mChangeCurrentByOneFromLongPressCommand);
    }
    if (mSetSelectionCommand != null) {
        mSetSelectionCommand.cancel();
    }
    if (mBeginSoftInputOnLongPressCommand != null) {
        removeCallbacks(mBeginSoftInputOnLongPressCommand);
    }
    mPressedStateHelper.cancel();
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.getHeight:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the height of the current drawing layer
 *
 * @return the height of the current drawing layer
 */

Body of Frist Method:
{
    return native_getHeight(mNativeCanvasWrapper);
}
Body of Second Method:
{
    return nGetHeight(mNativeCanvasWrapper);
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.setComponentName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mId = component.flattenToShortString();
}
Body of Second Method:
{
    mComponentName = component;
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.getEnabledSpellCheckers:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        final SpellCheckerInfo[] retval = sService.getEnabledSpellCheckers();
        if (DBG) {
            Log.d(TAG, "getEnabledSpellCheckers: " + (retval != null ? retval.length : "null"));
        }
        return retval;
    } catch (RemoteException e) {
        Log.e(TAG, "Error in getEnabledSpellCheckers: " + e);
        return null;
    }
}
Body of Second Method:
{
    try {
        final SpellCheckerInfo[] retval = mService.getEnabledSpellCheckers();
        if (DBG) {
            Log.d(TAG, "getEnabledSpellCheckers: " + (retval != null ? retval.length : "null"));
        }
        return retval;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.ClipDescription.getMimeTypeCount:COMMENT
Method Modifier: public      
Comment:/**
 * Return the number of MIME types the clip is available in.
 */

Body of Frist Method:
{
    return mMimeTypes.length;
}
Body of Second Method:
{
    return mMimeTypes.size();
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfEditor.write:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Writes the PDF file to the provided destination.
 * <p>
 * <strong>Note:</strong> This method takes ownership of the passed in file
 * descriptor and is responsible for closing it when writing completes.
 * </p>
 * @param output The destination.
 */

Body of Frist Method:
{
    try {
        throwIfClosed();
        nativeWrite(mNativeDocument, output.getFd());
    } finally {
        IoUtils.closeQuietly(output);
    }
}
Body of Second Method:
{
    try {
        throwIfClosed();
        synchronized (PdfRenderer.sPdfiumLock) {
            nativeWrite(mNativeDocument, output.getFd());
        }
    } finally {
        IoUtils.closeQuietly(output);
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.writeToStream:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Writes a serialized version of an Icon to the specified stream.
 *
 * @param stream The stream on which to serialize the Icon.
 * @hide
 */

Body of Frist Method:
{
    DataOutputStream dataStream = new DataOutputStream(stream);
    dataStream.writeInt(VERSION_STREAM_SERIALIZER);
    dataStream.writeByte(mType);
    switch(mType) {
        case TYPE_BITMAP:
            getBitmap().compress(Bitmap.CompressFormat.PNG, 100, dataStream);
            break;
        case TYPE_DATA:
            dataStream.writeInt(getDataLength());
            dataStream.write(getDataBytes(), getDataOffset(), getDataLength());
            break;
        case TYPE_RESOURCE:
            dataStream.writeUTF(getResPackage());
            dataStream.writeInt(getResId());
            break;
        case TYPE_URI:
            dataStream.writeUTF(getUriString());
            break;
    }
}
Body of Second Method:
{
    DataOutputStream dataStream = new DataOutputStream(stream);
    dataStream.writeInt(VERSION_STREAM_SERIALIZER);
    dataStream.writeByte(mType);
    switch(mType) {
        case TYPE_BITMAP:
        case TYPE_ADAPTIVE_BITMAP:
            getBitmap().compress(Bitmap.CompressFormat.PNG, 100, dataStream);
            break;
        case TYPE_DATA:
            dataStream.writeInt(getDataLength());
            dataStream.write(getDataBytes(), getDataOffset(), getDataLength());
            break;
        case TYPE_RESOURCE:
            dataStream.writeUTF(getResPackage());
            dataStream.writeInt(getResId());
            break;
        case TYPE_URI:
            dataStream.writeUTF(getUriString());
            break;
    }
}
------------------------
Find a silently evolved API code:android.graphics.PixelFormat.isPublicFormat:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Determine whether or not this is a public-visible and non-deprecated {@code format}.
 *
 * <p>In particular, {@code @hide} formats will return {@code false}.</p>
 *
 * <p>Any other indirect formats (such as {@code TRANSPARENT} or {@code TRANSLUCENT})
 * will return {@code false}.</p>
 *
 * @param format an integer format
 * @return a boolean
 *
 * @hide
 */

Body of Frist Method:
{
    switch(format) {
        case RGBA_8888:
        case RGBX_8888:
        case RGB_888:
        case RGB_565:
            return true;
    }
    return false;
}
Body of Second Method:
{
    switch(format) {
        case RGBA_8888:
        case RGBX_8888:
        case RGB_888:
        case RGB_565:
        case RGBA_F16:
        case RGBA_1010102:
            return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.text.method.WordIterator.prevBoundary:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the position of boundary preceding the given offset or
 * {@code DONE} if the given offset specifies the starting position.
 *
 * @param offset the given start position to search from.
 * @return the position of the last boundary preceding the given offset.
 */

Body of Frist Method:
{
    int shiftedOffset = offset - mOffsetShift;
    shiftedOffset = mIterator.preceding(shiftedOffset);
    if (shiftedOffset == BreakIterator.DONE) {
        return BreakIterator.DONE;
    }
    return shiftedOffset + mOffsetShift;
}
Body of Second Method:
{
    checkOffsetIsValid(offset);
    return mIterator.preceding(offset);
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getSimCountryIso:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the ISO country code equivalent for the SIM provider's country code.
 */

Body of Frist Method:
{
    return getSimCountryIsoForPhone(getDefaultPhone());
}
Body of Second Method:
{
    return getSimCountryIsoForPhone(getPhoneId());
}
------------------------
Find a silently evolved API code:android.telephony.DisconnectCause.toString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns descriptive string for the specified disconnect cause.
 */

Body of Frist Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        default:
            return "INVALID: " + cause;
    }
}
Body of Second Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        case DIALED_ON_WRONG_SLOT:
            return "DIALED_ON_WRONG_SLOT";
        case DIALED_CALL_FORWARDING_WHILE_ROAMING:
            return "DIALED_CALL_FORWARDING_WHILE_ROAMING";
        case IMEI_NOT_ACCEPTED:
            return "IMEI_NOT_ACCEPTED";
        case WIFI_LOST:
            return "WIFI_LOST";
        default:
            return "INVALID: " + cause;
    }
}
------------------------
Find a silently evolved API code:android.util.MemoryIntArray.get:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the value at a given index.
 *
 * @param index The index.
 * @return The value at this index.
 * @throws IOException If an error occurs while accessing the shared memory.
 */

Body of Frist Method:
{
    enforceNotClosed();
    enforceValidIndex(index);
    return nativeGet(mFd, mMemoryAddr, index, isOwner());
}
Body of Second Method:
{
    enforceNotClosed();
    enforceValidIndex(index);
    return nativeGet(mFd, mMemoryAddr, index);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getStreamMinVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the minimum volume index for a particular stream.
 *
 * @param streamType The stream type whose minimum volume index is returned.
 * @return The minimum valid volume index for the stream.
 * @see #getStreamVolume(int)
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getStreamMinVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.getStreamMinVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.extractAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a new bitmap that captures the alpha values of the original.
 * These values may be affected by the optional Paint parameter, which
 * can contain its own alpha, and may also contain a MaskFilter which
 * could change the actual dimensions of the resulting bitmap (e.g.
 * a blur maskfilter might enlarge the resulting bitmap). If offsetXY
 * is not null, it returns the amount to offset the returned bitmap so
 * that it will logically align with the original. For example, if the
 * paint contains a blur of radius 2, then offsetXY[] would contains
 * -2, -2, so that drawing the alpha bitmap offset by (-2, -2) and then
 * drawing the original would result in the blur visually aligning with
 * the original.
 *
 * <p>The initial density of the returned bitmap is the same as the original's.
 *
 * @param paint Optional paint used to modify the alpha values in the
 * resulting bitmap. Pass null for default behavior.
 * @param offsetXY Optional array that returns the X (index 0) and Y
 * (index 1) offset needed to position the returned bitmap
 * so that it visually lines up with the original.
 * @return new bitmap containing the (optionally modified by paint) alpha
 * channel of the original bitmap. This may be drawn with
 * Canvas.drawBitmap(), where the color(s) will be taken from the
 * paint that is passed to the draw call.
 */

Body of Frist Method:
{
    checkRecycled("Can't extractAlpha on a recycled bitmap");
    long nativePaint = paint != null ? paint.getNativeInstance() : 0;
    Bitmap bm = nativeExtractAlpha(mNativePtr, nativePaint, offsetXY);
    if (bm == null) {
        throw new RuntimeException("Failed to extractAlpha on Bitmap");
    }
    bm.mDensity = mDensity;
    return bm;
}
Body of Second Method:
{
    checkRecycled("Can't extractAlpha on a recycled bitmap");
    long nativePaint = paint != null ? paint.getNativeInstance() : 0;
    noteHardwareBitmapSlowCall();
    Bitmap bm = nativeExtractAlpha(mNativePtr, nativePaint, offsetXY);
    if (bm == null) {
        throw new RuntimeException("Failed to extractAlpha on Bitmap");
    }
    bm.mDensity = mDensity;
    return bm;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.setDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the drawable for the layer at the specified index.
 *
 * @param index The index of the layer to modify, must be in the range
 * {@code 0...getNumberOfLayers()-1}.
 * @param drawable The drawable to set for the layer.
 *
 * @see #getDrawable(int)
 * @attr ref android.R.styleable#LayerDrawableItem_drawable
 */

Body of Frist Method:
{
    if (index >= mLayerState.mNum) {
        throw new IndexOutOfBoundsException();
    }
    final ChildDrawable[] layers = mLayerState.mChildren;
    final ChildDrawable childDrawable = layers[index];
    if (childDrawable.mDrawable != null) {
        if (drawable != null) {
            final Rect bounds = childDrawable.mDrawable.getBounds();
            drawable.setBounds(bounds);
        }
        childDrawable.mDrawable.setCallback(null);
    }
    if (drawable != null) {
        drawable.setCallback(this);
    }
    childDrawable.mDrawable = drawable;
    mLayerState.invalidateCache();
    refreshChildPadding(index, childDrawable);
}
Body of Second Method:
{
    if (index >= mLayerState.mNumChildren) {
        throw new IndexOutOfBoundsException();
    }
    final ChildDrawable[] layers = mLayerState.mChildren;
    final ChildDrawable childDrawable = layers[index];
    if (childDrawable.mDrawable != null) {
        if (drawable != null) {
            final Rect bounds = childDrawable.mDrawable.getBounds();
            drawable.setBounds(bounds);
        }
        childDrawable.mDrawable.setCallback(null);
    }
    if (drawable != null) {
        drawable.setCallback(this);
    }
    childDrawable.mDrawable = drawable;
    mLayerState.invalidateCache();
    refreshChildPadding(index, childDrawable);
}
------------------------
Find a silently evolved API code:android.graphics.Path.op:COMMENT
Method Modifier: public      
Comment:/**
 * Set this path to the result of applying the Op to the two specified paths.
 * The resulting path will be constructed from non-overlapping contours.
 * The curve order is reduced where possible so that cubics may be turned
 * into quadratics, and quadratics maybe turned into lines.
 *
 * @param path1 The first operand (for difference, the minuend)
 * @param path2 The second operand (for difference, the subtrahend)
 *
 * @return True if operation succeeded, false otherwise and this path remains unmodified.
 *
 * @see Op
 * @see #op(Path, android.graphics.Path.Op)
 */

Body of Frist Method:
{
    if (native_op(path1.mNativePath, path2.mNativePath, op.ordinal(), this.mNativePath)) {
        isSimplePath = false;
        rects = null;
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (nOp(path1.mNativePath, path2.mNativePath, op.ordinal(), this.mNativePath)) {
        isSimplePath = false;
        rects = null;
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.ScanSettings.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(band);
    dest.writeInt(periodInMs);
    dest.writeInt(reportEvents);
    dest.writeInt(numBssidsPerScan);
    dest.writeInt(maxScansToCache);
    dest.writeInt(maxPeriodInMs);
    dest.writeInt(stepCount);
    dest.writeInt(isPnoScan ? 1 : 0);
    if (channels != null) {
        dest.writeInt(channels.length);
        for (int i = 0; i < channels.length; i++) {
            dest.writeInt(channels[i].frequency);
            dest.writeInt(channels[i].dwellTimeMS);
            dest.writeInt(channels[i].passive ? 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeIntArray(hiddenNetworkIds);
}
Body of Second Method:
{
    dest.writeInt(band);
    dest.writeInt(periodInMs);
    dest.writeInt(reportEvents);
    dest.writeInt(numBssidsPerScan);
    dest.writeInt(maxScansToCache);
    dest.writeInt(maxPeriodInMs);
    dest.writeInt(stepCount);
    dest.writeInt(isPnoScan ? 1 : 0);
    if (channels != null) {
        dest.writeInt(channels.length);
        for (int i = 0; i < channels.length; i++) {
            dest.writeInt(channels[i].frequency);
            dest.writeInt(channels[i].dwellTimeMS);
            dest.writeInt(channels[i].passive ? 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
    if (hiddenNetworks != null) {
        dest.writeInt(hiddenNetworks.length);
        for (int i = 0; i < hiddenNetworks.length; i++) {
            dest.writeString(hiddenNetworks[i].ssid);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteDatabase.updateWithOnConflict:COMMENT
Method Modifier: public      
Comment:/**
 * Convenience method for updating rows in the database.
 *
 * @param table the table to update in
 * @param values a map from column names to new column values. null is a
 * valid value that will be translated to NULL.
 * @param whereClause the optional WHERE clause to apply when updating.
 * Passing null will update all rows.
 * @param whereArgs You may include ?s in the where clause, which
 * will be replaced by the values from whereArgs. The values
 * will be bound as Strings.
 * @param conflictAlgorithm for update conflict resolver
 * @return the number of rows affected
 */

Body of Frist Method:
{
    if (values == null || values.size() == 0) {
        throw new IllegalArgumentException("Empty values");
    }
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder(120);
        sql.append("UPDATE ");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append(table);
        sql.append(" SET ");
        // move all bind args to one array
        int setValuesSize = values.size();
        int bindArgsSize = (whereArgs == null) ? setValuesSize : (setValuesSize + whereArgs.length);
        Object[] bindArgs = new Object[bindArgsSize];
        int i = 0;
        for (String colName : values.keySet()) {
            sql.append((i > 0) ? "," : "");
            sql.append(colName);
            bindArgs[i++] = values.get(colName);
            sql.append("=?");
        }
        if (whereArgs != null) {
            for (i = setValuesSize; i < bindArgsSize; i++) {
                bindArgs[i] = whereArgs[i - setValuesSize];
            }
        }
        if (!TextUtils.isEmpty(whereClause)) {
            sql.append(" WHERE ");
            sql.append(whereClause);
        }
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeUpdateDelete();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}
Body of Second Method:
{
    if (values == null || values.isEmpty()) {
        throw new IllegalArgumentException("Empty values");
    }
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder(120);
        sql.append("UPDATE ");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append(table);
        sql.append(" SET ");
        // move all bind args to one array
        int setValuesSize = values.size();
        int bindArgsSize = (whereArgs == null) ? setValuesSize : (setValuesSize + whereArgs.length);
        Object[] bindArgs = new Object[bindArgsSize];
        int i = 0;
        for (String colName : values.keySet()) {
            sql.append((i > 0) ? "," : "");
            sql.append(colName);
            bindArgs[i++] = values.get(colName);
            sql.append("=?");
        }
        if (whereArgs != null) {
            for (i = setValuesSize; i < bindArgsSize; i++) {
                bindArgs[i] = whereArgs[i - setValuesSize];
            }
        }
        if (!TextUtils.isEmpty(whereClause)) {
            sql.append(" WHERE ");
            sql.append(whereClause);
        }
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeUpdateDelete();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}
------------------------
Find a silently evolved API code:android.media.SoundPool.release:COMMENT
Method Modifier: public      final       
Comment:/**
 * Release the SoundPool resources.
 *
 * Release all memory and native resources used by the SoundPool
 * object. The SoundPool can no longer be used and the reference
 * should be set to null.
 */

Body of Frist Method:
{
    try {
        mAppOps.stopWatchingMode(mAppOpsCallback);
    } catch (RemoteException e) {
    // nothing to do here, the SoundPool is being released anyway
    }
    native_release();
}
Body of Second Method:
{
    baseRelease();
    native_release();
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbDeviceConnection.open:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    return native_open(name, pfd.getFileDescriptor());
}
Body of Second Method:
{
    mContext = context.getApplicationContext();
    boolean wasOpened = native_open(name, pfd.getFileDescriptor());
    if (wasOpened) {
        mCloseGuard.open("close");
    }
    return wasOpened;
}
------------------------
Find a silently evolved API code:android.graphics.Path.set:COMMENT
Method Modifier: public      
Comment:/**
 * Replace the contents of this with the contents of src.
 */

Body of Frist Method:
{
    if (this == src) {
        return;
    }
    isSimplePath = src.isSimplePath;
    native_set(mNativePath, src.mNativePath);
    if (!isSimplePath) {
        return;
    }
    if (rects != null && src.rects != null) {
        rects.set(src.rects);
    } else if (rects != null && src.rects == null) {
        rects.setEmpty();
    } else if (src.rects != null) {
        rects = new Region(src.rects);
    }
}
Body of Second Method:
{
    if (this == src) {
        return;
    }
    isSimplePath = src.isSimplePath;
    nSet(mNativePath, src.mNativePath);
    if (!isSimplePath) {
        return;
    }
    if (rects != null && src.rects != null) {
        rects.set(src.rects);
    } else if (rects != null && src.rects == null) {
        rects.setEmpty();
    } else if (src.rects != null) {
        rects = new Region(src.rects);
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.equals:COMMENT
Method Modifier: public      
Comment:/**
 * @return true if the signal strengths are the same
 */

Body of Frist Method:
{
    SignalStrength s;
    try {
        s = (SignalStrength) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mGsmSignalStrength == s.mGsmSignalStrength && mGsmBitErrorRate == s.mGsmBitErrorRate && mCdmaDbm == s.mCdmaDbm && mCdmaEcio == s.mCdmaEcio && mEvdoDbm == s.mEvdoDbm && mEvdoEcio == s.mEvdoEcio && mEvdoSnr == s.mEvdoSnr && mLteSignalStrength == s.mLteSignalStrength && mLteRsrp == s.mLteRsrp && mLteRsrq == s.mLteRsrq && mLteRssnr == s.mLteRssnr && mLteCqi == s.mLteCqi && mTdScdmaRscp == s.mTdScdmaRscp && isGsm == s.isGsm);
}
Body of Second Method:
{
    SignalStrength s;
    try {
        s = (SignalStrength) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mGsmSignalStrength == s.mGsmSignalStrength && mGsmBitErrorRate == s.mGsmBitErrorRate && mCdmaDbm == s.mCdmaDbm && mCdmaEcio == s.mCdmaEcio && mEvdoDbm == s.mEvdoDbm && mEvdoEcio == s.mEvdoEcio && mEvdoSnr == s.mEvdoSnr && mLteSignalStrength == s.mLteSignalStrength && mLteRsrp == s.mLteRsrp && mLteRsrq == s.mLteRsrq && mLteRssnr == s.mLteRssnr && mLteCqi == s.mLteCqi && mLteRsrpBoost == s.mLteRsrpBoost && mTdScdmaRscp == s.mTdScdmaRscp && isGsm == s.isGsm);
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.addExistingConnection:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Informs telecom of an existing connection which was added by the {@link ConnectionService}.
 *
 * @param callId The unique ID of the call being added.
 * @param connection The connection.
 */

Body of Frist Method:
{
    Log.v(this, "addExistingConnection: %s", callId);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.addExistingConnection(callId, connection);
        } catch (RemoteException ignored) {
        }
    }
}
Body of Second Method:
{
    Log.v(this, "addExistingConnection: %s", callId);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.addExistingConnection(callId, connection, Log.getExternalSession());
        } catch (RemoteException ignored) {
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.setHour:COMMENT
Method Modifier: public      
Comment:/**
 * Set the current hour.
 */

Body of Frist Method:
{
    setHourInternal(hour, false, true);
}
Body of Second Method:
{
    setHourInternal(hour, FROM_EXTERNAL_API, true);
}
------------------------
Find a silently evolved API code:android.net.NetworkCapabilities.getTransportTypes:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets all the transports set on this {@code NetworkCapability} instance.
 *
 * @return an array of {@code NetworkCapabilities.TRANSPORT_*} values
 * for this instance.
 * @hide
 */

Body of Frist Method:
{
    return enumerateBits(mTransportTypes);
}
Body of Second Method:
{
    return BitUtils.unpackBits(mTransportTypes);
}
------------------------
Find a silently evolved API code:android.webkit.WebViewUpdateService.getAllWebViewPackages:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Fetch all packages that could potentially implement WebView.
 */

Body of Frist Method:
{
    try {
        return getUpdateService().getAllWebViewPackages();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return getUpdateService().getAllWebViewPackages();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.preference.PreferenceActivity.finishPreferencePanel:COMMENT
Method Modifier: public      
Comment:/**
 * Called by a preference panel fragment to finish itself.
 *
 * @param caller The fragment that is asking to be finished.
 * @param resultCode Optional result code to send back to the original
 * launching fragment.
 * @param resultData Optional result data to send back to the original
 * launching fragment.
 */

Body of Frist Method:
{
    if (mSinglePane) {
        setResult(resultCode, resultData);
        finish();
    } else {
        // XXX be smarter about popping the stack.
        onBackPressed();
        if (caller != null) {
            if (caller.getTargetFragment() != null) {
                caller.getTargetFragment().onActivityResult(caller.getTargetRequestCode(), resultCode, resultData);
            }
        }
    }
}
Body of Second Method:
{
    // TODO: be smarter about popping the stack.
    onBackPressed();
    if (caller != null) {
        if (caller.getTargetFragment() != null) {
            caller.getTargetFragment().onActivityResult(caller.getTargetRequestCode(), resultCode, resultData);
        }
    }
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbPort.modeToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(mode) {
        case 0:
            return "none";
        case MODE_DFP:
            return "dfp";
        case MODE_UFP:
            return "ufp";
        case MODE_DUAL:
            return "dual";
        default:
            return Integer.toString(mode);
    }
}
Body of Second Method:
{
    switch(mode) {
        case MODE_NONE:
            return "none";
        case MODE_DFP:
            return "dfp";
        case MODE_UFP:
            return "ufp";
        case MODE_DUAL:
            return "dual";
        default:
            return Integer.toString(mode);
    }
}
------------------------
Find a silently evolved API code:android.text.method.WordIterator.getPunctuationBeginning:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * If <code>offset</code> is within a group of punctuation as defined
 * by {@link #isPunctuation(int)}, returns the index of the first character
 * of that group, otherwise returns BreakIterator.DONE.
 *
 * @param offset the offset to search from.
 */

Body of Frist Method:
{
    while (offset != BreakIterator.DONE && !isPunctuationStartBoundary(offset)) {
        offset = prevBoundary(offset);
    }
    // No need to shift offset, prevBoundary handles that.
    return offset;
}
Body of Second Method:
{
    checkOffsetIsValid(offset);
    while (offset != BreakIterator.DONE && !isPunctuationStartBoundary(offset)) {
        offset = prevBoundary(offset);
    }
    // No need to shift offset, prevBoundary handles that.
    return offset;
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.capabilityToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of a capability. For example,
 * {@link #CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT} is represented
 * by the string CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT.
 *
 * @param capability The capability.
 * @return The string representation.
 */

Body of Frist Method:
{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return "CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return "CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return "CAPABILITY_CAN_FILTER_KEY_EVENTS";
        case CAPABILITY_CAN_CONTROL_MAGNIFICATION:
            return "CAPABILITY_CAN_CONTROL_MAGNIFICATION";
        case CAPABILITY_CAN_PERFORM_GESTURES:
            return "CAPABILITY_CAN_PERFORM_GESTURES";
        default:
            return "UNKNOWN";
    }
}
Body of Second Method:
{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return "CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return "CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return "CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS";
        case CAPABILITY_CAN_CONTROL_MAGNIFICATION:
            return "CAPABILITY_CAN_CONTROL_MAGNIFICATION";
        case CAPABILITY_CAN_PERFORM_GESTURES:
            return "CAPABILITY_CAN_PERFORM_GESTURES";
        case CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES:
            return "CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES";
        default:
            return "UNKNOWN";
    }
}
------------------------
Find a silently evolved API code:android.content.IntentSender.getTargetPackage:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated Renamed to {@link #getCreatorPackage()}.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}
Body of Second Method:
{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}
------------------------
Find a silently evolved API code:android.app.DownloadManager.getDownloadUri:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the DownloadProvider URI for the download with the given ID.
 *
 * @hide
 */

Body of Frist Method:
{
    return ContentUris.withAppendedId(mBaseUri, id);
}
Body of Second Method:
{
    return ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);
}
------------------------
Find a silently evolved API code:android.media.midi.MidiDevice.openOutputPort:COMMENT
Method Modifier: public      
Comment:/**
 * Called to open a {@link MidiOutputPort} for the specified port number.
 *
 * An output port may be opened by multiple applications.
 *
 * @param portNumber the number of the output port to open
 * @return the {@link MidiOutputPort} if the open is successful,
 * or null in case of failure.
 */

Body of Frist Method:
{
    if (mIsDeviceClosed) {
        return null;
    }
    try {
        IBinder token = new Binder();
        ParcelFileDescriptor pfd = mDeviceServer.openOutputPort(token, portNumber);
        if (pfd == null) {
            return null;
        }
        return new MidiOutputPort(mDeviceServer, token, pfd, portNumber);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in openOutputPort");
        return null;
    }
}
Body of Second Method:
{
    if (mIsDeviceClosed) {
        return null;
    }
    try {
        IBinder token = new Binder();
        FileDescriptor fd = mDeviceServer.openOutputPort(token, portNumber);
        if (fd == null) {
            return null;
        }
        return new MidiOutputPort(mDeviceServer, token, fd, portNumber);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in openOutputPort");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path.transform:COMMENT
Method Modifier: public      
Comment:/**
 * Transform the points in this path by matrix, and write the answer
 * into dst. If dst is null, then the the original path is modified.
 *
 * @param matrix The matrix to apply to the path
 * @param dst    The transformed path is written here. If dst is null,
 * then the the original path is modified
 */

Body of Frist Method:
{
    long dstNative = 0;
    if (dst != null) {
        dst.isSimplePath = false;
        dstNative = dst.mNativePath;
    }
    native_transform(mNativePath, matrix.native_instance, dstNative);
}
Body of Second Method:
{
    long dstNative = 0;
    if (dst != null) {
        dst.isSimplePath = false;
        dstNative = dst.mNativePath;
    }
    nTransform(mNativePath, matrix.native_instance, dstNative);
}
------------------------
Find a silently evolved API code:android.graphics.Path.moveTo:COMMENT
Method Modifier: public      
Comment:/**
 * Set the beginning of the next contour to the point (x,y).
 *
 * @param x The x-coordinate of the start of a new contour
 * @param y The y-coordinate of the start of a new contour
 */

Body of Frist Method:
{
    native_moveTo(mNativePath, x, y);
}
Body of Second Method:
{
    nMoveTo(mNativePath, x, y);
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.getInstance:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Retrieve the global TextServicesManager instance, creating it if it doesn't already exist.
 * @hide
 */

Body of Frist Method:
{
    synchronized (TextServicesManager.class) {
        if (sInstance != null) {
            return sInstance;
        }
        sInstance = new TextServicesManager();
    }
    return sInstance;
}
Body of Second Method:
{
    synchronized (TextServicesManager.class) {
        if (sInstance == null) {
            try {
                sInstance = new TextServicesManager();
            } catch (ServiceNotFoundException e) {
                throw new IllegalStateException(e);
            }
        }
        return sInstance;
    }
}
------------------------
Find a silently evolved API code:android.app.SearchManager.getAssistIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets an intent for launching installed assistant activity, or null if not available.
 * @return The assist intent.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        Intent intent = new Intent(Intent.ACTION_ASSIST);
        if (inclContext) {
            IActivityManager am = ActivityManagerNative.getDefault();
            Bundle extras = am.getAssistContextExtras(ActivityManager.ASSIST_CONTEXT_BASIC);
            if (extras != null) {
                intent.replaceExtras(extras);
            }
        }
        return intent;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        Intent intent = new Intent(Intent.ACTION_ASSIST);
        if (inclContext) {
            IActivityManager am = ActivityManager.getService();
            Bundle extras = am.getAssistContextExtras(ActivityManager.ASSIST_CONTEXT_BASIC);
            if (extras != null) {
                intent.replaceExtras(extras);
            }
        }
        return intent;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.provider.DocumentsContract.buildHomeUri:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Builds URI for user home directory on external (local) storage.
 * {@hide}
 */

Body of Frist Method:
{
    // direct coupling, but not ideal.
    return DocumentsContract.buildRootUri("com.android.externalstorage.documents", "home");
}
Body of Second Method:
{
    // direct coupling, but not ideal.
    return DocumentsContract.buildRootUri(EXTERNAL_STORAGE_PROVIDER_AUTHORITY, "home");
}
------------------------
Find a silently evolved API code:android.media.AudioManager.unloadSoundEffects:COMMENT
Method Modifier: public      
Comment:/**
 * Unload Sound effects.
 * This method can be called to free some memory when
 * sound effects are disabled.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.unloadSoundEffects();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.unloadSoundEffects();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.skew:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcat the current matrix with the specified skew.
 *
 * @param sx The amount to skew in X
 * @param sy The amount to skew in Y
 */

Body of Frist Method:
{
    native_skew(mNativeCanvasWrapper, sx, sy);
}
Body of Second Method:
{
    if (sx == 0.0f && sy == 0.0f)
        return;
    nSkew(mNativeCanvasWrapper, sx, sy);
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.animateBasedOnTime:COMMENT
Method Modifier: default     
Comment:/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code> has been exceeded and the animation should be ended.
 */

Body of Frist Method:
{
    boolean done = false;
    if (mRunning) {
        final long scaledDuration = getScaledDuration();
        final float fraction = scaledDuration > 0 ? (float) (currentTime - mStartTime) / scaledDuration : 1f;
        final float lastFraction = mOverallFraction;
        final boolean newIteration = (int) fraction > (int) lastFraction;
        final boolean lastIterationFinished = (fraction >= mRepeatCount + 1) && (mRepeatCount != INFINITE);
        if (scaledDuration == 0) {
            // 0 duration animator, ignore the repeat count and skip to the end
            done = true;
        } else if (newIteration && !lastIterationFinished) {
            // Time to repeat
            if (mListeners != null) {
                int numListeners = mListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    mListeners.get(i).onAnimationRepeat(this);
                }
            }
        } else if (lastIterationFinished) {
            done = true;
        }
        mOverallFraction = clampFraction(fraction);
        float currentIterationFraction = getCurrentIterationFraction(mOverallFraction);
        animateValue(currentIterationFraction);
    }
    return done;
}
Body of Second Method:
{
    boolean done = false;
    if (mRunning) {
        final long scaledDuration = getScaledDuration();
        final float fraction = scaledDuration > 0 ? (float) (currentTime - mStartTime) / scaledDuration : 1f;
        final float lastFraction = mOverallFraction;
        final boolean newIteration = (int) fraction > (int) lastFraction;
        final boolean lastIterationFinished = (fraction >= mRepeatCount + 1) && (mRepeatCount != INFINITE);
        if (scaledDuration == 0) {
            // 0 duration animator, ignore the repeat count and skip to the end
            done = true;
        } else if (newIteration && !lastIterationFinished) {
            // Time to repeat
            if (mListeners != null) {
                int numListeners = mListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    mListeners.get(i).onAnimationRepeat(this);
                }
            }
        } else if (lastIterationFinished) {
            done = true;
        }
        mOverallFraction = clampFraction(fraction);
        float currentIterationFraction = getCurrentIterationFraction(mOverallFraction, mReversing);
        animateValue(currentIterationFraction);
    }
    return done;
}
------------------------
Find a silently evolved API code:android.app.FragmentController.dispatchMultiWindowModeChanged:COMMENT
Method Modifier: public      
Comment:/**
 * Lets all Fragments managed by the controller's FragmentManager know the multi-window mode of
 * the activity changed.
 * <p>Call when the multi-window mode of the activity changed.
 *
 * @see Fragment#onMultiWindowModeChanged
 */

Body of Frist Method:
{
    mHost.mFragmentManager.dispatchMultiWindowModeChanged(isInMultiWindowMode);
}
Body of Second Method:
{
    mHost.mFragmentManager.dispatchMultiWindowModeChanged(isInMultiWindowMode, newConfig);
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setNetworkCountryIso:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the ISO country code equivalent of the current registered
 * operator's MCC (Mobile Country Code).
 * @param iso the ISO country code equivalent of the current registered
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    setNetworkCountryIsoForPhone(phoneId, iso);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    setNetworkCountryIsoForPhone(phoneId, iso);
}
------------------------
Find a silently evolved API code:android.view.MenuInflater.MenuState.readItem:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the parser is pointing to an item tag.
 */

Body of Frist Method:
{
    TypedArray a = mContext.obtainStyledAttributes(attrs, com.android.internal.R.styleable.MenuItem);
    // Inherit attributes from the group as default value
    itemId = a.getResourceId(com.android.internal.R.styleable.MenuItem_id, defaultItemId);
    final int category = a.getInt(com.android.internal.R.styleable.MenuItem_menuCategory, groupCategory);
    final int order = a.getInt(com.android.internal.R.styleable.MenuItem_orderInCategory, groupOrder);
    itemCategoryOrder = (category & Menu.CATEGORY_MASK) | (order & Menu.USER_MASK);
    itemTitle = a.getText(com.android.internal.R.styleable.MenuItem_title);
    itemTitleCondensed = a.getText(com.android.internal.R.styleable.MenuItem_titleCondensed);
    itemIconResId = a.getResourceId(com.android.internal.R.styleable.MenuItem_icon, 0);
    itemAlphabeticShortcut = getShortcut(a.getString(com.android.internal.R.styleable.MenuItem_alphabeticShortcut));
    itemNumericShortcut = getShortcut(a.getString(com.android.internal.R.styleable.MenuItem_numericShortcut));
    if (a.hasValue(com.android.internal.R.styleable.MenuItem_checkable)) {
        // Item has attribute checkable, use it
        itemCheckable = a.getBoolean(com.android.internal.R.styleable.MenuItem_checkable, false) ? 1 : 0;
    } else {
        // Item does not have attribute, use the group's (group can have one more state
        // for checkable that represents the exclusive checkable)
        itemCheckable = groupCheckable;
    }
    itemChecked = a.getBoolean(com.android.internal.R.styleable.MenuItem_checked, defaultItemChecked);
    itemVisible = a.getBoolean(com.android.internal.R.styleable.MenuItem_visible, groupVisible);
    itemEnabled = a.getBoolean(com.android.internal.R.styleable.MenuItem_enabled, groupEnabled);
    itemShowAsAction = a.getInt(com.android.internal.R.styleable.MenuItem_showAsAction, -1);
    itemListenerMethodName = a.getString(com.android.internal.R.styleable.MenuItem_onClick);
    itemActionViewLayout = a.getResourceId(com.android.internal.R.styleable.MenuItem_actionLayout, 0);
    itemActionViewClassName = a.getString(com.android.internal.R.styleable.MenuItem_actionViewClass);
    itemActionProviderClassName = a.getString(com.android.internal.R.styleable.MenuItem_actionProviderClass);
    final boolean hasActionProvider = itemActionProviderClassName != null;
    if (hasActionProvider && itemActionViewLayout == 0 && itemActionViewClassName == null) {
        itemActionProvider = newInstance(itemActionProviderClassName, ACTION_PROVIDER_CONSTRUCTOR_SIGNATURE, mActionProviderConstructorArguments);
    } else {
        if (hasActionProvider) {
            Log.w(LOG_TAG, "Ignoring attribute 'actionProviderClass'." + " Action view already specified.");
        }
        itemActionProvider = null;
    }
    a.recycle();
    itemAdded = false;
}
Body of Second Method:
{
    TypedArray a = mContext.obtainStyledAttributes(attrs, com.android.internal.R.styleable.MenuItem);
    // Inherit attributes from the group as default value
    itemId = a.getResourceId(com.android.internal.R.styleable.MenuItem_id, defaultItemId);
    final int category = a.getInt(com.android.internal.R.styleable.MenuItem_menuCategory, groupCategory);
    final int order = a.getInt(com.android.internal.R.styleable.MenuItem_orderInCategory, groupOrder);
    itemCategoryOrder = (category & Menu.CATEGORY_MASK) | (order & Menu.USER_MASK);
    itemTitle = a.getText(com.android.internal.R.styleable.MenuItem_title);
    itemTitleCondensed = a.getText(com.android.internal.R.styleable.MenuItem_titleCondensed);
    itemIconResId = a.getResourceId(com.android.internal.R.styleable.MenuItem_icon, 0);
    if (a.hasValue(com.android.internal.R.styleable.MenuItem_iconTintMode)) {
        itemIconTintMode = Drawable.parseTintMode(a.getInt(com.android.internal.R.styleable.MenuItem_iconTintMode, -1), itemIconTintMode);
    } else {
        // Reset to null so that it's not carried over to the next item
        itemIconTintMode = null;
    }
    if (a.hasValue(com.android.internal.R.styleable.MenuItem_iconTint)) {
        itemIconTintList = a.getColorStateList(com.android.internal.R.styleable.MenuItem_iconTint);
    } else {
        // Reset to null so that it's not carried over to the next item
        itemIconTintList = null;
    }
    itemAlphabeticShortcut = getShortcut(a.getString(com.android.internal.R.styleable.MenuItem_alphabeticShortcut));
    itemAlphabeticModifiers = a.getInt(com.android.internal.R.styleable.MenuItem_alphabeticModifiers, KeyEvent.META_CTRL_ON);
    itemNumericShortcut = getShortcut(a.getString(com.android.internal.R.styleable.MenuItem_numericShortcut));
    itemNumericModifiers = a.getInt(com.android.internal.R.styleable.MenuItem_numericModifiers, KeyEvent.META_CTRL_ON);
    if (a.hasValue(com.android.internal.R.styleable.MenuItem_checkable)) {
        // Item has attribute checkable, use it
        itemCheckable = a.getBoolean(com.android.internal.R.styleable.MenuItem_checkable, false) ? 1 : 0;
    } else {
        // Item does not have attribute, use the group's (group can have one more state
        // for checkable that represents the exclusive checkable)
        itemCheckable = groupCheckable;
    }
    itemChecked = a.getBoolean(com.android.internal.R.styleable.MenuItem_checked, defaultItemChecked);
    itemVisible = a.getBoolean(com.android.internal.R.styleable.MenuItem_visible, groupVisible);
    itemEnabled = a.getBoolean(com.android.internal.R.styleable.MenuItem_enabled, groupEnabled);
    itemShowAsAction = a.getInt(com.android.internal.R.styleable.MenuItem_showAsAction, -1);
    itemListenerMethodName = a.getString(com.android.internal.R.styleable.MenuItem_onClick);
    itemActionViewLayout = a.getResourceId(com.android.internal.R.styleable.MenuItem_actionLayout, 0);
    itemActionViewClassName = a.getString(com.android.internal.R.styleable.MenuItem_actionViewClass);
    itemActionProviderClassName = a.getString(com.android.internal.R.styleable.MenuItem_actionProviderClass);
    final boolean hasActionProvider = itemActionProviderClassName != null;
    if (hasActionProvider && itemActionViewLayout == 0 && itemActionViewClassName == null) {
        itemActionProvider = newInstance(itemActionProviderClassName, ACTION_PROVIDER_CONSTRUCTOR_SIGNATURE, mActionProviderConstructorArguments);
    } else {
        if (hasActionProvider) {
            Log.w(LOG_TAG, "Ignoring attribute 'actionProviderClass'." + " Action view already specified.");
        }
        itemActionProvider = null;
    }
    itemContentDescription = a.getText(com.android.internal.R.styleable.MenuItem_contentDescription);
    itemTooltipText = a.getText(com.android.internal.R.styleable.MenuItem_tooltipText);
    a.recycle();
    itemAdded = false;
}
------------------------
Find a silently evolved API code:android.text.StaticLayout.generate:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    // TODO: also respect LocaleSpan within the text
    b.setLocale(paint.getTextLocale());
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.max(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += widths[j];
                    }
                }
                flag |= flags[i] & TAB_MASK;
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
Body of Second Method:
{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    // TODO: also respect LocaleSpan within the text
    b.setLocale(paint.getTextLocale());
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency, // TODO: Support more justification mode, e.g. letter spacing, stretching.
        b.mJustificationMode != Layout.JUSTIFICATION_MODE_NONE);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.max(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += widths[j];
                    }
                }
                flag |= flags[i] & TAB_MASK;
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
------------------------
Find a silently evolved API code:android.content.res.AssetManager.getThemeValue:COMMENT
Method Modifier: default     final       
Comment:/**
 * Populates {@code outValue} with the data associated with a particular
 * resource identifier for the current configuration. Resolves theme
 * attributes against the specified theme.
 *
 * @param theme the native pointer of the theme
 * @param resId the resource identifier to load
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */

Body of Frist Method:
{
    final int block = loadThemeAttributeValue(theme, resId, outValue, resolveRefs);
    if (block < 0) {
        return false;
    }
    if (outValue.type == TypedValue.TYPE_STRING) {
        final StringBlock[] blocks = ensureStringBlocks();
        outValue.string = blocks[block].get(outValue.data);
    }
    return true;
}
Body of Second Method:
{
    final int block = loadThemeAttributeValue(theme, resId, outValue, resolveRefs);
    if (block < 0) {
        return false;
    }
    // Convert the changing configurations flags populated by native code.
    outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
    if (outValue.type == TypedValue.TYPE_STRING) {
        final StringBlock[] blocks = ensureStringBlocks();
        outValue.string = blocks[block].get(outValue.data);
    }
    return true;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onReceive:COMMENT
Method Modifier: public      
Comment:/**
 * Intercept standard device administrator broadcasts.  Implementations
 * should not override this method; it is better to implement the
 * convenience callbacks for each action.
 */

Body of Frist Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent);
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent);
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent);
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent);
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_CHOOSE_PRIVATE_KEY_ALIAS.equals(action)) {
        int uid = intent.getIntExtra(EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, -1);
        Uri uri = intent.getParcelableExtra(EXTRA_CHOOSE_PRIVATE_KEY_URI);
        String alias = intent.getStringExtra(EXTRA_CHOOSE_PRIVATE_KEY_ALIAS);
        String chosenAlias = onChoosePrivateKeyAlias(context, intent, uid, uri, alias);
        setResultData(chosenAlias);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    } else if (ACTION_NOTIFY_PENDING_SYSTEM_UPDATE.equals(action)) {
        long receivedTime = intent.getLongExtra(EXTRA_SYSTEM_UPDATE_RECEIVED_TIME, -1);
        onSystemUpdatePending(context, intent, receivedTime);
    } else if (ACTION_BUGREPORT_SHARING_DECLINED.equals(action)) {
        onBugreportSharingDeclined(context, intent);
    } else if (ACTION_BUGREPORT_SHARE.equals(action)) {
        String bugreportFileHash = intent.getStringExtra(EXTRA_BUGREPORT_HASH);
        onBugreportShared(context, intent, bugreportFileHash);
    } else if (ACTION_BUGREPORT_FAILED.equals(action)) {
        int failureCode = intent.getIntExtra(EXTRA_BUGREPORT_FAILURE_REASON, BUGREPORT_FAILURE_FAILED_COMPLETING);
        onBugreportFailed(context, intent, failureCode);
    } else if (ACTION_SECURITY_LOGS_AVAILABLE.equals(action)) {
        onSecurityLogsAvailable(context, intent);
    }
}
Body of Second Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_CHOOSE_PRIVATE_KEY_ALIAS.equals(action)) {
        int uid = intent.getIntExtra(EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, -1);
        Uri uri = intent.getParcelableExtra(EXTRA_CHOOSE_PRIVATE_KEY_URI);
        String alias = intent.getStringExtra(EXTRA_CHOOSE_PRIVATE_KEY_ALIAS);
        String chosenAlias = onChoosePrivateKeyAlias(context, intent, uid, uri, alias);
        setResultData(chosenAlias);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    } else if (ACTION_NOTIFY_PENDING_SYSTEM_UPDATE.equals(action)) {
        long receivedTime = intent.getLongExtra(EXTRA_SYSTEM_UPDATE_RECEIVED_TIME, -1);
        onSystemUpdatePending(context, intent, receivedTime);
    } else if (ACTION_BUGREPORT_SHARING_DECLINED.equals(action)) {
        onBugreportSharingDeclined(context, intent);
    } else if (ACTION_BUGREPORT_SHARE.equals(action)) {
        String bugreportFileHash = intent.getStringExtra(EXTRA_BUGREPORT_HASH);
        onBugreportShared(context, intent, bugreportFileHash);
    } else if (ACTION_BUGREPORT_FAILED.equals(action)) {
        int failureCode = intent.getIntExtra(EXTRA_BUGREPORT_FAILURE_REASON, BUGREPORT_FAILURE_FAILED_COMPLETING);
        onBugreportFailed(context, intent, failureCode);
    } else if (ACTION_SECURITY_LOGS_AVAILABLE.equals(action)) {
        onSecurityLogsAvailable(context, intent);
    } else if (ACTION_NETWORK_LOGS_AVAILABLE.equals(action)) {
        long batchToken = intent.getLongExtra(EXTRA_NETWORK_LOGS_TOKEN, -1);
        int networkLogsCount = intent.getIntExtra(EXTRA_NETWORK_LOGS_COUNT, 0);
        onNetworkLogsAvailable(context, intent, batchToken, networkLogsCount);
    } else if (ACTION_USER_ADDED.equals(action)) {
        onUserAdded(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_REMOVED.equals(action)) {
        onUserRemoved(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    }
}
------------------------
Find a silently evolved API code:android.os.StrictMode.conditionallyEnableDebugLogging:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Enable DropBox logging for debug phone builds.
 *
 * @hide
 */

Body of Frist Method:
{
    boolean doFlashes = SystemProperties.getBoolean(VISUAL_PROPERTY, false) && !amTheSystemServerProcess();
    final boolean suppress = SystemProperties.getBoolean(DISABLE_PROPERTY, false);
    // Similar logic also appears in ActivityThread.java for system apps.
    if (!doFlashes && (IS_USER_BUILD || suppress)) {
        setCloseGuardEnabled(false);
        return false;
    }
    // check above.
    if (IS_ENG_BUILD) {
        doFlashes = true;
    }
    // Thread policy controls BlockGuard.
    int threadPolicyMask = StrictMode.DETECT_DISK_WRITE | StrictMode.DETECT_DISK_READ | StrictMode.DETECT_NETWORK;
    if (!IS_USER_BUILD) {
        threadPolicyMask |= StrictMode.PENALTY_DROPBOX;
    }
    if (doFlashes) {
        threadPolicyMask |= StrictMode.PENALTY_FLASH;
    }
    StrictMode.setThreadPolicyMask(threadPolicyMask);
    // and instance counting.
    if (IS_USER_BUILD) {
        setCloseGuardEnabled(false);
    } else {
        VmPolicy.Builder policyBuilder = new VmPolicy.Builder().detectAll().penaltyDropBox();
        if (IS_ENG_BUILD) {
            policyBuilder.penaltyLog();
        }
        setVmPolicy(policyBuilder.build());
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
    }
    return true;
}
Body of Second Method:
{
    boolean doFlashes = SystemProperties.getBoolean(VISUAL_PROPERTY, false) && !amTheSystemServerProcess();
    final boolean suppress = SystemProperties.getBoolean(DISABLE_PROPERTY, false);
    // Similar logic also appears in ActivityThread.java for system apps.
    if (!doFlashes && (IS_USER_BUILD || suppress)) {
        setCloseGuardEnabled(false);
        return false;
    }
    // check above.
    if (IS_ENG_BUILD) {
        doFlashes = true;
    }
    // Thread policy controls BlockGuard.
    int threadPolicyMask = StrictMode.DETECT_DISK_WRITE | StrictMode.DETECT_DISK_READ | StrictMode.DETECT_NETWORK;
    if (!IS_USER_BUILD) {
        threadPolicyMask |= StrictMode.PENALTY_DROPBOX;
    }
    if (doFlashes) {
        threadPolicyMask |= StrictMode.PENALTY_FLASH;
    }
    StrictMode.setThreadPolicyMask(threadPolicyMask);
    // and instance counting.
    if (IS_USER_BUILD) {
        setCloseGuardEnabled(false);
    } else {
        VmPolicy.Builder policyBuilder = new VmPolicy.Builder().detectAll();
        if (!IS_ENG_BUILD) {
            // Activity leak detection causes too much slowdown for userdebug because of the
            // GCs.
            policyBuilder = policyBuilder.disable(DETECT_VM_ACTIVITY_LEAKS);
        }
        policyBuilder = policyBuilder.penaltyDropBox();
        if (IS_ENG_BUILD) {
            policyBuilder.penaltyLog();
        }
        // system health investigations
        if (android.os.Process.myUid() < android.os.Process.FIRST_APPLICATION_UID) {
            policyBuilder.detectUntaggedSockets();
        }
        setVmPolicy(policyBuilder.build());
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getLastAudibleStreamVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get last audible volume before stream was muted.
 *
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getLastAudibleStreamVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.getLastAudibleStreamVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.freeTextLayoutCaches:COMMENT
<android.graphics.Canvas: void freeTextLayoutCaches()>
public      static      native      hidden      ->public      static      hidden      
Method Modifier: public      static      native      hidden      
Method Modifier: Yes         Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          Yes         
Comment:/**
 * Free up text layout caches
 *
 * @hide
 */

Body of Frist Method:

Body of Second Method:
{
    nFreeTextLayoutCaches();
}
------------------------
Find a silently evolved API code:android.content.ContentValues.getAsBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Gets a value and converts it to a Boolean.
 *
 * @param key the value to get
 * @return the Boolean value, or {@code null} if the value is missing or cannot be converted
 */

Body of Frist Method:
{
    Object value = mValues.get(key);
    try {
        return (Boolean) value;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            return Boolean.valueOf(value.toString());
        } else if (value instanceof Number) {
            return ((Number) value).intValue() != 0;
        } else {
            Log.e(TAG, "Cannot cast value for " + key + " to a Boolean: " + value, e);
            return null;
        }
    }
}
Body of Second Method:
{
    Object value = mValues.get(key);
    try {
        return (Boolean) value;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            // false.
            return Boolean.valueOf(value.toString()) || "1".equals(value);
        } else if (value instanceof Number) {
            return ((Number) value).intValue() != 0;
        } else {
            Log.e(TAG, "Cannot cast value for " + key + " to a Boolean: " + value, e);
            return null;
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.getOutline:COMMENT
Method Modifier: public      
Comment:/**
 * Populates <code>outline</code> with the first available layer outline,
 * excluding the mask layer.
 *
 * @param outline Outline in which to place the first available layer outline
 */

Body of Frist Method:
{
    final LayerState state = mLayerState;
    final ChildDrawable[] children = state.mChildren;
    final int N = state.mNum;
    for (int i = 0; i < N; i++) {
        if (children[i].mId != R.id.mask) {
            children[i].mDrawable.getOutline(outline);
            if (!outline.isEmpty())
                return;
        }
    }
}
Body of Second Method:
{
    final LayerState state = mLayerState;
    final ChildDrawable[] children = state.mChildren;
    final int N = state.mNumChildren;
    for (int i = 0; i < N; i++) {
        if (children[i].mId != R.id.mask) {
            children[i].mDrawable.getOutline(outline);
            if (!outline.isEmpty())
                return;
        }
    }
}
------------------------
Find a silently evolved API code:android.util.MemoryIntArray.isWritable:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return Gets whether this array is mutable.
 */

Body of Frist Method:
{
    enforceNotClosed();
    return isOwner() || mClientWritable;
}
Body of Second Method:
{
    enforceNotClosed();
    return mIsOwner;
}
------------------------
Find a silently evolved API code:android.graphics.Path.getFillType:COMMENT
Method Modifier: public      
Comment:/**
 * Return the path's fill type. This defines how "inside" is
 * computed. The default value is WINDING.
 *
 * @return the path's fill type
 */

Body of Frist Method:
{
    return sFillTypeArray[native_getFillType(mNativePath)];
}
Body of Second Method:
{
    return sFillTypeArray[nGetFillType(mNativePath)];
}
------------------------
Find a silently evolved API code:android.webkit.WebViewUpdateService.getValidWebViewPackages:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Fetch all packages that could potentially implement WebView and are currently valid.
 */

Body of Frist Method:
{
    try {
        return getUpdateService().getValidWebViewPackages();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return getUpdateService().getValidWebViewPackages();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setNetworkOperatorNumeric:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the numeric name (MCC+MNC) of current registered operator.
 * @param operator the numeric name (MCC+MNC) of current registered operator
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    setNetworkOperatorNumericForPhone(phoneId, numeric);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    setNetworkOperatorNumericForPhone(phoneId, numeric);
}
------------------------
Find a silently evolved API code:android.animation.AnimatorInflater.setupObjectAnimator:COMMENT
Method Modifier: private     static      
Comment:/**
 * Setup ObjectAnimator's property or values from pathData.
 *
 * @param anim The target Animator which will be updated.
 * @param arrayObjectAnimator TypedArray for the ObjectAnimator.
 * @param getFloats True if the value type is float.
 * @param pixelSize The relative pixel size, used to calculate the
 * maximum error for path animations.
 */

Body of Frist Method:
{
    ObjectAnimator oa = (ObjectAnimator) anim;
    String pathData = arrayObjectAnimator.getString(R.styleable.PropertyAnimator_pathData);
    // Here we are dealing with case 2:
    if (pathData != null) {
        String propertyXName = arrayObjectAnimator.getString(R.styleable.PropertyAnimator_propertyXName);
        String propertyYName = arrayObjectAnimator.getString(R.styleable.PropertyAnimator_propertyYName);
        if (propertyXName == null && propertyYName == null) {
            throw new InflateException(arrayObjectAnimator.getPositionDescription() + " propertyXName or propertyYName is needed for PathData");
        } else {
            Path path = PathParser.createPathFromPathData(pathData);
            // max half a pixel error
            float error = 0.5f * pixelSize;
            PathKeyframes keyframeSet = KeyframeSet.ofPath(path, error);
            Keyframes xKeyframes;
            Keyframes yKeyframes;
            if (getFloats) {
                xKeyframes = keyframeSet.createXFloatKeyframes();
                yKeyframes = keyframeSet.createYFloatKeyframes();
            } else {
                xKeyframes = keyframeSet.createXIntKeyframes();
                yKeyframes = keyframeSet.createYIntKeyframes();
            }
            PropertyValuesHolder x = null;
            PropertyValuesHolder y = null;
            if (propertyXName != null) {
                x = PropertyValuesHolder.ofKeyframes(propertyXName, xKeyframes);
            }
            if (propertyYName != null) {
                y = PropertyValuesHolder.ofKeyframes(propertyYName, yKeyframes);
            }
            if (x == null) {
                oa.setValues(y);
            } else if (y == null) {
                oa.setValues(x);
            } else {
                oa.setValues(x, y);
            }
        }
    } else {
        String propertyName = arrayObjectAnimator.getString(R.styleable.PropertyAnimator_propertyName);
        oa.setPropertyName(propertyName);
    }
}
Body of Second Method:
{
    ObjectAnimator oa = (ObjectAnimator) anim;
    String pathData = arrayObjectAnimator.getString(R.styleable.PropertyAnimator_pathData);
    // Here we are dealing with case 2:
    if (pathData != null) {
        String propertyXName = arrayObjectAnimator.getString(R.styleable.PropertyAnimator_propertyXName);
        String propertyYName = arrayObjectAnimator.getString(R.styleable.PropertyAnimator_propertyYName);
        if (valueType == VALUE_TYPE_PATH || valueType == VALUE_TYPE_UNDEFINED) {
            // When pathData is defined, we are in case #2 mentioned above. ValueType can only
            // be float type, or int type. Otherwise we fallback to default type.
            valueType = VALUE_TYPE_FLOAT;
        }
        if (propertyXName == null && propertyYName == null) {
            throw new InflateException(arrayObjectAnimator.getPositionDescription() + " propertyXName or propertyYName is needed for PathData");
        } else {
            Path path = PathParser.createPathFromPathData(pathData);
            // max half a pixel error
            float error = 0.5f * pixelSize;
            PathKeyframes keyframeSet = KeyframeSet.ofPath(path, error);
            Keyframes xKeyframes;
            Keyframes yKeyframes;
            if (valueType == VALUE_TYPE_FLOAT) {
                xKeyframes = keyframeSet.createXFloatKeyframes();
                yKeyframes = keyframeSet.createYFloatKeyframes();
            } else {
                xKeyframes = keyframeSet.createXIntKeyframes();
                yKeyframes = keyframeSet.createYIntKeyframes();
            }
            PropertyValuesHolder x = null;
            PropertyValuesHolder y = null;
            if (propertyXName != null) {
                x = PropertyValuesHolder.ofKeyframes(propertyXName, xKeyframes);
            }
            if (propertyYName != null) {
                y = PropertyValuesHolder.ofKeyframes(propertyYName, yKeyframes);
            }
            if (x == null) {
                oa.setValues(y);
            } else if (y == null) {
                oa.setValues(x);
            } else {
                oa.setValues(x, y);
            }
        }
    } else {
        String propertyName = arrayObjectAnimator.getString(R.styleable.PropertyAnimator_propertyName);
        oa.setPropertyName(propertyName);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.shouldVibrate:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns whether a particular type should vibrate according to user
 * settings and the current ringer mode.
 * <p>
 * This shouldn't be needed by most clients that use notifications to
 * vibrate. The notification manager will not vibrate if the policy doesn't
 * allow it, so the client should always set a vibrate pattern and let the
 * notification manager control whether or not to actually vibrate.
 *
 * @param vibrateType The type of vibrate. One of
 * {@link #VIBRATE_TYPE_NOTIFICATION} or
 * {@link #VIBRATE_TYPE_RINGER}.
 * @return Whether the type should vibrate at the instant this method is
 * called.
 * @see #setVibrateSetting(int, int)
 * @see #getVibrateSetting(int)
 * @deprecated Applications should maintain their own vibrate policy based on
 * current ringer mode that can be queried via {@link #getRingerMode()}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.shouldVibrate(vibrateType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.shouldVibrate(vibrateType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.StrictMode.dropboxViolationAsync:COMMENT
Method Modifier: private     static      
Comment:/**
 * In the common case, as set by conditionallyEnableDebugLogging,
 * we're just dropboxing any violations but not showing a dialog,
 * not loggging, and not killing the process.  In these cases we
 * don't need to do a synchronous call to the ActivityManager.
 * This is used by both per-thread and vm-wide violations when
 * applicable.
 */

Body of Frist Method:
{
    int outstanding = sDropboxCallsInFlight.incrementAndGet();
    if (outstanding > 20) {
        // What's going on?  Let's not make make the situation
        // worse and just not log.
        sDropboxCallsInFlight.decrementAndGet();
        return;
    }
    if (LOG_V)
        Log.d(TAG, "Dropboxing async; in-flight=" + outstanding);
    new Thread("callActivityManagerForStrictModeDropbox") {

        public void run() {
            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            try {
                IActivityManager am = ActivityManagerNative.getDefault();
                if (am == null) {
                    Log.d(TAG, "No activity manager; failed to Dropbox violation.");
                } else {
                    am.handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
                }
            } catch (RemoteException e) {
                if (e instanceof DeadObjectException) {
                // System process is dead; ignore
                } else {
                    Log.e(TAG, "RemoteException handling StrictMode violation", e);
                }
            }
            int outstanding = sDropboxCallsInFlight.decrementAndGet();
            if (LOG_V)
                Log.d(TAG, "Dropbox complete; in-flight=" + outstanding);
        }
    }.start();
}
Body of Second Method:
{
    int outstanding = sDropboxCallsInFlight.incrementAndGet();
    if (outstanding > 20) {
        // What's going on?  Let's not make make the situation
        // worse and just not log.
        sDropboxCallsInFlight.decrementAndGet();
        return;
    }
    if (LOG_V)
        Log.d(TAG, "Dropboxing async; in-flight=" + outstanding);
    new Thread("callActivityManagerForStrictModeDropbox") {

        public void run() {
            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            try {
                IActivityManager am = ActivityManager.getService();
                if (am == null) {
                    Log.d(TAG, "No activity manager; failed to Dropbox violation.");
                } else {
                    am.handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
                }
            } catch (RemoteException e) {
                if (e instanceof DeadObjectException) {
                // System process is dead; ignore
                } else {
                    Log.e(TAG, "RemoteException handling StrictMode violation", e);
                }
            }
            int outstanding = sDropboxCallsInFlight.decrementAndGet();
            if (LOG_V)
                Log.d(TAG, "Dropbox complete; in-flight=" + outstanding);
        }
    }.start();
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraCharacteristics.getAvailableKeyList:COMMENT
Method Modifier: private     
Comment:/**
 * Returns the list of keys supported by this {@link CameraDevice} by metadataClass.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * @param metadataClass The subclass of CameraMetadata that you want to get the keys for.
 * @param keyClass The class of the metadata key, e.g. CaptureRequest.Key.class
 *
 * @return List of keys supported by this CameraDevice for metadataClass.
 *
 * @throws IllegalArgumentException if metadataClass is not a subclass of CameraMetadata
 */

Body of Frist Method:
{
    if (metadataClass.equals(CameraMetadata.class)) {
        throw new AssertionError("metadataClass must be a strict subclass of CameraMetadata");
    } else if (!CameraMetadata.class.isAssignableFrom(metadataClass)) {
        throw new AssertionError("metadataClass must be a subclass of CameraMetadata");
    }
    List<TKey> staticKeyList = CameraCharacteristics.<TKey>getKeysStatic(metadataClass, keyClass, /*instance*/
    null, filterTags);
    return Collections.unmodifiableList(staticKeyList);
}
Body of Second Method:
{
    if (metadataClass.equals(CameraMetadata.class)) {
        throw new AssertionError("metadataClass must be a strict subclass of CameraMetadata");
    } else if (!CameraMetadata.class.isAssignableFrom(metadataClass)) {
        throw new AssertionError("metadataClass must be a subclass of CameraMetadata");
    }
    List<TKey> staticKeyList = getKeys(metadataClass, keyClass, /*instance*/
    null, filterTags);
    return Collections.unmodifiableList(staticKeyList);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.reloadAudioSettings:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Reload audio settings. This method is called by Settings backup
 * agent when audio settings are restored and causes the AudioService
 * to read and apply restored settings.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.reloadAudioSettings();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.reloadAudioSettings();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getCaCertificateAliases:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get CA certificate aliases
 * @return alias to the CA certificate
 * @hide
 */

Body of Frist Method:
{
    String value = getFieldValue(CA_CERT_KEY, "");
    if (value.startsWith(CA_CERT_PREFIX)) {
        // Backwards compatibility: parse the original alias prefix.
        return new String[] { getFieldValue(CA_CERT_KEY, CA_CERT_PREFIX) };
    } else if (value.startsWith(KEYSTORES_URI)) {
        String values = value.substring(KEYSTORES_URI.length());
        String[] aliases = TextUtils.split(values, CA_CERT_ALIAS_DELIMITER);
        for (int i = 0; i < aliases.length; i++) {
            aliases[i] = decodeCaCertificateAlias(aliases[i]);
            if (aliases[i].startsWith(Credentials.CA_CERTIFICATE)) {
                aliases[i] = aliases[i].substring(Credentials.CA_CERTIFICATE.length());
            }
        }
        return aliases.length != 0 ? aliases : null;
    } else {
        return TextUtils.isEmpty(value) ? null : new String[] { value };
    }
}
Body of Second Method:
{
    String value = getFieldValue(CA_CERT_KEY);
    if (value.startsWith(CA_CERT_PREFIX)) {
        // Backwards compatibility: parse the original alias prefix.
        return new String[] { getFieldValue(CA_CERT_KEY, CA_CERT_PREFIX) };
    } else if (value.startsWith(KEYSTORES_URI)) {
        String values = value.substring(KEYSTORES_URI.length());
        String[] aliases = TextUtils.split(values, CA_CERT_ALIAS_DELIMITER);
        for (int i = 0; i < aliases.length; i++) {
            aliases[i] = decodeCaCertificateAlias(aliases[i]);
            if (aliases[i].startsWith(Credentials.CA_CERTIFICATE)) {
                aliases[i] = aliases[i].substring(Credentials.CA_CERTIFICATE.length());
            }
        }
        return aliases.length != 0 ? aliases : null;
    } else {
        return TextUtils.isEmpty(value) ? null : new String[] { value };
    }
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.usageToString:COMMENT
<android.media.AudioAttributes: String usageToString()>
public      hidden      ->public      static      hidden      
Method Modifier: public      static      hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return usageToString(mUsage);
}
Body of Second Method:
{
    switch(usage) {
        case USAGE_UNKNOWN:
            return new String("USAGE_UNKNOWN");
        case USAGE_MEDIA:
            return new String("USAGE_MEDIA");
        case USAGE_VOICE_COMMUNICATION:
            return new String("USAGE_VOICE_COMMUNICATION");
        case USAGE_VOICE_COMMUNICATION_SIGNALLING:
            return new String("USAGE_VOICE_COMMUNICATION_SIGNALLING");
        case USAGE_ALARM:
            return new String("USAGE_ALARM");
        case USAGE_NOTIFICATION:
            return new String("USAGE_NOTIFICATION");
        case USAGE_NOTIFICATION_RINGTONE:
            return new String("USAGE_NOTIFICATION_RINGTONE");
        case USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_REQUEST");
        case USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_INSTANT");
        case USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_DELAYED");
        case USAGE_NOTIFICATION_EVENT:
            return new String("USAGE_NOTIFICATION_EVENT");
        case USAGE_ASSISTANCE_ACCESSIBILITY:
            return new String("USAGE_ASSISTANCE_ACCESSIBILITY");
        case USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
            return new String("USAGE_ASSISTANCE_NAVIGATION_GUIDANCE");
        case USAGE_ASSISTANCE_SONIFICATION:
            return new String("USAGE_ASSISTANCE_SONIFICATION");
        case USAGE_GAME:
            return new String("USAGE_GAME");
        case USAGE_ASSISTANT:
            return new String("USAGE_ASSISTANT");
        default:
            return new String("unknown usage " + usage);
    }
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfRenderer.shouldScaleForPrinting:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether the document prefers to be scaled for printing.
 * You should take this info account if the document is rendered
 * for printing and the target media size differs from the page
 * size.
 *
 * @return If to scale the document.
 */

Body of Frist Method:
{
    throwIfClosed();
    return nativeScaleForPrinting(mNativeDocument);
}
Body of Second Method:
{
    throwIfClosed();
    synchronized (sPdfiumLock) {
        return nativeScaleForPrinting(mNativeDocument);
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.getId:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the ID of the specified layer.
 *
 * @param index The index of the layer, must be in the range
 * {@code 0...getNumberOfLayers()-1}.
 * @return The id of the layer or {@link android.view.View#NO_ID} if the
 * layer has no id.
 *
 * @see #setId(int, int)
 * @attr ref android.R.styleable#LayerDrawableItem_id
 */

Body of Frist Method:
{
    if (index >= mLayerState.mNum) {
        throw new IndexOutOfBoundsException();
    }
    return mLayerState.mChildren[index].mId;
}
Body of Second Method:
{
    if (index >= mLayerState.mNumChildren) {
        throw new IndexOutOfBoundsException();
    }
    return mLayerState.mChildren[index].mId;
}
------------------------
Find a silently evolved API code:android.graphics.SweepGradient.copy:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final SweepGradient copy;
    switch(mType) {
        case TYPE_COLORS_AND_POSITIONS:
            copy = new SweepGradient(mCx, mCy, mColors.clone(), mPositions != null ? mPositions.clone() : null);
            break;
        case TYPE_COLOR_START_AND_COLOR_END:
            copy = new SweepGradient(mCx, mCy, mColor0, mColor1);
            break;
        default:
            throw new IllegalArgumentException("SweepGradient should be created with either " + "colors and positions or start color and end color");
    }
    copyLocalMatrix(copy);
    return copy;
}
Body of Second Method:
{
    final SweepGradient copy;
    if (mType == TYPE_COLORS_AND_POSITIONS) {
        copy = new SweepGradient(mCx, mCy, mColors.clone(), mPositions != null ? mPositions.clone() : null);
    } else {
        // TYPE_COLOR_START_AND_COLOR_END
        copy = new SweepGradient(mCx, mCy, mColor0, mColor1);
    }
    copyLocalMatrix(copy);
    return copy;
}
------------------------
Find a silently evolved API code:android.provider.ContactsContract.Contacts.markAsContacted:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Mark a contact as having been contacted. Updates two fields:
 * {@link #TIMES_CONTACTED} and {@link #LAST_TIME_CONTACTED}. The
 * TIMES_CONTACTED field is incremented by 1 and the LAST_TIME_CONTACTED
 * field is populated with the current system time.
 *
 * @param resolver the ContentResolver to use
 * @param contactId the person who was contacted
 *
 * @deprecated The class DataUsageStatUpdater of the Android support library should
 * be used instead.
 */

Body of Frist Method:
{
    Uri uri = ContentUris.withAppendedId(CONTENT_URI, contactId);
    ContentValues values = new ContentValues();
    // TIMES_CONTACTED will be incremented when LAST_TIME_CONTACTED is modified.
    values.put(LAST_TIME_CONTACTED, System.currentTimeMillis());
    resolver.update(uri, values, null, null);
}
Body of Second Method:
{
    Uri uri = ContentUris.withAppendedId(CONTENT_URI, contactId);
    ContentValues values = new ContentValues();
    // TIMES_CONTACTED will be incremented when LAST_TIME_CONTACTED is modified.
    values.put(LR_LAST_TIME_CONTACTED, System.currentTimeMillis());
    resolver.update(uri, values, null, null);
}
------------------------
Find a silently evolved API code:android.hardware.location.ContextHubManager.getContextHubInfo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get more information about a specific hub.
 *
 * @param hubHandle Handle (system-wide unique identifier) of a context hub.
 * @return ContextHubInfo Information about the requested context hub.
 *
 * @see ContextHubInfo
 */

Body of Frist Method:
{
    ContextHubInfo retVal = null;
    try {
        retVal = getBinder().getContextHubInfo(hubHandle);
    } catch (RemoteException e) {
        Log.w(TAG, "Could not fetch context hub info :" + e);
    }
    return retVal;
}
Body of Second Method:
{
    try {
        return mService.getContextHubInfo(hubHandle);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.util.TypedValue.complexToDimensionPixelSize:COMMENT
Method Modifier: public      static      
Comment:/**
 * Converts a complex data value holding a dimension to its final value
 * as an integer pixel size.  This is the same as
 * {@link #complexToDimension}, except the raw floating point value is
 * converted to an integer (pixel) value for use as a size.  A size
 * conversion involves rounding the base value, and ensuring that a
 * non-zero base value is at least one pixel in size.
 * The given <var>data</var> must be structured as a
 * {@link #TYPE_DIMENSION}.
 *
 * @param data A complex data value holding a unit, magnitude, and
 * mantissa.
 * @param metrics Current display metrics to use in the conversion --
 * supplies display density and scaling information.
 *
 * @return The number of pixels specified by the data and its desired
 * multiplier and units.
 */

Body of Frist Method:
{
    final float value = complexToFloat(data);
    final float f = applyDimension((data >> COMPLEX_UNIT_SHIFT) & COMPLEX_UNIT_MASK, value, metrics);
    final int res = (int) (f + 0.5f);
    if (res != 0)
        return res;
    if (value == 0)
        return 0;
    if (value > 0)
        return 1;
    return -1;
}
Body of Second Method:
{
    final float value = complexToFloat(data);
    final float f = applyDimension((data >> COMPLEX_UNIT_SHIFT) & COMPLEX_UNIT_MASK, value, metrics);
    final int res = (int) ((f >= 0) ? (f + 0.5f) : (f - 0.5f));
    if (res != 0)
        return res;
    if (value == 0)
        return 0;
    if (value > 0)
        return 1;
    return -1;
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfEditor.getPageSize:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the size of a given page in mils (1/72").
 *
 * @param pageIndex The page index.
 * @param outSize The size output.
 */

Body of Frist Method:
{
    throwIfClosed();
    throwIfOutSizeNull(outSize);
    throwIfPageNotInDocument(pageIndex);
    nativeGetPageSize(mNativeDocument, pageIndex, outSize);
}
Body of Second Method:
{
    throwIfClosed();
    throwIfOutSizeNull(outSize);
    throwIfPageNotInDocument(pageIndex);
    synchronized (PdfRenderer.sPdfiumLock) {
        nativeGetPageSize(mNativeDocument, pageIndex, outSize);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ApplicationInfo.getSplitResourcePaths:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    return splitSourceDirs;
}
Body of Second Method:
{
    return splitPublicSourceDirs;
}
------------------------
Find a silently evolved API code:android.widget.CalendarViewLegacyDelegate.WeekView.drawSelectedDateVerticalBars:COMMENT
Method Modifier: private     
Comment:/**
 * Draws the selected date bars if this week has a selected day.
 *
 * @param canvas The canvas to draw on
 */

Body of Frist Method:
{
    if (!mHasSelectedDay) {
        return;
    }
    mSelectedDateVerticalBar.setBounds(mSelectedLeft - mSelectedDateVerticalBarWidth / 2, mWeekSeperatorLineWidth, mSelectedLeft + mSelectedDateVerticalBarWidth / 2, mHeight);
    mSelectedDateVerticalBar.draw(canvas);
    mSelectedDateVerticalBar.setBounds(mSelectedRight - mSelectedDateVerticalBarWidth / 2, mWeekSeperatorLineWidth, mSelectedRight + mSelectedDateVerticalBarWidth / 2, mHeight);
    mSelectedDateVerticalBar.draw(canvas);
}
Body of Second Method:
{
    if (!mHasSelectedDay) {
        return;
    }
    mSelectedDateVerticalBar.setBounds(mSelectedLeft - mSelectedDateVerticalBarWidth / 2, mWeekSeparatorLineWidth, mSelectedLeft + mSelectedDateVerticalBarWidth / 2, mHeight);
    mSelectedDateVerticalBar.draw(canvas);
    mSelectedDateVerticalBar.setBounds(mSelectedRight - mSelectedDateVerticalBarWidth / 2, mWeekSeparatorLineWidth, mSelectedRight + mSelectedDateVerticalBarWidth / 2, mHeight);
    mSelectedDateVerticalBar.draw(canvas);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.unregisterAudioPolicyAsync:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * @param policy the non-null {@link AudioPolicy} to unregister.
 */

Body of Frist Method:
{
    if (policy == null) {
        throw new IllegalArgumentException("Illegal null AudioPolicy argument");
    }
    IAudioService service = getService();
    try {
        service.unregisterAudioPolicyAsync(policy.cb());
        policy.setRegistration(null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (policy == null) {
        throw new IllegalArgumentException("Illegal null AudioPolicy argument");
    }
    final IAudioService service = getService();
    try {
        service.unregisterAudioPolicyAsync(policy.cb());
        policy.setRegistration(null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.pm.UserInfo.supportsSwitchTo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return true if this user can be switched to.
 */

Body of Frist Method:
{
    if (isEphemeral() && !isEnabled()) {
        // Don't support switching to an ephemeral user with removal in progress.
        return false;
    }
    // TODO remove fw.show_hidden_users when we have finished developing managed profiles.
    return !isManagedProfile() || SystemProperties.getBoolean("fw.show_hidden_users", false);
}
Body of Second Method:
{
    if (isEphemeral() && !isEnabled()) {
        // Don't support switching to an ephemeral user with removal in progress.
        return false;
    }
    return !isManagedProfile();
}
------------------------
Find a silently evolved API code:android.view.DragAndDropPermissions.release:COMMENT
Method Modifier: public      
Comment:/**
 * Revoke permissions explicitly.
 */

Body of Frist Method:
{
    try {
        mDragAndDropPermissions.release();
        mPermissionOwnerToken = null;
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mDragAndDropPermissions.release();
        mTransientToken = null;
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path.rCubicTo:COMMENT
Method Modifier: public      
Comment:/**
 * Same as cubicTo, but the coordinates are considered relative to the
 * current point on this contour. If there is no previous point, then a
 * moveTo(0,0) is inserted automatically.
 */

Body of Frist Method:
{
    isSimplePath = false;
    native_rCubicTo(mNativePath, x1, y1, x2, y2, x3, y3);
}
Body of Second Method:
{
    isSimplePath = false;
    nRCubicTo(mNativePath, x1, y1, x2, y2, x3, y3);
}
------------------------
Find a silently evolved API code:android.util.MemoryIntArray.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the value at a given index. This method can be called only if
 * {@link #isWritable()} returns true which means your process is the
 * owner.
 *
 * @param index The index.
 * @param value The value to set.
 * @throws IOException If an error occurs while accessing the shared memory.
 */

Body of Frist Method:
{
    enforceNotClosed();
    enforceWritable();
    enforceValidIndex(index);
    nativeSet(mFd, mMemoryAddr, index, value, isOwner());
}
Body of Second Method:
{
    enforceNotClosed();
    enforceWritable();
    enforceValidIndex(index);
    nativeSet(mFd, mMemoryAddr, index, value);
}
------------------------
Find a silently evolved API code:android.preference.PreferenceActivity.onHeaderClick:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the user selects an item in the header list.  The default
 * implementation will call either
 * {@link #startWithFragment(String, Bundle, Fragment, int, int, int)}
 * or {@link #switchToHeader(Header)} as appropriate.
 *
 * @param header The header that was selected.
 * @param position The header's position in the list.
 */

Body of Frist Method:
{
    if (header.fragment != null) {
        if (mSinglePane) {
            int titleRes = header.breadCrumbTitleRes;
            int shortTitleRes = header.breadCrumbShortTitleRes;
            if (titleRes == 0) {
                titleRes = header.titleRes;
                shortTitleRes = 0;
            }
            startWithFragment(header.fragment, header.fragmentArguments, null, 0, titleRes, shortTitleRes);
        } else {
            switchToHeader(header);
        }
    } else if (header.intent != null) {
        startActivity(header.intent);
    }
}
Body of Second Method:
{
    if (header.fragment != null) {
        switchToHeader(header);
    } else if (header.intent != null) {
        startActivity(header.intent);
    }
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbRequest.initialize:COMMENT
Method Modifier: public      
Comment:/**
 * Initializes the request so it can read or write data on the given endpoint.
 * Whether the request allows reading or writing depends on the direction of the endpoint.
 *
 * @param endpoint the endpoint to be used for this request.
 * @return true if the request was successfully opened.
 */

Body of Frist Method:
{
    mEndpoint = endpoint;
    return native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
}
Body of Second Method:
{
    mEndpoint = endpoint;
    mConnection = Preconditions.checkNotNull(connection, "connection");
    boolean wasInitialized = native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
    if (wasInitialized) {
        mCloseGuard.open("close");
    }
    return wasInitialized;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isBluetoothScoOn:COMMENT
Method Modifier: public      
Comment:/**
 * Checks whether communications use Bluetooth SCO.
 *
 * @return true if SCO is used for communications;
 * false if otherwise
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.isBluetoothScoOn();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.isBluetoothScoOn();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.getWidth:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the width of the current drawing layer
 *
 * @return the width of the current drawing layer
 */

Body of Frist Method:
{
    return native_getWidth(mNativeCanvasWrapper);
}
Body of Second Method:
{
    return nGetWidth(mNativeCanvasWrapper);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.enableNoAutoConnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Enable the Bluetooth Adapter, but don't auto-connect devices
 * and don't persist state. Only for use by system applications.
 * @hide
 */

Body of Frist Method:
{
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, "enableNoAutoConnect(): BT is already enabled..!");
        return true;
    }
    try {
        return mManagerService.enableNoAutoConnect();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, "enableNoAutoConnect(): BT already enabled!");
        return true;
    }
    try {
        return mManagerService.enableNoAutoConnect(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.preference.PreferenceGroup.addPreference:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a {@link Preference} at the correct position based on the
 * preference's order.
 *
 * @param preference The preference to add.
 * @return Whether the preference is now in this group.
 */

Body of Frist Method:
{
    if (mPreferenceList.contains(preference)) {
        // Exists
        return true;
    }
    if (preference.getOrder() == Preference.DEFAULT_ORDER) {
        if (mOrderingAsAdded) {
            preference.setOrder(mCurrentPreferenceOrder++);
        }
        if (preference instanceof PreferenceGroup) {
            // TODO: fix (method is called tail recursively when inflating,
            // so we won't end up properly passing this flag down to children
            ((PreferenceGroup) preference).setOrderingAsAdded(mOrderingAsAdded);
        }
    }
    if (!onPrepareAddPreference(preference)) {
        return false;
    }
    synchronized (this) {
        int insertionIndex = Collections.binarySearch(mPreferenceList, preference);
        if (insertionIndex < 0) {
            insertionIndex = insertionIndex * -1 - 1;
        }
        mPreferenceList.add(insertionIndex, preference);
    }
    preference.onAttachedToHierarchy(getPreferenceManager());
    if (mAttachedToActivity) {
        preference.onAttachedToActivity();
    }
    notifyHierarchyChanged();
    return true;
}
Body of Second Method:
{
    if (mPreferenceList.contains(preference)) {
        // Exists
        return true;
    }
    if (preference.getOrder() == Preference.DEFAULT_ORDER) {
        if (mOrderingAsAdded) {
            preference.setOrder(mCurrentPreferenceOrder++);
        }
        if (preference instanceof PreferenceGroup) {
            // TODO: fix (method is called tail recursively when inflating,
            // so we won't end up properly passing this flag down to children
            ((PreferenceGroup) preference).setOrderingAsAdded(mOrderingAsAdded);
        }
    }
    if (!onPrepareAddPreference(preference)) {
        return false;
    }
    synchronized (this) {
        int insertionIndex = Collections.binarySearch(mPreferenceList, preference);
        if (insertionIndex < 0) {
            insertionIndex = insertionIndex * -1 - 1;
        }
        mPreferenceList.add(insertionIndex, preference);
    }
    preference.onAttachedToHierarchy(getPreferenceManager());
    preference.assignParent(this);
    if (mAttachedToActivity) {
        preference.onAttachedToActivity();
    }
    notifyHierarchyChanged();
    return true;
}
------------------------
Find a silently evolved API code:android.os.Bundle.filterValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Filter values in Bundle to only basic types.
 * @hide
 */

Body of Frist Method:
{
    unparcel();
    if (mMap != null) {
        for (int i = mMap.size() - 1; i >= 0; i--) {
            Object value = mMap.valueAt(i);
            if (PersistableBundle.isValidType(value)) {
                continue;
            }
            if (value instanceof Bundle) {
                ((Bundle) value).filterValues();
            }
            if (value.getClass().getName().startsWith("android.")) {
                continue;
            }
            mMap.removeAt(i);
        }
    }
    mFlags |= FLAG_HAS_FDS_KNOWN;
    mFlags &= ~FLAG_HAS_FDS;
}
Body of Second Method:
{
    unparcel();
    Bundle bundle = this;
    if (mMap != null) {
        ArrayMap<String, Object> map = mMap;
        for (int i = map.size() - 1; i >= 0; i--) {
            Object value = map.valueAt(i);
            if (PersistableBundle.isValidType(value)) {
                continue;
            }
            if (value instanceof Bundle) {
                Bundle newBundle = ((Bundle) value).filterValues();
                if (newBundle != value) {
                    if (map == mMap) {
                        // The filter had to generate a new bundle, but we have not yet
                        // created a new one here.  Do that now.
                        bundle = new Bundle(this);
                        // Note the ArrayMap<> constructor is guaranteed to generate
                        // a new object with items in the same order as the original.
                        map = bundle.mMap;
                    }
                    // Replace this current entry with the new child bundle.
                    map.setValueAt(i, newBundle);
                }
                continue;
            }
            if (value.getClass().getName().startsWith("android.")) {
                continue;
            }
            if (map == mMap) {
                // This is the first time we have had to remove something, that means we
                // need to switch to a new Bundle.
                bundle = new Bundle(this);
                // Note the ArrayMap<> constructor is guaranteed to generate
                // a new object with items in the same order as the original.
                map = bundle.mMap;
            }
            map.removeAt(i);
        }
    }
    mFlags |= FLAG_HAS_FDS_KNOWN;
    mFlags &= ~FLAG_HAS_FDS;
    return bundle;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.PnoSettings.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(isConnected ? 1 : 0);
    dest.writeInt(min5GHzRssi);
    dest.writeInt(min24GHzRssi);
    dest.writeInt(initialScoreMax);
    dest.writeInt(currentConnectionBonus);
    dest.writeInt(sameNetworkBonus);
    dest.writeInt(secureBonus);
    dest.writeInt(band5GHzBonus);
    if (networkList != null) {
        dest.writeInt(networkList.length);
        for (int i = 0; i < networkList.length; i++) {
            dest.writeString(networkList[i].ssid);
            dest.writeInt(networkList[i].networkId);
            dest.writeInt(networkList[i].priority);
            dest.writeByte(networkList[i].flags);
            dest.writeByte(networkList[i].authBitField);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    dest.writeInt(isConnected ? 1 : 0);
    dest.writeInt(min5GHzRssi);
    dest.writeInt(min24GHzRssi);
    dest.writeInt(initialScoreMax);
    dest.writeInt(currentConnectionBonus);
    dest.writeInt(sameNetworkBonus);
    dest.writeInt(secureBonus);
    dest.writeInt(band5GHzBonus);
    if (networkList != null) {
        dest.writeInt(networkList.length);
        for (int i = 0; i < networkList.length; i++) {
            dest.writeString(networkList[i].ssid);
            dest.writeByte(networkList[i].flags);
            dest.writeByte(networkList[i].authBitField);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.replace:COMMENT
Method Modifier: public      
Comment:// Documentation from interface

Body of Frist Method:
{
    checkRange("replace", start, end);
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    final int origLen = end - start;
    final int newLen = tbend - tbstart;
    if (origLen == 0 && newLen == 0 && !hasNonExclusiveExclusiveSpanAt(tb, tbstart)) {
        // Early exit so that the text watchers do not get notified
        return this;
    }
    TextWatcher[] textWatchers = getSpans(start, start + origLen, TextWatcher.class);
    sendBeforeTextChanged(textWatchers, start, origLen, newLen);
    // Try to keep the cursor / selection at the same relative position during
    // a text replacement. If replaced or replacement text length is zero, this
    // is already taken care of.
    boolean adjustSelection = origLen != 0 && newLen != 0;
    int selectionStart = 0;
    int selectionEnd = 0;
    if (adjustSelection) {
        selectionStart = Selection.getSelectionStart(this);
        selectionEnd = Selection.getSelectionEnd(this);
    }
    change(start, end, tb, tbstart, tbend);
    if (adjustSelection) {
        boolean changed = false;
        if (selectionStart > start && selectionStart < end) {
            final long diff = selectionStart - start;
            final int offset = Math.toIntExact(diff * newLen / origLen);
            selectionStart = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_START, selectionStart, selectionStart, Spanned.SPAN_POINT_POINT);
        }
        if (selectionEnd > start && selectionEnd < end) {
            final long diff = selectionEnd - start;
            final int offset = Math.toIntExact(diff * newLen / origLen);
            selectionEnd = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_END, selectionEnd, selectionEnd, Spanned.SPAN_POINT_POINT);
        }
        if (changed) {
            restoreInvariants();
        }
    }
    sendTextChanged(textWatchers, start, origLen, newLen);
    sendAfterTextChanged(textWatchers);
    // Span watchers need to be called after text watchers, which may update the layout
    sendToSpanWatchers(start, end, newLen - origLen);
    return this;
}
Body of Second Method:
{
    checkRange("replace", start, end);
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    final int origLen = end - start;
    final int newLen = tbend - tbstart;
    if (origLen == 0 && newLen == 0 && !hasNonExclusiveExclusiveSpanAt(tb, tbstart)) {
        // Early exit so that the text watchers do not get notified
        return this;
    }
    TextWatcher[] textWatchers = getSpans(start, start + origLen, TextWatcher.class);
    sendBeforeTextChanged(textWatchers, start, origLen, newLen);
    // Try to keep the cursor / selection at the same relative position during
    // a text replacement. If replaced or replacement text length is zero, this
    // is already taken care of.
    boolean adjustSelection = origLen != 0 && newLen != 0;
    int selectionStart = 0;
    int selectionEnd = 0;
    if (adjustSelection) {
        selectionStart = Selection.getSelectionStart(this);
        selectionEnd = Selection.getSelectionEnd(this);
    }
    change(start, end, tb, tbstart, tbend);
    if (adjustSelection) {
        boolean changed = false;
        if (selectionStart > start && selectionStart < end) {
            final long diff = selectionStart - start;
            final int offset = Math.toIntExact(diff * newLen / origLen);
            selectionStart = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_START, selectionStart, selectionStart, Spanned.SPAN_POINT_POINT, true);
        }
        if (selectionEnd > start && selectionEnd < end) {
            final long diff = selectionEnd - start;
            final int offset = Math.toIntExact(diff * newLen / origLen);
            selectionEnd = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_END, selectionEnd, selectionEnd, Spanned.SPAN_POINT_POINT, true);
        }
        if (changed) {
            restoreInvariants();
        }
    }
    sendTextChanged(textWatchers, start, origLen, newLen);
    sendAfterTextChanged(textWatchers);
    // Span watchers need to be called after text watchers, which may update the layout
    sendToSpanWatchers(start, end, newLen - origLen);
    return this;
}
------------------------
Find a silently evolved API code:android.text.Layout.measurePara:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR, null);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        // leading margins should be taken into account when measuring a paragraph
        int margin = 0;
        if (text instanceof Spanned) {
            Spanned spanned = (Spanned) text;
            LeadingMarginSpan[] spans = getParagraphSpans(spanned, start, end, LeadingMarginSpan.class);
            for (LeadingMarginSpan lms : spans) {
                margin += lms.getLeadingMargin(true);
            }
        }
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return margin + tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}
Body of Second Method:
{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, textDir, null);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        // leading margins should be taken into account when measuring a paragraph
        int margin = 0;
        if (text instanceof Spanned) {
            Spanned spanned = (Spanned) text;
            LeadingMarginSpan[] spans = getParagraphSpans(spanned, start, end, LeadingMarginSpan.class);
            for (LeadingMarginSpan lms : spans) {
                margin += lms.getLeadingMargin(true);
            }
        }
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return margin + Math.abs(tl.metrics(null));
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getSubId:COMMENT
Method Modifier: private     
Comment:/**
 * Return an appropriate subscription ID for any situation.
 *
 * If this object has been created with {@link #createForSubscriptionId}, then the provided
 * subId is returned. Otherwise, the default subId will be returned.
 */

Body of Frist Method:
{
    if (mSubId == SubscriptionManager.DEFAULT_SUBSCRIPTION_ID) {
        return getDefaultSubscription();
    }
    return mSubId;
}
Body of Second Method:
{
    if (SubscriptionManager.isUsableSubIdValue(mSubId)) {
        return mSubId;
    }
    return SubscriptionManager.getDefaultSubscriptionId();
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbRequest.close:COMMENT
Method Modifier: public      
Comment:/**
 * Releases all resources related to this request.
 */

Body of Frist Method:
{
    mEndpoint = null;
    native_close();
}
Body of Second Method:
{
    if (mNativeContext != 0) {
        mEndpoint = null;
        mConnection = null;
        native_close();
        mCloseGuard.close();
    }
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfEditor.setTransformAndClip:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets a transformation and clip for a given page. The transformation matrix if
 * non-null must be affine as per {@link android.graphics.Matrix#isAffine()}. If
 * the clip is null, then no clipping is performed.
 *
 * @param pageIndex The page whose transform to set.
 * @param transform The transformation to apply.
 * @param clip The clip to apply.
 */

Body of Frist Method:
{
    throwIfClosed();
    throwIfPageNotInDocument(pageIndex);
    throwIfNotNullAndNotAfine(transform);
    if (transform == null) {
        transform = Matrix.IDENTITY_MATRIX;
    }
    if (clip == null) {
        Point size = new Point();
        getPageSize(pageIndex, size);
        nativeSetTransformAndClip(mNativeDocument, pageIndex, transform.native_instance, 0, 0, size.x, size.y);
    } else {
        nativeSetTransformAndClip(mNativeDocument, pageIndex, transform.native_instance, clip.left, clip.top, clip.right, clip.bottom);
    }
}
Body of Second Method:
{
    throwIfClosed();
    throwIfPageNotInDocument(pageIndex);
    throwIfNotNullAndNotAfine(transform);
    if (transform == null) {
        transform = Matrix.IDENTITY_MATRIX;
    }
    if (clip == null) {
        Point size = new Point();
        getPageSize(pageIndex, size);
        synchronized (PdfRenderer.sPdfiumLock) {
            nativeSetTransformAndClip(mNativeDocument, pageIndex, transform.native_instance, 0, 0, size.x, size.y);
        }
    } else {
        synchronized (PdfRenderer.sPdfiumLock) {
            nativeSetTransformAndClip(mNativeDocument, pageIndex, transform.native_instance, clip.left, clip.top, clip.right, clip.bottom);
        }
    }
}
------------------------
Find a silently evolved API code:android.media.MediaMetadata.getDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a simple description of this metadata for display purposes.
 *
 * @return A simple description of this metadata.
 */

Body of Frist Method:
{
    if (mDescription != null) {
        return mDescription;
    }
    String mediaId = getString(METADATA_KEY_MEDIA_ID);
    CharSequence[] text = new CharSequence[3];
    Bitmap icon = null;
    Uri iconUri = null;
    // First handle the case where display data is set already
    CharSequence displayText = getText(METADATA_KEY_DISPLAY_TITLE);
    if (!TextUtils.isEmpty(displayText)) {
        // If they have a display title use only display data, otherwise use
        // our best bets
        text[0] = displayText;
        text[1] = getText(METADATA_KEY_DISPLAY_SUBTITLE);
        text[2] = getText(METADATA_KEY_DISPLAY_DESCRIPTION);
    } else {
        // Use whatever fields we can
        int textIndex = 0;
        int keyIndex = 0;
        while (textIndex < text.length && keyIndex < PREFERRED_DESCRIPTION_ORDER.length) {
            CharSequence next = getText(PREFERRED_DESCRIPTION_ORDER[keyIndex++]);
            if (!TextUtils.isEmpty(next)) {
                // Fill in the next empty bit of text
                text[textIndex++] = next;
            }
        }
    }
    // Get the best art bitmap we can find
    for (int i = 0; i < PREFERRED_BITMAP_ORDER.length; i++) {
        Bitmap next = getBitmap(PREFERRED_BITMAP_ORDER[i]);
        if (next != null) {
            icon = next;
            break;
        }
    }
    // Get the best Uri we can find
    for (int i = 0; i < PREFERRED_URI_ORDER.length; i++) {
        String next = getString(PREFERRED_URI_ORDER[i]);
        if (!TextUtils.isEmpty(next)) {
            iconUri = Uri.parse(next);
            break;
        }
    }
    MediaDescription.Builder bob = new MediaDescription.Builder();
    bob.setMediaId(mediaId);
    bob.setTitle(text[0]);
    bob.setSubtitle(text[1]);
    bob.setDescription(text[2]);
    bob.setIconBitmap(icon);
    bob.setIconUri(iconUri);
    mDescription = bob.build();
    return mDescription;
}
Body of Second Method:
{
    if (mDescription != null) {
        return mDescription;
    }
    String mediaId = getString(METADATA_KEY_MEDIA_ID);
    CharSequence[] text = new CharSequence[3];
    Bitmap icon = null;
    Uri iconUri = null;
    // First handle the case where display data is set already
    CharSequence displayText = getText(METADATA_KEY_DISPLAY_TITLE);
    if (!TextUtils.isEmpty(displayText)) {
        // If they have a display title use only display data, otherwise use
        // our best bets
        text[0] = displayText;
        text[1] = getText(METADATA_KEY_DISPLAY_SUBTITLE);
        text[2] = getText(METADATA_KEY_DISPLAY_DESCRIPTION);
    } else {
        // Use whatever fields we can
        int textIndex = 0;
        int keyIndex = 0;
        while (textIndex < text.length && keyIndex < PREFERRED_DESCRIPTION_ORDER.length) {
            CharSequence next = getText(PREFERRED_DESCRIPTION_ORDER[keyIndex++]);
            if (!TextUtils.isEmpty(next)) {
                // Fill in the next empty bit of text
                text[textIndex++] = next;
            }
        }
    }
    // Get the best art bitmap we can find
    for (int i = 0; i < PREFERRED_BITMAP_ORDER.length; i++) {
        Bitmap next = getBitmap(PREFERRED_BITMAP_ORDER[i]);
        if (next != null) {
            icon = next;
            break;
        }
    }
    // Get the best Uri we can find
    for (int i = 0; i < PREFERRED_URI_ORDER.length; i++) {
        String next = getString(PREFERRED_URI_ORDER[i]);
        if (!TextUtils.isEmpty(next)) {
            iconUri = Uri.parse(next);
            break;
        }
    }
    Uri mediaUri = null;
    String mediaUriStr = getString(METADATA_KEY_MEDIA_URI);
    if (!TextUtils.isEmpty(mediaUriStr)) {
        mediaUri = Uri.parse(mediaUriStr);
    }
    MediaDescription.Builder bob = new MediaDescription.Builder();
    bob.setMediaId(mediaId);
    bob.setTitle(text[0]);
    bob.setSubtitle(text[1]);
    bob.setDescription(text[2]);
    bob.setIconBitmap(icon);
    bob.setIconUri(iconUri);
    bob.setMediaUri(mediaUri);
    if (mBundle.containsKey(METADATA_KEY_BT_FOLDER_TYPE)) {
        Bundle bundle = new Bundle();
        bundle.putLong(MediaDescription.EXTRA_BT_FOLDER_TYPE, getLong(METADATA_KEY_BT_FOLDER_TYPE));
        bob.setExtras(bundle);
    }
    mDescription = bob.build();
    return mDescription;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.OutputConfiguration.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType);
    }
    return HashCodeHelpers.hashCode(mRotation, mSurface.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId);
}
Body of Second Method:
{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0);
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0);
}
------------------------
Find a silently evolved API code:android.os.StrictMode.readAndHandleBinderCallViolations:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, "strict mode violation stacks read from binder call.  i=" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
            String front = info.crashInfo.stackTrace.substring(0, 256);
            // 30000 characters is way too large for this to be any sane kind of
            // strict mode collection of stacks.  We've had a problem where we leave
            // strict mode violations associated with the thread, and it keeps tacking
            // more and more stacks on to the violations.  Looks like we're in this casse,
            // so we'll report it and bail on all of the current strict mode violations
            // we currently are maintaining for this thread.
            // First, drain the remaining violations from the parcel.
            // Skip the current entry.
            i++;
            for (; i < numViolations; i++) {
                info = new ViolationInfo(p, !currentlyGathering);
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, "Stack is too large: numViolations=" + numViolations + " policy=#" + Integer.toHexString(policyMask) + " front=" + front);
            return;
        }
        info.crashInfo.stackTrace += "# via Binder call with stack:\n" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}
Body of Second Method:
{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    sw.append("# via Binder call with stack:\n");
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    final int policyMask = getThreadPolicyMask();
    final boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    final int size = p.readInt();
    for (int i = 0; i < size; i++) {
        final ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        info.crashInfo.appendStackTrace(ourStack);
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getNetworkOperator:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the numeric name (MCC+MNC) of current registered operator.
 * <p>
 * Availability: Only when user is registered to a network. Result may be
 * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if
 * on a CDMA network).
 */

Body of Frist Method:
{
    return getNetworkOperatorForPhone(getDefaultPhone());
}
Body of Second Method:
{
    return getNetworkOperatorForPhone(getPhoneId());
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.putPhoneIdAndSubIdExtra:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int[] subIds = SubscriptionManager.getSubId(phoneId);
    if (subIds != null && subIds.length > 0) {
        putPhoneIdAndSubIdExtra(intent, phoneId, subIds[0]);
    } else {
        logd("putPhoneIdAndSubIdExtra: no valid subs");
    }
}
Body of Second Method:
{
    if (VDBG)
        logd("putPhoneIdAndSubIdExtra: phoneId=" + phoneId + " subId=" + subId);
    intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, subId);
    intent.putExtra(EXTRA_SUBSCRIPTION_INDEX, subId);
    intent.putExtra(PhoneConstants.PHONE_KEY, phoneId);
    // FIXME this is using phoneId and slotIndex interchangeably
    // Eventually, this should be removed as it is not the slot id
    intent.putExtra(PhoneConstants.SLOT_KEY, phoneId);
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.shouldPlayBackward:COMMENT
Method Modifier: private     
Comment:/**
 * Calculates the direction of animation playing (i.e. forward or backward), based on 1)
 * whether the entire animation is being reversed, 2) repeat mode applied to the current
 * iteration.
 */

Body of Frist Method:
{
    if (iteration > 0 && mRepeatMode == REVERSE && (iteration < (mRepeatCount + 1) || mRepeatCount == INFINITE)) {
        // figure out the correct direction to start playing based on the iteration
        if (mReversing) {
            return (iteration % 2) == 0;
        } else {
            return (iteration % 2) != 0;
        }
    } else {
        return mReversing;
    }
}
Body of Second Method:
{
    if (iteration > 0 && mRepeatMode == REVERSE && (iteration < (mRepeatCount + 1) || mRepeatCount == INFINITE)) {
        // figure out the correct direction to start playing based on the iteration
        if (inReverse) {
            return (iteration % 2) == 0;
        } else {
            return (iteration % 2) != 0;
        }
    } else {
        return inReverse;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the volume index for a particular stream.
 * <p>This method has no effect if the device implements a fixed volume policy
 * as indicated by {@link #isVolumeFixed()}.
 * <p>From N onward, volume adjustments that would toggle Do Not Disturb are not allowed unless
 * the app has been granted Do Not Disturb Access.
 * See {@link NotificationManager#isNotificationPolicyAccessGranted()}.
 * @param streamType The stream whose volume index should be set.
 * @param index The volume index to set. See
 * {@link #getStreamMaxVolume(int)} for the largest valid value.
 * @param flags One or more flags.
 * @see #getStreamMaxVolume(int)
 * @see #getStreamVolume(int)
 * @see #isVolumeFixed()
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setStreamVolume(streamType, index, flags, getContext().getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.setStreamVolume(streamType, index, flags, getContext().getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path.cubicTo:COMMENT
Method Modifier: public      
Comment:/**
 * Add a cubic bezier from the last point, approaching control points
 * (x1,y1) and (x2,y2), and ending at (x3,y3). If no moveTo() call has been
 * made for this contour, the first point is automatically set to (0,0).
 *
 * @param x1 The x-coordinate of the 1st control point on a cubic curve
 * @param y1 The y-coordinate of the 1st control point on a cubic curve
 * @param x2 The x-coordinate of the 2nd control point on a cubic curve
 * @param y2 The y-coordinate of the 2nd control point on a cubic curve
 * @param x3 The x-coordinate of the end point on a cubic curve
 * @param y3 The y-coordinate of the end point on a cubic curve
 */

Body of Frist Method:
{
    isSimplePath = false;
    native_cubicTo(mNativePath, x1, y1, x2, y2, x3, y3);
}
Body of Second Method:
{
    isSimplePath = false;
    nCubicTo(mNativePath, x1, y1, x2, y2, x3, y3);
}
------------------------
Find a silently evolved API code:android.transition.Visibility.onDisappear:COMMENT
Method Modifier: public      
Comment:/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */

Body of Frist Method:
{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = viewToKeep.getVisibility();
        viewToKeep.setTransitionVisibility(View.VISIBLE);
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, finalVisibility, mSuppressLayout);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}
Body of Second Method:
{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                    transition.removeListener(this);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = viewToKeep.getVisibility();
        viewToKeep.setTransitionVisibility(View.VISIBLE);
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, finalVisibility, mSuppressLayout);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setAltSubjectMatch:COMMENT
Method Modifier: public      
Comment:/**
 * Set alternate subject match. This is the substring to be matched against the
 * alternate subject of the authentication server certificate.
 * @param altSubjectMatch substring to be matched, for example
 * DNS:server.example.com;EMAIL:server@example.com
 */

Body of Frist Method:
{
    setFieldValue(ALTSUBJECT_MATCH_KEY, altSubjectMatch, "");
}
Body of Second Method:
{
    setFieldValue(ALTSUBJECT_MATCH_KEY, altSubjectMatch);
}
------------------------
Find a silently evolved API code:javax.obex.ClientOperation.validateConnection:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Verifies that the connection is open and the proper data has been read.
 * @throws IOException if an IO error occurs
 */

Body of Frist Method:
{
    ensureOpen();
    // to sure only one privateInput object exist.
    if (mPrivateInput == null) {
        startProcessing();
    }
}
Body of Second Method:
{
    ensureOpen();
    // before continuing
    if (mPrivateInput == null || mReplyHeader.responseCode == -1) {
        startProcessing();
    }
}
------------------------
Find a silently evolved API code:android.graphics.LightingColorFilter.setColorAdd:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Specifies the RGB that will be added to the source color when
 * the color filter is applied.
 * The alpha channel of this color is ignored.
 *
 * @see #getColorAdd()
 *
 * @hide
 */

Body of Frist Method:
{
    mAdd = add;
    update();
}
Body of Second Method:
{
    if (mAdd != add) {
        mAdd = add;
        discardNativeInstance();
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setTelephonyProperty:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Sets the telephony property with the value specified.
 *
 * @hide
 */

Body of Frist Method:
{
    String propVal = "";
    String[] p = null;
    String prop = SystemProperties.get(property);
    if (value == null) {
        value = "";
    }
    if (prop != null) {
        p = prop.split(",");
    }
    if (!SubscriptionManager.isValidPhoneId(phoneId)) {
        Rlog.d(TAG, "setTelephonyProperty: invalid phoneId=" + phoneId + " property=" + property + " value: " + value + " prop=" + prop);
        return;
    }
    for (int i = 0; i < phoneId; i++) {
        String str = "";
        if ((p != null) && (i < p.length)) {
            str = p[i];
        }
        propVal = propVal + str + ",";
    }
    propVal = propVal + value;
    if (p != null) {
        for (int i = phoneId + 1; i < p.length; i++) {
            propVal = propVal + "," + p[i];
        }
    }
    if (property.length() > SystemProperties.PROP_NAME_MAX || propVal.length() > SystemProperties.PROP_VALUE_MAX) {
        Rlog.d(TAG, "setTelephonyProperty: property to long phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
        return;
    }
    Rlog.d(TAG, "setTelephonyProperty: success phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
    SystemProperties.set(property, propVal);
}
Body of Second Method:
{
    String propVal = "";
    String[] p = null;
    String prop = SystemProperties.get(property);
    if (value == null) {
        value = "";
    }
    if (prop != null) {
        p = prop.split(",");
    }
    if (!SubscriptionManager.isValidPhoneId(phoneId)) {
        Rlog.d(TAG, "setTelephonyProperty: invalid phoneId=" + phoneId + " property=" + property + " value: " + value + " prop=" + prop);
        return;
    }
    for (int i = 0; i < phoneId; i++) {
        String str = "";
        if ((p != null) && (i < p.length)) {
            str = p[i];
        }
        propVal = propVal + str + ",";
    }
    propVal = propVal + value;
    if (p != null) {
        for (int i = phoneId + 1; i < p.length; i++) {
            propVal = propVal + "," + p[i];
        }
    }
    if (propVal.length() > SystemProperties.PROP_VALUE_MAX) {
        Rlog.d(TAG, "setTelephonyProperty: property too long phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
        return;
    }
    Rlog.d(TAG, "setTelephonyProperty: success phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
    SystemProperties.set(property, propVal);
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.removeExtras:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Removes extras associated with a {@code Connection}.
 * @param callId The unique ID of the call.
 * @param keys The extra keys to remove.
 */

Body of Frist Method:
{
    Log.v(this, "removeExtras: %s %s", callId, keys);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.removeExtras(callId, keys);
        } catch (RemoteException ignored) {
        }
    }
}
Body of Second Method:
{
    Log.v(this, "removeExtras: %s %s", callId, keys);
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            adapter.removeExtras(callId, keys, Log.getExternalSession());
        } catch (RemoteException ignored) {
        }
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderOperation.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Create a ContentProviderOperation from this {@link Builder}.
 */

Body of Frist Method:
{
    if (mType == TYPE_UPDATE) {
        if ((mValues == null || mValues.size() == 0) && (mValuesBackReferences == null || mValuesBackReferences.size() == 0)) {
            throw new IllegalArgumentException("Empty values");
        }
    }
    if (mType == TYPE_ASSERT) {
        if ((mValues == null || mValues.size() == 0) && (mValuesBackReferences == null || mValuesBackReferences.size() == 0) && (mExpectedCount == null)) {
            throw new IllegalArgumentException("Empty values");
        }
    }
    return new ContentProviderOperation(this);
}
Body of Second Method:
{
    if (mType == TYPE_UPDATE) {
        if ((mValues == null || mValues.isEmpty()) && (mValuesBackReferences == null || mValuesBackReferences.isEmpty())) {
            throw new IllegalArgumentException("Empty values");
        }
    }
    if (mType == TYPE_ASSERT) {
        if ((mValues == null || mValues.isEmpty()) && (mValuesBackReferences == null || mValuesBackReferences.isEmpty()) && (mExpectedCount == null)) {
            throw new IllegalArgumentException("Empty values");
        }
    }
    return new ContentProviderOperation(this);
}
------------------------
Find a silently evolved API code:android.content.ClipboardManager.setPrimaryClip:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 */

Body of Frist Method:
{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess(true);
        }
        getService().setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess(true);
        }
        mService.setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.initialize:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initialize gsm/cdma values, sets lte values to defaults.
 *
 * @param gsmSignalStrength
 * @param gsmBitErrorRate
 * @param cdmaDbm
 * @param cdmaEcio
 * @param evdoDbm
 * @param evdoEcio
 * @param evdoSnr
 * @param gsm
 *
 * @hide
 */

Body of Frist Method:
{
    initialize(gsmSignalStrength, gsmBitErrorRate, cdmaDbm, cdmaEcio, evdoDbm, evdoEcio, evdoSnr, 99, INVALID, INVALID, INVALID, INVALID, gsm);
}
Body of Second Method:
{
    initialize(gsmSignalStrength, gsmBitErrorRate, cdmaDbm, cdmaEcio, evdoDbm, evdoEcio, evdoSnr, 99, INVALID, INVALID, INVALID, INVALID, 0, gsm);
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getPhoneTypeFromNetworkType:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    // When the system property CURRENT_ACTIVE_PHONE, has not been set,
    // use the system property for default network type.
    // This is a fail safe, and can only happen at first boot.
    String mode = getTelephonyProperty(phoneId, "ro.telephony.default_network", null);
    if (mode != null) {
        return TelephonyManager.getPhoneType(Integer.parseInt(mode));
    }
    return TelephonyManager.PHONE_TYPE_NONE;
}
Body of Second Method:
{
    // When the system property CURRENT_ACTIVE_PHONE, has not been set,
    // use the system property for default network type.
    // This is a fail safe, and can only happen at first boot.
    String mode = getTelephonyProperty(phoneId, "ro.telephony.default_network", null);
    if (mode != null && !mode.isEmpty()) {
        return TelephonyManager.getPhoneType(Integer.parseInt(mode));
    }
    return TelephonyManager.PHONE_TYPE_NONE;
}
------------------------
Find a silently evolved API code:android.content.ClipboardManager.hasPrimaryClip:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if there is currently a primary clip on the clipboard.
 */

Body of Frist Method:
{
    try {
        return getService().hasPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return mService.hasPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getByteCount:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the minimum number of bytes that can be used to store this bitmap's pixels.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#KITKAT}, the result of this method can
 * no longer be used to determine memory usage of a bitmap. See {@link
 * #getAllocationByteCount()}.</p>
 */

Body of Frist Method:
{
    // int result permits bitmaps up to 46,340 x 46,340
    return getRowBytes() * getHeight();
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getByteCount() on a recycle()'d bitmap! " + "This is undefined behavior!");
        return 0;
    }
    // int result permits bitmaps up to 46,340 x 46,340
    return getRowBytes() * getHeight();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGattServer.removeService:COMMENT
Method Modifier: public      
Comment:/**
 * Removes a service from the list of services to be provided.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param service Service to be removed.
 * @return true, if the service has been removed
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "removeService() - service: " + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService intService = getService(service.getUuid(), service.getInstanceId(), service.getType());
    if (intService == null)
        return false;
    try {
        mService.removeService(mServerIf, service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()));
        mServices.remove(intService);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "removeService() - service: " + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService intService = getService(service.getUuid(), service.getInstanceId(), service.getType());
    if (intService == null)
        return false;
    try {
        mService.removeService(mServerIf, service.getInstanceId());
        mServices.remove(intService);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.reset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setInetAddress(null);
    setBSSID(null);
    setSSID(null);
    setNetworkId(-1);
    setRssi(INVALID_RSSI);
    setLinkSpeed(-1);
    setFrequency(-1);
    setMeteredHint(false);
    setEphemeral(false);
    txBad = 0;
    txSuccess = 0;
    rxSuccess = 0;
    txRetries = 0;
    txBadRate = 0;
    txSuccessRate = 0;
    rxSuccessRate = 0;
    txRetriesRate = 0;
    lowRssiCount = 0;
    badRssiCount = 0;
    linkStuckCount = 0;
    score = 0;
}
Body of Second Method:
{
    setInetAddress(null);
    setBSSID(null);
    setSSID(null);
    setNetworkId(-1);
    setRssi(INVALID_RSSI);
    setLinkSpeed(-1);
    setFrequency(-1);
    setMeteredHint(false);
    setEphemeral(false);
    txBad = 0;
    txSuccess = 0;
    rxSuccess = 0;
    txRetries = 0;
    txBadRate = 0;
    txSuccessRate = 0;
    rxSuccessRate = 0;
    txRetriesRate = 0;
    lowRssiCount = 0;
    badRssiCount = 0;
    linkStuckCount = 0;
    score = 0;
    mLastPacketCountUpdateTimeStamp = RESET_TIME_STAMP;
}
------------------------
Find a silently evolved API code:android.view.Display.getRectSize:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the size of the display as a rectangle, in pixels.
 *
 * @param outSize A {@link Rect} object to receive the size information.
 * @see #getSize(Point)
 */

Body of Frist Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(mTempMetrics, mDisplayAdjustments);
        outSize.set(0, 0, mTempMetrics.widthPixels, mTempMetrics.heightPixels);
    }
}
Body of Second Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(mTempMetrics, getDisplayAdjustments());
        outSize.set(0, 0, mTempMetrics.widthPixels, mTempMetrics.heightPixels);
    }
}
------------------------
Find a silently evolved API code:android.provider.DocumentsContract.deleteDocument:COMMENT
Method Modifier: public      static      
Comment:/**
 * Delete the given document.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_DELETE}
 * @return if the document was deleted successfully.
 */

Body of Frist Method:
{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        deleteDocument(client, documentUri);
        return true;
    } catch (Exception e) {
        Log.w(TAG, "Failed to delete document", e);
        return false;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}
Body of Second Method:
{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        deleteDocument(client, documentUri);
        return true;
    } catch (Exception e) {
        Log.w(TAG, "Failed to delete document", e);
        rethrowIfNecessary(resolver, e);
        return false;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getCallStateForSlot:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * See getCallState.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return CALL_STATE_IDLE;
        return telephony.getCallStateForSlot(slotId);
    } catch (RemoteException ex) {
        // the phone process is restarting.
        return CALL_STATE_IDLE;
    } catch (NullPointerException ex) {
        // the phone process is restarting.
        return CALL_STATE_IDLE;
    }
}
Body of Second Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return CALL_STATE_IDLE;
        return telephony.getCallStateForSlot(slotIndex);
    } catch (RemoteException ex) {
        // the phone process is restarting.
        return CALL_STATE_IDLE;
    } catch (NullPointerException ex) {
        // the phone process is restarting.
        return CALL_STATE_IDLE;
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebViewUpdateService.getCurrentWebViewPackageName:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Used by DevelopmentSetting to get the name of the WebView provider currently in use.
 */

Body of Frist Method:
{
    try {
        return getUpdateService().getCurrentWebViewPackageName();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return getUpdateService().getCurrentWebViewPackageName();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path_Delegate.getWindingRule:COMMENT
Method Modifier: private     static      
Comment:/**
 * Returns the Java2D winding rules matching a given Android {@link FillType}.
 * @param type the android fill type
 * @return the matching java2d winding rule.
 */

Body of Frist Method:
{
    switch(type) {
        case WINDING:
        case INVERSE_WINDING:
            return GeneralPath.WIND_NON_ZERO;
        case EVEN_ODD:
        case INVERSE_EVEN_ODD:
            return GeneralPath.WIND_EVEN_ODD;
    }
    assert false;
    throw new IllegalArgumentException();
}
Body of Second Method:
{
    switch(type) {
        case WINDING:
        case INVERSE_WINDING:
            return GeneralPath.WIND_NON_ZERO;
        case EVEN_ODD:
        case INVERSE_EVEN_ODD:
            return GeneralPath.WIND_EVEN_ODD;
        default:
            assert false;
            return GeneralPath.WIND_NON_ZERO;
    }
}
------------------------
Find a silently evolved API code:android.text.method.WordIterator.preceding:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    int shiftedOffset = offset - mOffsetShift;
    do {
        shiftedOffset = mIterator.preceding(shiftedOffset);
        if (shiftedOffset == BreakIterator.DONE) {
            return BreakIterator.DONE;
        }
        if (isOnLetterOrDigit(shiftedOffset)) {
            return shiftedOffset + mOffsetShift;
        }
    } while (true);
}
Body of Second Method:
{
    checkOffsetIsValid(offset);
    while (true) {
        offset = mIterator.preceding(offset);
        if (offset == BreakIterator.DONE || isOnLetterOrDigit(offset)) {
            return offset;
        }
    }
}
------------------------
Find a silently evolved API code:android.content.ClipDescription.hasMimeType:COMMENT
Method Modifier: public      
Comment:/**
 * Check whether the clip description contains the given MIME type.
 *
 * @param mimeType The desired MIME type.  May be a pattern.
 * @return Returns true if one of the MIME types in the clip description
 * matches the desired MIME type, else false.
 */

Body of Frist Method:
{
    for (int i = 0; i < mMimeTypes.length; i++) {
        if (compareMimeTypes(mMimeTypes[i], mimeType)) {
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    final int size = mMimeTypes.size();
    for (int i = 0; i < size; i++) {
        if (compareMimeTypes(mMimeTypes.get(i), mimeType)) {
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.midi.MidiDevice.connectPorts:COMMENT
Method Modifier: public      
Comment:/**
 * Connects the supplied {@link MidiInputPort} to the output port of this device
 * with the specified port number. Once the connection is made, the MidiInput port instance
 * can no longer receive data via its {@link MidiReceiver#onSend} method.
 * This method returns a {@link MidiDevice.MidiConnection} object, which can be used
 * to close the connection.
 *
 * @param inputPort the inputPort to connect
 * @param outputPortNumber the port number of the output port to connect inputPort to.
 * @return {@link MidiDevice.MidiConnection} object if the connection is successful,
 * or null in case of failure.
 */

Body of Frist Method:
{
    if (outputPortNumber < 0 || outputPortNumber >= mDeviceInfo.getOutputPortCount()) {
        throw new IllegalArgumentException("outputPortNumber out of range");
    }
    if (mIsDeviceClosed) {
        return null;
    }
    ParcelFileDescriptor pfd = inputPort.claimFileDescriptor();
    if (pfd == null) {
        return null;
    }
    try {
        IBinder token = new Binder();
        int calleePid = mDeviceServer.connectPorts(token, pfd, outputPortNumber);
        // kill the connection. So don't do that.
        if (calleePid != Process.myPid()) {
            // close our copy of the file descriptor
            IoUtils.closeQuietly(pfd);
        }
        return new MidiConnection(token, inputPort);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in connectPorts");
        return null;
    }
}
Body of Second Method:
{
    if (outputPortNumber < 0 || outputPortNumber >= mDeviceInfo.getOutputPortCount()) {
        throw new IllegalArgumentException("outputPortNumber out of range");
    }
    if (mIsDeviceClosed) {
        return null;
    }
    FileDescriptor fd = inputPort.claimFileDescriptor();
    if (fd == null) {
        return null;
    }
    try {
        IBinder token = new Binder();
        int calleePid = mDeviceServer.connectPorts(token, fd, outputPortNumber);
        // kill the connection. So don't do that.
        if (calleePid != Process.myPid()) {
            // close our copy of the file descriptor
            IoUtils.closeQuietly(fd);
        }
        return new MidiConnection(token, inputPort);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in connectPorts");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkIdentity.buildNetworkIdentity:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Build a {@link NetworkIdentity} from the given {@link NetworkState},
 * assuming that any mobile networks are using the current IMSI.
 */

Body of Frist Method:
{
    final int type = state.networkInfo.getType();
    final int subType = state.networkInfo.getSubtype();
    String subscriberId = null;
    String networkId = null;
    boolean roaming = false;
    boolean metered = false;
    if (isNetworkTypeMobile(type)) {
        if (state.subscriberId == null) {
            Slog.w(TAG, "Active mobile network without subscriber!");
        }
        subscriberId = state.subscriberId;
        roaming = state.networkInfo.isRoaming();
        metered = !state.networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else if (type == TYPE_WIFI) {
        if (state.networkId != null) {
            networkId = state.networkId;
        } else {
            final WifiManager wifi = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
            final WifiInfo info = wifi.getConnectionInfo();
            networkId = info != null ? info.getSSID() : null;
        }
    }
    return new NetworkIdentity(type, subType, subscriberId, networkId, roaming, metered);
}
Body of Second Method:
{
    final int type = state.networkInfo.getType();
    final int subType = state.networkInfo.getSubtype();
    String subscriberId = null;
    String networkId = null;
    boolean roaming = false;
    boolean metered = !state.networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    if (isNetworkTypeMobile(type)) {
        if (state.subscriberId == null) {
            if (state.networkInfo.getState() != NetworkInfo.State.DISCONNECTED && state.networkInfo.getState() != NetworkInfo.State.UNKNOWN) {
                Slog.w(TAG, "Active mobile network without subscriber! ni = " + state.networkInfo);
            }
        }
        subscriberId = state.subscriberId;
        roaming = state.networkInfo.isRoaming();
    } else if (type == TYPE_WIFI) {
        if (state.networkId != null) {
            networkId = state.networkId;
        } else {
            final WifiManager wifi = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
            final WifiInfo info = wifi.getConnectionInfo();
            networkId = info != null ? info.getSSID() : null;
        }
    }
    return new NetworkIdentity(type, subType, subscriberId, networkId, roaming, metered);
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.openDevice:COMMENT
Method Modifier: public      
Comment:/**
 * Opens the device so it can be used to send and receive
 * data using {@link android.hardware.usb.UsbRequest}.
 *
 * @param device the device to open
 * @return a {@link UsbDeviceConnection}, or {@code null} if open failed
 */

Body of Frist Method:
{
    try {
        String deviceName = device.getDeviceName();
        ParcelFileDescriptor pfd = mService.openDevice(deviceName);
        if (pfd != null) {
            UsbDeviceConnection connection = new UsbDeviceConnection(device);
            boolean result = connection.open(deviceName, pfd);
            pfd.close();
            if (result) {
                return connection;
            }
        }
    } catch (Exception e) {
        Log.e(TAG, "exception in UsbManager.openDevice", e);
    }
    return null;
}
Body of Second Method:
{
    try {
        String deviceName = device.getDeviceName();
        ParcelFileDescriptor pfd = mService.openDevice(deviceName);
        if (pfd != null) {
            UsbDeviceConnection connection = new UsbDeviceConnection(device);
            boolean result = connection.open(deviceName, pfd, mContext);
            pfd.close();
            if (result) {
                return connection;
            }
        }
    } catch (Exception e) {
        Log.e(TAG, "exception in UsbManager.openDevice", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStats.getNextHistoryBucket:COMMENT
Method Modifier: private     
Comment:/**
 * Getting the next item in a history enumeration.
 * @param bucketOut Next item will be set here.
 * @return true if a next item could be set.
 */

Body of Frist Method:
{
    if (bucketOut != null && mHistory != null) {
        if (mEnumerationIndex < mHistory.size()) {
            mRecycledHistoryEntry = mHistory.getValues(mEnumerationIndex++, mRecycledHistoryEntry);
            bucketOut.mUid = Bucket.convertUid(getUid());
            bucketOut.mTag = Bucket.convertTag(mTag);
            bucketOut.mState = Bucket.STATE_ALL;
            bucketOut.mRoaming = Bucket.ROAMING_ALL;
            bucketOut.mBeginTimeStamp = mRecycledHistoryEntry.bucketStart;
            bucketOut.mEndTimeStamp = mRecycledHistoryEntry.bucketStart + mRecycledHistoryEntry.bucketDuration;
            bucketOut.mRxBytes = mRecycledHistoryEntry.rxBytes;
            bucketOut.mRxPackets = mRecycledHistoryEntry.rxPackets;
            bucketOut.mTxBytes = mRecycledHistoryEntry.txBytes;
            bucketOut.mTxPackets = mRecycledHistoryEntry.txPackets;
            return true;
        } else if (hasNextUid()) {
            stepHistory();
            return getNextHistoryBucket(bucketOut);
        }
    }
    return false;
}
Body of Second Method:
{
    if (bucketOut != null && mHistory != null) {
        if (mEnumerationIndex < mHistory.size()) {
            mRecycledHistoryEntry = mHistory.getValues(mEnumerationIndex++, mRecycledHistoryEntry);
            bucketOut.mUid = Bucket.convertUid(getUid());
            bucketOut.mTag = Bucket.convertTag(mTag);
            bucketOut.mState = Bucket.STATE_ALL;
            bucketOut.mMetered = Bucket.METERED_ALL;
            bucketOut.mRoaming = Bucket.ROAMING_ALL;
            bucketOut.mBeginTimeStamp = mRecycledHistoryEntry.bucketStart;
            bucketOut.mEndTimeStamp = mRecycledHistoryEntry.bucketStart + mRecycledHistoryEntry.bucketDuration;
            bucketOut.mRxBytes = mRecycledHistoryEntry.rxBytes;
            bucketOut.mRxPackets = mRecycledHistoryEntry.rxPackets;
            bucketOut.mTxBytes = mRecycledHistoryEntry.txBytes;
            bucketOut.mTxPackets = mRecycledHistoryEntry.txPackets;
            return true;
        } else if (hasNextUid()) {
            stepHistory();
            return getNextHistoryBucket(bucketOut);
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getSmsReceiveCapableForPhone:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get SMS receive capable from system property by phone id.
 *
 * @param phoneId for which SMS receive capable is get
 * @param defaultValue default value
 * @return SMS receive capable
 *
 * @hide
 */

Body of Frist Method:
{
    if (SubscriptionManager.isValidPhoneId(phoneId)) {
        return Boolean.valueOf(TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_SMS_RECEIVE, String.valueOf(defaultValue)));
    }
    return defaultValue;
}
Body of Second Method:
{
    if (SubscriptionManager.isValidPhoneId(phoneId)) {
        return Boolean.parseBoolean(TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_SMS_RECEIVE, String.valueOf(defaultValue)));
    }
    return defaultValue;
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.setSpan:COMMENT
Method Modifier: public      
Comment:/**
 * Mark the specified range of text with the specified object.
 * The flags determine how the span will behave when text is
 * inserted at the start or end of the span's range.
 */

Body of Frist Method:
{
    setSpan(true, what, start, end, flags);
}
Body of Second Method:
{
    setSpan(true, what, start, end, flags, true);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.addStatusChangeListener:COMMENT
Method Modifier: public      static      
Comment:/**
 * Request notifications when the different aspects of the SyncManager change. The
 * different items that can be requested are:
 * <ul>
 * <li> {@link #SYNC_OBSERVER_TYPE_PENDING}
 * <li> {@link #SYNC_OBSERVER_TYPE_ACTIVE}
 * <li> {@link #SYNC_OBSERVER_TYPE_SETTINGS}
 * </ul>
 * The caller can set one or more of the status types in the mask for any
 * given listener registration.
 * @param mask the status change types that will cause the callback to be invoked
 * @param callback observer to be invoked when the status changes
 * @return a handle that can be used to remove the listener at a later time
 */

Body of Frist Method:
{
    if (callback == null) {
        throw new IllegalArgumentException("you passed in a null callback");
    }
    try {
        ISyncStatusObserver.Stub observer = new ISyncStatusObserver.Stub() {

            public void onStatusChanged(int which) throws RemoteException {
                callback.onStatusChanged(which);
            }
        };
        getContentService().addStatusChangeListener(mask, observer);
        return observer;
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    if (callback == null) {
        throw new IllegalArgumentException("you passed in a null callback");
    }
    try {
        ISyncStatusObserver.Stub observer = new ISyncStatusObserver.Stub() {

            @Override
            public void onStatusChanged(int which) throws RemoteException {
                callback.onStatusChanged(which);
            }
        };
        getContentService().addStatusChangeListener(mask, observer);
        return observer;
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
------------------------
Find a silently evolved API code:android.content.IntentSender.getCreatorUid:COMMENT
Method Modifier: public      
Comment:/**
 * Return the uid of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned integer is supplied by the system, so
 * that an application can not spoof its uid.
 *
 * @return The uid of the PendingIntent, or -1 if there is
 * none associated with it.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getUidForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return -1;
    }
}
Body of Second Method:
{
    try {
        return ActivityManager.getService().getUidForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return -1;
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    return protLevel;
}
Body of Second Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_EPHEMERAL) != 0) {
        protLevel += "|ephemeral";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel += "|runtime";
    }
    return protLevel;
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setupSetterAndGetter:COMMENT
Method Modifier: default     
Comment:/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */

Body of Frist Method:
{
    mKeyframes.invalidateCache();
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            List<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w("PropertyValuesHolder", "No such property (" + mProperty.getName() + ") on target object " + target + ". Trying reflection instead");
            mProperty = null;
        }
    }
    // We can't just say 'else' here because the catch statement sets mProperty to null.
    if (mProperty == null) {
        Class targetClass = target.getClass();
        if (mSetter == null) {
            setupSetter(targetClass);
        }
        List<Keyframe> keyframes = mKeyframes.getKeyframes();
        int keyframeCount = keyframes == null ? 0 : keyframes.size();
        for (int i = 0; i < keyframeCount; i++) {
            Keyframe kf = keyframes.get(i);
            if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                if (mGetter == null) {
                    setupGetter(targetClass);
                    if (mGetter == null) {
                        // Already logged the error - just return to avoid NPE
                        return;
                    }
                }
                try {
                    Object value = convertBack(mGetter.invoke(target));
                    kf.setValue(value);
                    kf.setValueWasSetOnStart(true);
                } catch (InvocationTargetException e) {
                    Log.e("PropertyValuesHolder", e.toString());
                } catch (IllegalAccessException e) {
                    Log.e("PropertyValuesHolder", e.toString());
                }
            }
        }
    }
}
Body of Second Method:
{
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            List<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w("PropertyValuesHolder", "No such property (" + mProperty.getName() + ") on target object " + target + ". Trying reflection instead");
            mProperty = null;
        }
    }
    // We can't just say 'else' here because the catch statement sets mProperty to null.
    if (mProperty == null) {
        Class targetClass = target.getClass();
        if (mSetter == null) {
            setupSetter(targetClass);
        }
        List<Keyframe> keyframes = mKeyframes.getKeyframes();
        int keyframeCount = keyframes == null ? 0 : keyframes.size();
        for (int i = 0; i < keyframeCount; i++) {
            Keyframe kf = keyframes.get(i);
            if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                if (mGetter == null) {
                    setupGetter(targetClass);
                    if (mGetter == null) {
                        // Already logged the error - just return to avoid NPE
                        return;
                    }
                }
                try {
                    Object value = convertBack(mGetter.invoke(target));
                    kf.setValue(value);
                    kf.setValueWasSetOnStart(true);
                } catch (InvocationTargetException e) {
                    Log.e("PropertyValuesHolder", e.toString());
                } catch (IllegalAccessException e) {
                    Log.e("PropertyValuesHolder", e.toString());
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.nfc.NdefRecord.parse:COMMENT
Method Modifier: default     static      
Comment:/**
 * Main record parsing method.<p>
 * Expects NdefMessage to begin immediately, allows trailing data.<p>
 * Currently has strict validation of all fields as per NDEF 1.0
 * specification section 2.5. We will attempt to keep this as strict as
 * possible to encourage well-formatted NDEF.<p>
 * Always returns 1 or more NdefRecord's, or throws FormatException.
 *
 * @param buffer ByteBuffer to read from
 * @param ignoreMbMe ignore MB and ME flags, and read only 1 complete record
 * @return one or more records
 * @throws FormatException on any parsing error
 */

Body of Frist Method:
{
    List<NdefRecord> records = new ArrayList<NdefRecord>();
    try {
        byte[] type = null;
        byte[] id = null;
        byte[] payload = null;
        ArrayList<byte[]> chunks = new ArrayList<byte[]>();
        boolean inChunk = false;
        short chunkTnf = -1;
        boolean me = false;
        while (!me) {
            byte flag = buffer.get();
            boolean mb = (flag & NdefRecord.FLAG_MB) != 0;
            me = (flag & NdefRecord.FLAG_ME) != 0;
            boolean cf = (flag & NdefRecord.FLAG_CF) != 0;
            boolean sr = (flag & NdefRecord.FLAG_SR) != 0;
            boolean il = (flag & NdefRecord.FLAG_IL) != 0;
            short tnf = (short) (flag & 0x07);
            if (!mb && records.size() == 0 && !inChunk && !ignoreMbMe) {
                throw new FormatException("expected MB flag");
            } else if (mb && records.size() != 0 && !ignoreMbMe) {
                throw new FormatException("unexpected MB flag");
            } else if (inChunk && il) {
                throw new FormatException("unexpected IL flag in non-leading chunk");
            } else if (cf && me) {
                throw new FormatException("unexpected ME flag in non-trailing chunk");
            } else if (inChunk && tnf != NdefRecord.TNF_UNCHANGED) {
                throw new FormatException("expected TNF_UNCHANGED in non-leading chunk");
            } else if (!inChunk && tnf == NdefRecord.TNF_UNCHANGED) {
                throw new FormatException("" + "unexpected TNF_UNCHANGED in first chunk or unchunked record");
            }
            int typeLength = buffer.get() & 0xFF;
            long payloadLength = sr ? (buffer.get() & 0xFF) : (buffer.getInt() & 0xFFFFFFFFL);
            int idLength = il ? (buffer.get() & 0xFF) : 0;
            if (inChunk && typeLength != 0) {
                throw new FormatException("expected zero-length type in non-leading chunk");
            }
            if (!inChunk) {
                type = (typeLength > 0 ? new byte[typeLength] : EMPTY_BYTE_ARRAY);
                id = (idLength > 0 ? new byte[idLength] : EMPTY_BYTE_ARRAY);
                buffer.get(type);
                buffer.get(id);
            }
            ensureSanePayloadSize(payloadLength);
            payload = (payloadLength > 0 ? new byte[(int) payloadLength] : EMPTY_BYTE_ARRAY);
            buffer.get(payload);
            if (cf && !inChunk) {
                // first chunk
                chunks.clear();
                chunkTnf = tnf;
            }
            if (cf || inChunk) {
                // any chunk
                chunks.add(payload);
            }
            if (!cf && inChunk) {
                // last chunk, flatten the payload
                payloadLength = 0;
                for (byte[] p : chunks) {
                    payloadLength += p.length;
                }
                ensureSanePayloadSize(payloadLength);
                payload = new byte[(int) payloadLength];
                int i = 0;
                for (byte[] p : chunks) {
                    System.arraycopy(p, 0, payload, i, p.length);
                    i += p.length;
                }
                tnf = chunkTnf;
            }
            if (cf) {
                // more chunks to come
                inChunk = true;
                continue;
            } else {
                inChunk = false;
            }
            String error = validateTnf(tnf, type, id, payload);
            if (error != null) {
                throw new FormatException(error);
            }
            records.add(new NdefRecord(tnf, type, id, payload));
            if (ignoreMbMe) {
                // for parsing a single NdefRecord
                break;
            }
        }
    } catch (BufferUnderflowException e) {
        throw new FormatException("expected more data", e);
    }
    return records.toArray(new NdefRecord[records.size()]);
}
Body of Second Method:
{
    List<NdefRecord> records = new ArrayList<NdefRecord>();
    try {
        byte[] type = null;
        byte[] id = null;
        byte[] payload = null;
        ArrayList<byte[]> chunks = new ArrayList<byte[]>();
        boolean inChunk = false;
        short chunkTnf = -1;
        boolean me = false;
        while (!me) {
            byte flag = buffer.get();
            boolean mb = (flag & NdefRecord.FLAG_MB) != 0;
            me = (flag & NdefRecord.FLAG_ME) != 0;
            boolean cf = (flag & NdefRecord.FLAG_CF) != 0;
            boolean sr = (flag & NdefRecord.FLAG_SR) != 0;
            boolean il = (flag & NdefRecord.FLAG_IL) != 0;
            short tnf = (short) (flag & 0x07);
            if (!mb && records.size() == 0 && !inChunk && !ignoreMbMe) {
                throw new FormatException("expected MB flag");
            } else if (mb && (records.size() != 0 || inChunk) && !ignoreMbMe) {
                throw new FormatException("unexpected MB flag");
            } else if (inChunk && il) {
                throw new FormatException("unexpected IL flag in non-leading chunk");
            } else if (cf && me) {
                throw new FormatException("unexpected ME flag in non-trailing chunk");
            } else if (inChunk && tnf != NdefRecord.TNF_UNCHANGED) {
                throw new FormatException("expected TNF_UNCHANGED in non-leading chunk");
            } else if (!inChunk && tnf == NdefRecord.TNF_UNCHANGED) {
                throw new FormatException("" + "unexpected TNF_UNCHANGED in first chunk or unchunked record");
            }
            int typeLength = buffer.get() & 0xFF;
            long payloadLength = sr ? (buffer.get() & 0xFF) : (buffer.getInt() & 0xFFFFFFFFL);
            int idLength = il ? (buffer.get() & 0xFF) : 0;
            if (inChunk && typeLength != 0) {
                throw new FormatException("expected zero-length type in non-leading chunk");
            }
            if (!inChunk) {
                type = (typeLength > 0 ? new byte[typeLength] : EMPTY_BYTE_ARRAY);
                id = (idLength > 0 ? new byte[idLength] : EMPTY_BYTE_ARRAY);
                buffer.get(type);
                buffer.get(id);
            }
            ensureSanePayloadSize(payloadLength);
            payload = (payloadLength > 0 ? new byte[(int) payloadLength] : EMPTY_BYTE_ARRAY);
            buffer.get(payload);
            if (cf && !inChunk) {
                // first chunk
                if (typeLength == 0 && tnf != NdefRecord.TNF_UNKNOWN) {
                    throw new FormatException("expected non-zero type length in first chunk");
                }
                chunks.clear();
                chunkTnf = tnf;
            }
            if (cf || inChunk) {
                // any chunk
                chunks.add(payload);
            }
            if (!cf && inChunk) {
                // last chunk, flatten the payload
                payloadLength = 0;
                for (byte[] p : chunks) {
                    payloadLength += p.length;
                }
                ensureSanePayloadSize(payloadLength);
                payload = new byte[(int) payloadLength];
                int i = 0;
                for (byte[] p : chunks) {
                    System.arraycopy(p, 0, payload, i, p.length);
                    i += p.length;
                }
                tnf = chunkTnf;
            }
            if (cf) {
                // more chunks to come
                inChunk = true;
                continue;
            } else {
                inChunk = false;
            }
            String error = validateTnf(tnf, type, id, payload);
            if (error != null) {
                throw new FormatException(error);
            }
            records.add(new NdefRecord(tnf, type, id, payload));
            if (ignoreMbMe) {
                // for parsing a single NdefRecord
                break;
            }
        }
    } catch (BufferUnderflowException e) {
        throw new FormatException("expected more data", e);
    }
    return records.toArray(new NdefRecord[records.size()]);
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.spliceOperationsFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Splice in {@link #operations} from the given {@link NetworkStats} based
 * on matching {@link #uid} and {@link #tag} rows. Ignores {@link #iface},
 * since operation counts are at data layer.
 */

Body of Frist Method:
{
    for (int i = 0; i < size; i++) {
        final int j = stats.findIndex(iface[i], uid[i], set[i], tag[i], roaming[i]);
        if (j == -1) {
            operations[i] = 0;
        } else {
            operations[i] = stats.operations[j];
        }
    }
}
Body of Second Method:
{
    for (int i = 0; i < size; i++) {
        final int j = stats.findIndex(iface[i], uid[i], set[i], tag[i], metered[i], roaming[i]);
        if (j == -1) {
            operations[i] = 0;
        } else {
            operations[i] = stats.operations[j];
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.Matrix.getValues:COMMENT
Method Modifier: public      
Comment:/**
 * Copy 9 values from the matrix into the array.
 */

Body of Frist Method:
{
    if (values.length < 9) {
        throw new ArrayIndexOutOfBoundsException();
    }
    native_getValues(native_instance, values);
}
Body of Second Method:
{
    if (values.length < 9) {
        throw new ArrayIndexOutOfBoundsException();
    }
    nGetValues(native_instance, values);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setSpeakerphoneOn:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the speakerphone on or off.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param on set <var>true</var> to turn on speakerphone;
 * <var>false</var> to turn it off
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setSpeakerphoneOn(on);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.setSpeakerphoneOn(on);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.sameAs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Compares if this icon is constructed from the same resources as another icon.
 * Note that this is an inexpensive operation and doesn't do deep Bitmap equality comparisons.
 *
 * @param otherIcon the other icon
 * @return whether this icon is the same as the another one
 * @hide
 */

Body of Frist Method:
{
    if (otherIcon == this) {
        return true;
    }
    if (mType != otherIcon.getType()) {
        return false;
    }
    switch(mType) {
        case TYPE_BITMAP:
            return getBitmap() == otherIcon.getBitmap();
        case TYPE_DATA:
            return getDataLength() == otherIcon.getDataLength() && getDataOffset() == otherIcon.getDataOffset() && getDataBytes() == otherIcon.getDataBytes();
        case TYPE_RESOURCE:
            return getResId() == otherIcon.getResId() && Objects.equals(getResPackage(), otherIcon.getResPackage());
        case TYPE_URI:
            return Objects.equals(getUriString(), otherIcon.getUriString());
    }
    return false;
}
Body of Second Method:
{
    if (otherIcon == this) {
        return true;
    }
    if (mType != otherIcon.getType()) {
        return false;
    }
    switch(mType) {
        case TYPE_BITMAP:
        case TYPE_ADAPTIVE_BITMAP:
            return getBitmap() == otherIcon.getBitmap();
        case TYPE_DATA:
            return getDataLength() == otherIcon.getDataLength() && getDataOffset() == otherIcon.getDataOffset() && getDataBytes() == otherIcon.getDataBytes();
        case TYPE_RESOURCE:
            return getResId() == otherIcon.getResId() && Objects.equals(getResPackage(), otherIcon.getResPackage());
        case TYPE_URI:
            return Objects.equals(getUriString(), otherIcon.getUriString());
    }
    return false;
}
------------------------
Find a silently evolved API code:android.renderscript.ScriptIntrinsicBlur.forEach:COMMENT
Method Modifier: public      
Comment:/**
 * Apply the filter to the input and save to the specified
 * allocation.
 *
 * @param aout Output allocation. Must match creation element
 * type.
 * @param opt LaunchOptions for clipping
 */

Body of Frist Method:
{
    forEach(0, (Allocation) null, aout, null, opt);
}
Body of Second Method:
{
    if (aout.getType().getY() == 0) {
        throw new RSIllegalArgumentException("Output is a 1D Allocation");
    }
    forEach(0, (Allocation) null, aout, null, opt);
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.updateHeaderSeparator:COMMENT
Method Modifier: private     
Comment:/**
 * The time separator is defined in the Unicode CLDR and cannot be supposed to be ":".
 *
 * See http://unicode.org/cldr/trac/browser/trunk/common/main
 *
 * We pass the correct "skeleton" depending on 12 or 24 hours view and then extract the
 * separator as the character which is just after the hour marker in the returned pattern.
 */

Body of Frist Method:
{
    final String bestDateTimePattern = DateFormat.getBestDateTimePattern(mLocale, (mIs24Hour) ? "Hm" : "hm");
    final String separatorText;
    // See http://www.unicode.org/reports/tr35/tr35-dates.html for hour formats
    final char[] hourFormats = { 'H', 'h', 'K', 'k' };
    int hIndex = lastIndexOfAny(bestDateTimePattern, hourFormats);
    if (hIndex == -1) {
        // Default case
        separatorText = ":";
    } else {
        separatorText = Character.toString(bestDateTimePattern.charAt(hIndex + 1));
    }
    mSeparatorView.setText(separatorText);
}
Body of Second Method:
{
    final String bestDateTimePattern = DateFormat.getBestDateTimePattern(mLocale, (mIs24Hour) ? "Hm" : "hm");
    final String separatorText;
    // See http://www.unicode.org/reports/tr35/tr35-dates.html for hour formats
    final char[] hourFormats = { 'H', 'h', 'K', 'k' };
    int hIndex = lastIndexOfAny(bestDateTimePattern, hourFormats);
    if (hIndex == -1) {
        // Default case
        separatorText = ":";
    } else {
        separatorText = Character.toString(bestDateTimePattern.charAt(hIndex + 1));
    }
    mSeparatorView.setText(separatorText);
    mTextInputPickerView.updateSeparator(separatorText);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isSpeakerphoneOn:COMMENT
Method Modifier: public      
Comment:/**
 * Checks whether the speakerphone is on or off.
 *
 * @return true if speakerphone is on, false if it's off
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.isSpeakerphoneOn();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        return service.isSpeakerphoneOn();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.ViewTreeObserver.removeOnDrawListener:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Remove a previously installed pre-draw callback.</p>
 * <p><strong>Note:</strong> this method <strong>cannot</strong> be invoked from
 * {@link android.view.ViewTreeObserver.OnDrawListener#onDraw()}.</p>
 *
 * @param victim The callback to remove
 *
 * @throws IllegalStateException If {@link #isAlive()} returns false
 *
 * @see #addOnDrawListener(OnDrawListener)
 */

Body of Frist Method:
{
    checkIsAlive();
    if (mOnDrawListeners == null) {
        return;
    }
    mOnDrawListeners.remove(victim);
}
Body of Second Method:
{
    checkIsAlive();
    if (mOnDrawListeners == null) {
        return;
    }
    if (mInDispatchOnDraw) {
        IllegalStateException ex = new IllegalStateException("Cannot call removeOnDrawListener inside of onDraw");
        if (sIllegalOnDrawModificationIsFatal) {
            throw ex;
        } else {
            Log.e("ViewTreeObserver", ex.getMessage(), ex);
        }
    }
    mOnDrawListeners.remove(victim);
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivityAsCaller:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Special version!
 * @hide
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
        int result = ActivityManagerNative.getDefault().startActivityAsCaller(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options, ignoreTargetSecurity, userId);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                ActivityResult result = null;
                if (am.ignoreMatchingSpecificIntents()) {
                    result = am.onStartActivity(intent);
                }
                if (result != null) {
                    am.mHits++;
                    return result;
                } else if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
        int result = ActivityManager.getService().startActivityAsCaller(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options, ignoreTargetSecurity, userId);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.net.http.SslCertificate.formatCertificateDate:COMMENT
Method Modifier: private     
Comment:/**
 * Formats the certificate date to a properly localized date string.
 * @return Properly localized version of the certificate date string and
 * the "" if it fails to localize.
 */

Body of Frist Method:
{
    if (certificateDate == null) {
        return "";
    }
    return DateFormat.getDateFormat(context).format(certificateDate);
}
Body of Second Method:
{
    if (certificateDate == null) {
        return "";
    }
    return DateFormat.getMediumDateFormat(context).format(certificateDate);
}
------------------------
Find a silently evolved API code:android.os.StrictMode.AndroidBlockGuardPolicy.handleViolation:COMMENT
Method Modifier: default     
Comment:// hence the policy being passed around.

Body of Frist Method:
{
    if (info == null || info.crashInfo == null || info.crashInfo.stackTrace == null) {
        Log.wtf(TAG, "unexpected null stacktrace");
        return;
    }
    if (LOG_V)
        Log.d(TAG, "handleViolation; policy=" + info.policy);
    if ((info.policy & PENALTY_GATHER) != 0) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<ViolationInfo>(1);
            gatheredViolations.set(violations);
        } else if (violations.size() >= 5) {
            // Too many.  In a loop or something?  Don't gather them all.
            return;
        }
        for (ViolationInfo previous : violations) {
            if (info.crashInfo.stackTrace.equals(previous.crashInfo.stackTrace)) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<Integer, Long>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if ((info.policy & PENALTY_LOG) != 0 && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        if (info.durationMillis != -1) {
            Log.d(TAG, "StrictMode policy violation; ~duration=" + info.durationMillis + " ms: " + info.crashInfo.stackTrace);
        } else {
            Log.d(TAG, "StrictMode policy violation: " + info.crashInfo.stackTrace);
        }
    }
    // The violationMaskSubset, passed to ActivityManager, is a
    // subset of the original StrictMode policy bitmask, with
    // only the bit violated and penalty bits to be executed
    // by the ActivityManagerService remaining set.
    int violationMaskSubset = 0;
    if ((info.policy & PENALTY_DIALOG) != 0 && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        violationMaskSubset |= PENALTY_DIALOG;
    }
    if ((info.policy & PENALTY_DROPBOX) != 0 && lastViolationTime == 0) {
        violationMaskSubset |= PENALTY_DROPBOX;
    }
    if (violationMaskSubset != 0) {
        int violationBit = parseViolationFromMessage(info.crashInfo.exceptionMessage);
        violationMaskSubset |= violationBit;
        final int savedPolicyMask = getThreadPolicyMask();
        final boolean justDropBox = (info.policy & THREAD_PENALTY_MASK) == PENALTY_DROPBOX;
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(violationMaskSubset, info);
            return;
        }
        // Normal synchronous call to the ActivityManager.
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            if (e instanceof DeadObjectException) {
            // System process is dead; ignore
            } else {
                Log.e(TAG, "RemoteException trying to handle StrictMode violation", e);
            }
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if ((info.policy & PENALTY_DEATH) != 0) {
        executeDeathPenalty(info);
    }
}
Body of Second Method:
{
    if (info == null || info.crashInfo == null || info.crashInfo.stackTrace == null) {
        Log.wtf(TAG, "unexpected null stacktrace");
        return;
    }
    if (LOG_V)
        Log.d(TAG, "handleViolation; policy=" + info.policy);
    if ((info.policy & PENALTY_GATHER) != 0) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<ViolationInfo>(1);
            gatheredViolations.set(violations);
        }
        for (ViolationInfo previous : violations) {
            if (info.crashInfo.stackTrace.equals(previous.crashInfo.stackTrace)) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<Integer, Long>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if ((info.policy & PENALTY_LOG) != 0 && sListener != null) {
        sListener.onViolation(info.crashInfo.stackTrace);
    }
    if ((info.policy & PENALTY_LOG) != 0 && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        if (info.durationMillis != -1) {
            Log.d(TAG, "StrictMode policy violation; ~duration=" + info.durationMillis + " ms: " + info.crashInfo.stackTrace);
        } else {
            Log.d(TAG, "StrictMode policy violation: " + info.crashInfo.stackTrace);
        }
    }
    // The violationMaskSubset, passed to ActivityManager, is a
    // subset of the original StrictMode policy bitmask, with
    // only the bit violated and penalty bits to be executed
    // by the ActivityManagerService remaining set.
    int violationMaskSubset = 0;
    if ((info.policy & PENALTY_DIALOG) != 0 && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        violationMaskSubset |= PENALTY_DIALOG;
    }
    if ((info.policy & PENALTY_DROPBOX) != 0 && lastViolationTime == 0) {
        violationMaskSubset |= PENALTY_DROPBOX;
    }
    if (violationMaskSubset != 0) {
        int violationBit = parseViolationFromMessage(info.crashInfo.exceptionMessage);
        violationMaskSubset |= violationBit;
        final int savedPolicyMask = getThreadPolicyMask();
        final boolean justDropBox = (info.policy & THREAD_PENALTY_MASK) == PENALTY_DROPBOX;
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(violationMaskSubset, info);
            return;
        }
        // Normal synchronous call to the ActivityManager.
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManager.getService().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            if (e instanceof DeadObjectException) {
            // System process is dead; ignore
            } else {
                Log.e(TAG, "RemoteException trying to handle StrictMode violation", e);
            }
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if ((info.policy & PENALTY_DEATH) != 0) {
        executeDeathPenalty(info);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.setMatrix:COMMENT
Method Modifier: public      
Comment:/**
 * Completely replace the current matrix with the specified matrix. If the
 * matrix parameter is null, then the current matrix is reset to identity.
 *
 * <strong>Note:</strong> it is recommended to use {@link #concat(Matrix)},
 * {@link #scale(float, float)}, {@link #translate(float, float)} and
 * {@link #rotate(float)} instead of this method.
 *
 * @param matrix The matrix to replace the current matrix with. If it is
 * null, set the current matrix to identity.
 *
 * @see #concat(Matrix)
 */

Body of Frist Method:
{
    native_setMatrix(mNativeCanvasWrapper, matrix == null ? 0 : matrix.native_instance);
}
Body of Second Method:
{
    nSetMatrix(mNativeCanvasWrapper, matrix == null ? 0 : matrix.native_instance);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.isEnterprise:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Helper function, idenfity if a configuration should be treated as an enterprise network
 * @hide
 */

Body of Frist Method:
{
    return allowedKeyManagement.get(KeyMgmt.WPA_EAP) || allowedKeyManagement.get(KeyMgmt.IEEE8021X);
}
Body of Second Method:
{
    return (allowedKeyManagement.get(KeyMgmt.WPA_EAP) || allowedKeyManagement.get(KeyMgmt.IEEE8021X)) && enterpriseConfig != null && enterpriseConfig.getEapMethod() != WifiEnterpriseConfig.Eap.NONE;
}
------------------------
Find a silently evolved API code:android.content.res.AssetManager.getPooledStringForCookie:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    // Cookies map to string blocks starting at 1.
    return mStringBlocks[cookie - 1].get(id);
}
Body of Second Method:
{
    synchronized (this) {
        // Cookies map to string blocks starting at 1.
        return mStringBlocks[cookie - 1].get(id);
    }
}
------------------------
Find a silently evolved API code:android.widget.CalendarViewLegacyDelegate.WeekView.drawWeekNumbersAndDates:COMMENT
Method Modifier: private     
Comment:/**
 * Draws the week and month day numbers for this week.
 *
 * @param canvas The canvas to draw on
 */

Body of Frist Method:
{
    final float textHeight = mDrawPaint.getTextSize();
    final int y = (int) ((mHeight + textHeight) / 2) - mWeekSeperatorLineWidth;
    final int nDays = mNumCells;
    final int divisor = 2 * nDays;
    mDrawPaint.setTextAlign(Paint.Align.CENTER);
    mDrawPaint.setTextSize(mDateTextSize);
    int i = 0;
    if (isLayoutRtl()) {
        for (; i < nDays - 1; i++) {
            mMonthNumDrawPaint.setColor(mFocusDay[i] ? mFocusedMonthDateColor : mUnfocusedMonthDateColor);
            int x = (2 * i + 1) * mWidth / divisor;
            canvas.drawText(mDayNumbers[nDays - 1 - i], x, y, mMonthNumDrawPaint);
        }
        if (mShowWeekNumber) {
            mDrawPaint.setColor(mWeekNumberColor);
            int x = mWidth - mWidth / divisor;
            canvas.drawText(mDayNumbers[0], x, y, mDrawPaint);
        }
    } else {
        if (mShowWeekNumber) {
            mDrawPaint.setColor(mWeekNumberColor);
            int x = mWidth / divisor;
            canvas.drawText(mDayNumbers[0], x, y, mDrawPaint);
            i++;
        }
        for (; i < nDays; i++) {
            mMonthNumDrawPaint.setColor(mFocusDay[i] ? mFocusedMonthDateColor : mUnfocusedMonthDateColor);
            int x = (2 * i + 1) * mWidth / divisor;
            canvas.drawText(mDayNumbers[i], x, y, mMonthNumDrawPaint);
        }
    }
}
Body of Second Method:
{
    final float textHeight = mDrawPaint.getTextSize();
    final int y = (int) ((mHeight + textHeight) / 2) - mWeekSeparatorLineWidth;
    final int nDays = mNumCells;
    final int divisor = 2 * nDays;
    mDrawPaint.setTextAlign(Paint.Align.CENTER);
    mDrawPaint.setTextSize(mDateTextSize);
    int i = 0;
    if (isLayoutRtl()) {
        for (; i < nDays - 1; i++) {
            mMonthNumDrawPaint.setColor(mFocusDay[i] ? mFocusedMonthDateColor : mUnfocusedMonthDateColor);
            int x = (2 * i + 1) * mWidth / divisor;
            canvas.drawText(mDayNumbers[nDays - 1 - i], x, y, mMonthNumDrawPaint);
        }
        if (mShowWeekNumber) {
            mDrawPaint.setColor(mWeekNumberColor);
            int x = mWidth - mWidth / divisor;
            canvas.drawText(mDayNumbers[0], x, y, mDrawPaint);
        }
    } else {
        if (mShowWeekNumber) {
            mDrawPaint.setColor(mWeekNumberColor);
            int x = mWidth / divisor;
            canvas.drawText(mDayNumbers[0], x, y, mDrawPaint);
            i++;
        }
        for (; i < nDays; i++) {
            mMonthNumDrawPaint.setColor(mFocusDay[i] ? mFocusedMonthDateColor : mUnfocusedMonthDateColor);
            int x = (2 * i + 1) * mWidth / divisor;
            canvas.drawText(mDayNumbers[i], x, y, mMonthNumDrawPaint);
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGattServer.notifyCharacteristicChanged:COMMENT
Method Modifier: public      
Comment:/**
 * Send a notification or indication that a local characteristic has been
 * updated.
 *
 * <p>A notification or indication is sent to the remote device to signal
 * that the characteristic has been updated. This function should be invoked
 * for every client that requests notifications/indications by writing
 * to the "Client Configuration" descriptor for the given characteristic.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to receive the notification/indication
 * @param characteristic The local characteristic that has been updated
 * @param confirm true to request confirmation from the client (indication),
 * false to send a notification
 * @throws IllegalArgumentException
 * @return true, if the notification has been triggered successfully
 */

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "notifyCharacteristicChanged() - device: " + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    if (characteristic.getValue() == null) {
        throw new IllegalArgumentException("Chracteristic value is empty. Use " + "BluetoothGattCharacteristic#setvalue to update");
    }
    try {
        mService.sendNotification(mServerIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), confirm, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "notifyCharacteristicChanged() - device: " + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    if (characteristic.getValue() == null) {
        throw new IllegalArgumentException("Chracteristic value is empty. Use " + "BluetoothGattCharacteristic#setvalue to update");
    }
    try {
        mService.sendNotification(mServerIf, device.getAddress(), characteristic.getInstanceId(), confirm, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.getMultipathIndicatorString:COMMENT
Method Modifier: private     
Comment:/**
 * Gets a string representation of the 'multi-path indicator'.
 *
 * <p>For internal and logging use only.
 */

Body of Frist Method:
{
    switch(mMultipathIndicator) {
        case MULTIPATH_INDICATOR_UNKNOWN:
            return "Unknown";
        case MULTIPATH_INDICATOR_DETECTED:
            return "Detected";
        case MULTIPATH_INDICATOR_NOT_USED:
            return "NotUsed";
        default:
            return "<Invalid:" + mMultipathIndicator + ">";
    }
}
Body of Second Method:
{
    switch(mMultipathIndicator) {
        case MULTIPATH_INDICATOR_UNKNOWN:
            return "Unknown";
        case MULTIPATH_INDICATOR_DETECTED:
            return "Detected";
        case MULTIPATH_INDICATOR_NOT_DETECTED:
            return "NotDetected";
        default:
            return "<Invalid:" + mMultipathIndicator + ">";
    }
}
------------------------
Find a silently evolved API code:android.widget.Toast.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Close the view if it's showing, or don't show it if it isn't showing yet.
 * You do not normally have to call this.  Normally view will disappear on its own
 * after the appropriate duration.
 */

Body of Frist Method:
{
    mTN.hide();
    try {
        getService().cancelToast(mContext.getPackageName(), mTN);
    } catch (RemoteException e) {
    // Empty
    }
}
Body of Second Method:
{
    mTN.cancel();
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.onConferenceMergeFailed:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Indicates that the merge request on this call has failed.
 *
 * @param callId The unique ID of the call being conferenced.
 */

Body of Frist Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            Log.d(this, "merge failed for call %s", callId);
            adapter.setConferenceMergeFailed(callId);
        } catch (RemoteException ignored) {
        }
    }
}
Body of Second Method:
{
    for (IConnectionServiceAdapter adapter : mAdapters) {
        try {
            Log.d(this, "merge failed for call %s", callId);
            adapter.setConferenceMergeFailed(callId, Log.getExternalSession());
        } catch (RemoteException ignored) {
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.ScanSettings.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build {@link ScanSettings}.
 */

Body of Frist Method:
{
    return new ScanSettings(mScanMode, mCallbackType, mScanResultType, mReportDelayMillis, mMatchMode, mNumOfMatchesPerFilter);
}
Body of Second Method:
{
    return new ScanSettings(mScanMode, mCallbackType, mScanResultType, mReportDelayMillis, mMatchMode, mNumOfMatchesPerFilter, mLegacy, mPhy);
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.setSpellCheckerEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        sService.setSpellCheckerEnabled(enabled);
    } catch (RemoteException e) {
        Log.e(TAG, "Error in setSpellCheckerEnabled:" + e);
    }
}
Body of Second Method:
{
    try {
        mService.setSpellCheckerEnabled(enabled);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.DownloadManager.getUriForDownloadedFile:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the {@link Uri} of the given downloaded file id, if the file is
 * downloaded successfully. Otherwise, null is returned.
 *
 * @param id the id of the downloaded file.
 * @return the {@link Uri} of the given downloaded file id, if download was
 * successful. null otherwise.
 */

Body of Frist Method:
{
    // to check if the file is in cache, get its destination from the database
    Query query = new Query().setFilterById(id);
    Cursor cursor = null;
    try {
        cursor = query(query);
        if (cursor == null) {
            return null;
        }
        if (cursor.moveToFirst()) {
            int status = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_STATUS));
            if (DownloadManager.STATUS_SUCCESSFUL == status) {
                return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, id);
            }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    // downloaded file not found or its status is not 'successfully completed'
    return null;
}
Body of Second Method:
{
    // to check if the file is in cache, get its destination from the database
    Query query = new Query().setFilterById(id);
    Cursor cursor = null;
    try {
        cursor = query(query);
        if (cursor == null) {
            return null;
        }
        if (cursor.moveToFirst()) {
            int status = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_STATUS));
            if (DownloadManager.STATUS_SUCCESSFUL == status) {
                return ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);
            }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    // downloaded file not found or its status is not 'successfully completed'
    return null;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.setBeforeText:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text before a change.
 *
 * @param beforeText The text before the change.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */

Body of Frist Method:
{
    enforceNotSealed();
    mBeforeText = beforeText;
}
Body of Second Method:
{
    enforceNotSealed();
    mBeforeText = (beforeText == null) ? null : beforeText.subSequence(0, beforeText.length());
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setMasterMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setMasterMute(mute, flags, getContext().getOpPackageName(), UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.setMasterMute(mute, flags, getContext().getOpPackageName(), UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.ClipDescription.toShortString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    boolean first = !toShortStringTypesOnly(b);
    if (mLabel != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append('"');
        b.append(mLabel);
        b.append('"');
    }
    if (mExtras != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append(mExtras.toString());
    }
    return !first;
}
Body of Second Method:
{
    boolean first = !toShortStringTypesOnly(b);
    if (mLabel != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append('"');
        b.append(mLabel);
        b.append('"');
    }
    if (mExtras != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append(mExtras.toString());
    }
    if (mTimeStamp > 0) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append('<');
        b.append(TimeUtils.logTimeOfDay(mTimeStamp));
        b.append('>');
    }
    return !first;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.getRoot:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the root node in the window's hierarchy.
 *
 * @return The root node.
 */

Body of Frist Method:
{
    if (mConnectionId == UNDEFINED) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mId, AccessibilityNodeInfo.ROOT_NODE_ID, true, AccessibilityNodeInfo.FLAG_PREFETCH_DESCENDANTS);
}
Body of Second Method:
{
    if (mConnectionId == UNDEFINED_WINDOW_ID) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mId, AccessibilityNodeInfo.ROOT_NODE_ID, true, AccessibilityNodeInfo.FLAG_PREFETCH_DESCENDANTS, null);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.startTrackingWifiChange:COMMENT
<android.net.wifi.WifiScanner: void startTrackingWifiChange(WifiChangeListener)>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * track changes in wifi environment
 * @param listener object to report events on; this object must be unique and must also be
 * provided on {@link #stopTrackingWifiChange}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = addListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    mAsyncChannel.sendMessage(CMD_START_TRACKING_CHANGE, 0, key);
}
Body of Second Method:
{
    throw new UnsupportedOperationException();
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbPort.roleCombinationsToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    StringBuilder result = new StringBuilder();
    result.append("[");
    boolean first = true;
    while (combo != 0) {
        final int index = Integer.numberOfTrailingZeros(combo);
        combo &= ~(1 << index);
        final int powerRole = index / NUM_DATA_ROLES;
        final int dataRole = index % NUM_DATA_ROLES;
        if (first) {
            first = false;
        } else {
            result.append(", ");
        }
        result.append(powerRoleToString(powerRole));
        result.append(':');
        result.append(dataRoleToString(dataRole));
    }
    result.append("]");
    return result.toString();
}
Body of Second Method:
{
    StringBuilder result = new StringBuilder();
    result.append("[");
    boolean first = true;
    while (combo != 0) {
        final int index = Integer.numberOfTrailingZeros(combo);
        combo &= ~(1 << index);
        final int powerRole = (index / NUM_DATA_ROLES + POWER_ROLE_OFFSET);
        final int dataRole = index % NUM_DATA_ROLES;
        if (first) {
            first = false;
        } else {
            result.append(", ");
        }
        result.append(powerRoleToString(powerRole));
        result.append(':');
        result.append(dataRoleToString(dataRole));
    }
    result.append("]");
    return result.toString();
}
------------------------
Find a silently evolved API code:android.app.ApplicationErrorReport.CrashInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Save a CrashInfo instance to a parcel.
 */

Body of Frist Method:
{
    int start = dest.dataPosition();
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
    int total = dest.dataPosition() - start;
    if (total > 20 * 1024) {
        Slog.d("Error", "ERR: exClass=" + exceptionClassName);
        Slog.d("Error", "ERR: exMsg=" + exceptionMessage);
        Slog.d("Error", "ERR: file=" + throwFileName);
        Slog.d("Error", "ERR: class=" + throwClassName);
        Slog.d("Error", "ERR: method=" + throwMethodName + " line=" + throwLineNumber);
        Slog.d("Error", "ERR: stack=" + stackTrace);
        Slog.d("Error", "ERR: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
Body of Second Method:
{
    int start = dest.dataPosition();
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
    int total = dest.dataPosition() - start;
    if (Binder.CHECK_PARCEL_SIZE && total > 20 * 1024) {
        Slog.d("Error", "ERR: exClass=" + exceptionClassName);
        Slog.d("Error", "ERR: exMsg=" + exceptionMessage);
        Slog.d("Error", "ERR: file=" + throwFileName);
        Slog.d("Error", "ERR: class=" + throwClassName);
        Slog.d("Error", "ERR: method=" + throwMethodName + " line=" + throwLineNumber);
        Slog.d("Error", "ERR: stack=" + stackTrace);
        Slog.d("Error", "ERR: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.getChild:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the child window at a given index.
 *
 * @param index The index.
 * @return The child.
 */

Body of Frist Method:
{
    if (mChildIds == null) {
        throw new IndexOutOfBoundsException();
    }
    if (mConnectionId == UNDEFINED) {
        return null;
    }
    final int childId = (int) mChildIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.getWindow(mConnectionId, childId);
}
Body of Second Method:
{
    if (mChildIds == null) {
        throw new IndexOutOfBoundsException();
    }
    if (mConnectionId == UNDEFINED_WINDOW_ID) {
        return null;
    }
    final int childId = (int) mChildIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.getWindow(mConnectionId, childId);
}
------------------------
Find a silently evolved API code:android.content.SyncRequest.Builder.setRequiresCharging:COMMENT
Method Modifier: public      
Comment:/**
 * Specify whether the sync requires the phone to be plugged in.
 * @param requiresCharging true if sync requires the phone to be plugged in. Default false.
 */

Body of Frist Method:
{
    mRequiresCharging = true;
    return this;
}
Body of Second Method:
{
    mRequiresCharging = requiresCharging;
    return this;
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivityFromAppTask:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Special version!
 * @hide
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
        int result = appTask.startActivity(whoThread.asBinder(), who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return;
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                ActivityResult result = null;
                if (am.ignoreMatchingSpecificIntents()) {
                    result = am.onStartActivity(intent);
                }
                if (result != null) {
                    am.mHits++;
                    return;
                } else if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
        int result = appTask.startActivity(whoThread.asBinder(), who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return;
}
------------------------
Find a silently evolved API code:android.content.ClipboardManager.hasText:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */

Body of Frist Method:
{
    try {
        return getService().hasClipboardText(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return mService.hasClipboardText(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteDatabase.insertWithOnConflict:COMMENT
Method Modifier: public      
Comment:/**
 * General method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.
 * SQL doesn't allow inserting a completely empty row without
 * naming at least one column name.  If your provided <code>initialValues</code> is
 * empty, no column names are known and an empty row can't be inserted.
 * If not set to null, the <code>nullColumnHack</code> parameter
 * provides the name of nullable column name to explicitly insert a NULL into
 * in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row OR <code>-1</code> if either the
 * input parameter <code>conflictAlgorithm</code> = {@link #CONFLICT_IGNORE}
 * or an error occurred.
 */

Body of Frist Method:
{
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder();
        sql.append("INSERT");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append(" INTO ");
        sql.append(table);
        sql.append('(');
        Object[] bindArgs = null;
        int size = (initialValues != null && initialValues.size() > 0) ? initialValues.size() : 0;
        if (size > 0) {
            bindArgs = new Object[size];
            int i = 0;
            for (String colName : initialValues.keySet()) {
                sql.append((i > 0) ? "," : "");
                sql.append(colName);
                bindArgs[i++] = initialValues.get(colName);
            }
            sql.append(')');
            sql.append(" VALUES (");
            for (i = 0; i < size; i++) {
                sql.append((i > 0) ? ",?" : "?");
            }
        } else {
            sql.append(nullColumnHack + ") VALUES (NULL");
        }
        sql.append(')');
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeInsert();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}
Body of Second Method:
{
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder();
        sql.append("INSERT");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append(" INTO ");
        sql.append(table);
        sql.append('(');
        Object[] bindArgs = null;
        int size = (initialValues != null && !initialValues.isEmpty()) ? initialValues.size() : 0;
        if (size > 0) {
            bindArgs = new Object[size];
            int i = 0;
            for (String colName : initialValues.keySet()) {
                sql.append((i > 0) ? "," : "");
                sql.append(colName);
                bindArgs[i++] = initialValues.get(colName);
            }
            sql.append(')');
            sql.append(" VALUES (");
            for (i = 0; i < size; i++) {
                sql.append((i > 0) ? ",?" : "?");
            }
        } else {
            sql.append(nullColumnHack + ") VALUES (NULL");
        }
        sql.append(')');
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeInsert();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}
------------------------
Find a silently evolved API code:android.graphics.PorterDuffColorFilter.setMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Specifies the Porter-Duff mode to use when compositing this color
 * filter's color with the source pixel at draw time.
 *
 * @see PorterDuff
 * @see #getMode()
 * @see #getColor()
 *
 * @hide
 */

Body of Frist Method:
{
    mMode = mode;
    update();
}
Body of Second Method:
{
    if (mode == null) {
        throw new IllegalArgumentException("mode must be non-null");
    }
    mMode = mode;
    discardNativeInstance();
}
------------------------
Find a silently evolved API code:android.hardware.location.ContextHubManager.getContextHubHandles:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get a handle to all the context hubs in the system
 * @return array of context hub handles
 */

Body of Frist Method:
{
    int[] retVal = null;
    try {
        retVal = getBinder().getContextHubHandles();
    } catch (RemoteException e) {
        Log.w(TAG, "Could not fetch context hub handles : " + e);
    }
    return retVal;
}
Body of Second Method:
{
    try {
        return mService.getContextHubHandles();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraCharacteristics.getKeys:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // List of keys is immutable; cache the results after we calculate them
    if (mKeys != null) {
        return mKeys;
    }
    int[] filterTags = get(REQUEST_AVAILABLE_CHARACTERISTICS_KEYS);
    if (filterTags == null) {
        throw new AssertionError("android.request.availableCharacteristicsKeys must be non-null" + " in the characteristics");
    }
    mKeys = Collections.unmodifiableList(getKeysStatic(getClass(), getKeyClass(), this, filterTags));
    return mKeys;
}
Body of Second Method:
{
    // List of keys is immutable; cache the results after we calculate them
    if (mKeys != null) {
        return mKeys;
    }
    int[] filterTags = get(REQUEST_AVAILABLE_CHARACTERISTICS_KEYS);
    if (filterTags == null) {
        throw new AssertionError("android.request.availableCharacteristicsKeys must be non-null" + " in the characteristics");
    }
    mKeys = Collections.unmodifiableList(getKeys(getClass(), getKeyClass(), this, filterTags));
    return mKeys;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.registerAudioPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Register the given {@link AudioPolicy}.
 * This call is synchronous and blocks until the registration process successfully completed
 * or failed to complete.
 * @param policy the non-null {@link AudioPolicy} to register.
 * @return {@link #ERROR} if there was an error communicating with the registration service
 * or if the user doesn't have the required
 * {@link android.Manifest.permission#MODIFY_AUDIO_ROUTING} permission,
 * {@link #SUCCESS} otherwise.
 */

Body of Frist Method:
{
    if (policy == null) {
        throw new IllegalArgumentException("Illegal null AudioPolicy argument");
    }
    IAudioService service = getService();
    try {
        String regId = service.registerAudioPolicy(policy.getConfig(), policy.cb(), policy.hasFocusListener());
        if (regId == null) {
            return ERROR;
        } else {
            policy.setRegistration(regId);
        }
    // successful registration
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return SUCCESS;
}
Body of Second Method:
{
    if (policy == null) {
        throw new IllegalArgumentException("Illegal null AudioPolicy argument");
    }
    final IAudioService service = getService();
    try {
        String regId = service.registerAudioPolicy(policy.getConfig(), policy.cb(), policy.hasFocusListener(), policy.isFocusPolicy());
        if (regId == null) {
            return ERROR;
        } else {
            policy.setRegistration(regId);
        }
    // successful registration
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return SUCCESS;
}
------------------------
Find a silently evolved API code:android.text.StaticLayout.Builder.obtain:COMMENT
Method Modifier: public      static      
Comment:/**
 * Obtain a builder for constructing StaticLayout objects
 *
 * @param source The text to be laid out, optionally with spans
 * @param start The index of the start of the text
 * @param end The index + 1 of the end of the text
 * @param paint The base paint used for layout
 * @param width The width in pixels
 * @return a builder object used for constructing the StaticLayout
 */

Body of Frist Method:
{
    Builder b = sPool.acquire();
    if (b == null) {
        b = new Builder();
    }
    // set default initial values
    b.mText = source;
    b.mStart = start;
    b.mEnd = end;
    b.mPaint = paint;
    b.mWidth = width;
    b.mAlignment = Alignment.ALIGN_NORMAL;
    b.mTextDir = TextDirectionHeuristics.FIRSTSTRONG_LTR;
    b.mSpacingMult = 1.0f;
    b.mSpacingAdd = 0.0f;
    b.mIncludePad = true;
    b.mEllipsizedWidth = width;
    b.mEllipsize = null;
    b.mMaxLines = Integer.MAX_VALUE;
    b.mBreakStrategy = Layout.BREAK_STRATEGY_SIMPLE;
    b.mHyphenationFrequency = Layout.HYPHENATION_FREQUENCY_NONE;
    b.mMeasuredText = MeasuredText.obtain();
    return b;
}
Body of Second Method:
{
    Builder b = sPool.acquire();
    if (b == null) {
        b = new Builder();
    }
    // set default initial values
    b.mText = source;
    b.mStart = start;
    b.mEnd = end;
    b.mPaint = paint;
    b.mWidth = width;
    b.mAlignment = Alignment.ALIGN_NORMAL;
    b.mTextDir = TextDirectionHeuristics.FIRSTSTRONG_LTR;
    b.mSpacingMult = 1.0f;
    b.mSpacingAdd = 0.0f;
    b.mIncludePad = true;
    b.mEllipsizedWidth = width;
    b.mEllipsize = null;
    b.mMaxLines = Integer.MAX_VALUE;
    b.mBreakStrategy = Layout.BREAK_STRATEGY_SIMPLE;
    b.mHyphenationFrequency = Layout.HYPHENATION_FREQUENCY_NONE;
    b.mJustificationMode = Layout.JUSTIFICATION_MODE_NONE;
    b.mMeasuredText = MeasuredText.obtain();
    return b;
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.checkStartActivityResult:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (res >= ActivityManager.START_SUCCESS) {
        return;
    }
    switch(res) {
        case ActivityManager.START_INTENT_NOT_RESOLVED:
        case ActivityManager.START_CLASS_NOT_FOUND:
            if (intent instanceof Intent && ((Intent) intent).getComponent() != null)
                throw new ActivityNotFoundException("Unable to find explicit activity class " + ((Intent) intent).getComponent().toShortString() + "; have you declared this activity in your AndroidManifest.xml?");
            throw new ActivityNotFoundException("No Activity found to handle " + intent);
        case ActivityManager.START_PERMISSION_DENIED:
            throw new SecurityException("Not allowed to start activity " + intent);
        case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
            throw new AndroidRuntimeException("FORWARD_RESULT_FLAG used while also requesting a result");
        case ActivityManager.START_NOT_ACTIVITY:
            throw new IllegalArgumentException("PendingIntent is not an activity");
        case ActivityManager.START_NOT_VOICE_COMPATIBLE:
            throw new SecurityException("Starting under voice control not allowed for: " + intent);
        case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:
            throw new IllegalStateException("Session calling startVoiceActivity does not match active session");
        case ActivityManager.START_VOICE_HIDDEN_SESSION:
            throw new IllegalStateException("Cannot start voice activity on a hidden session");
        case ActivityManager.START_CANCELED:
            throw new AndroidRuntimeException("Activity could not be started for " + intent);
        default:
            throw new AndroidRuntimeException("Unknown error code " + res + " when starting " + intent);
    }
}
Body of Second Method:
{
    if (!ActivityManager.isStartResultFatalError(res)) {
        return;
    }
    switch(res) {
        case ActivityManager.START_INTENT_NOT_RESOLVED:
        case ActivityManager.START_CLASS_NOT_FOUND:
            if (intent instanceof Intent && ((Intent) intent).getComponent() != null)
                throw new ActivityNotFoundException("Unable to find explicit activity class " + ((Intent) intent).getComponent().toShortString() + "; have you declared this activity in your AndroidManifest.xml?");
            throw new ActivityNotFoundException("No Activity found to handle " + intent);
        case ActivityManager.START_PERMISSION_DENIED:
            throw new SecurityException("Not allowed to start activity " + intent);
        case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
            throw new AndroidRuntimeException("FORWARD_RESULT_FLAG used while also requesting a result");
        case ActivityManager.START_NOT_ACTIVITY:
            throw new IllegalArgumentException("PendingIntent is not an activity");
        case ActivityManager.START_NOT_VOICE_COMPATIBLE:
            throw new SecurityException("Starting under voice control not allowed for: " + intent);
        case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:
            throw new IllegalStateException("Session calling startVoiceActivity does not match active session");
        case ActivityManager.START_VOICE_HIDDEN_SESSION:
            throw new IllegalStateException("Cannot start voice activity on a hidden session");
        case ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION:
            throw new IllegalStateException("Session calling startAssistantActivity does not match active session");
        case ActivityManager.START_ASSISTANT_HIDDEN_SESSION:
            throw new IllegalStateException("Cannot start assistant activity on a hidden session");
        case ActivityManager.START_CANCELED:
            throw new AndroidRuntimeException("Activity could not be started for " + intent);
        default:
            throw new AndroidRuntimeException("Unknown error code " + res + " when starting " + intent);
    }
}
------------------------
Find a silently evolved API code:android.text.BidiFormatter.DirectionalityEstimator.dirTypeBackward:COMMENT
Method Modifier: default     
Comment:/**
 * Returns the Character.DIRECTIONALITY_... value of the preceding codepoint and advances
 * charIndex backwards. If isHtml, and the codepoint is the end of a complete HTML tag or
 * entity, advances over the whole tag/entity and returns
 * Character.DIRECTIONALITY_WHITESPACE. For an entity, it would be best to figure out the
 * actual character, and return its dirtype, but treating it as whitespace is good enough
 * for our purposes.
 *
 * @throws java.lang.IndexOutOfBoundsException if called when charIndex > length or <= 0.
 */

Body of Frist Method:
{
    lastChar = text.charAt(charIndex - 1);
    if (Character.isLowSurrogate(lastChar)) {
        int codePoint = Character.codePointBefore(text, charIndex);
        charIndex -= Character.charCount(codePoint);
        return Character.getDirectionality(codePoint);
    }
    charIndex--;
    byte dirType = getCachedDirectionality(lastChar);
    if (isHtml) {
        // Process tags and entities.
        if (lastChar == '>') {
            dirType = skipTagBackward();
        } else if (lastChar == ';') {
            dirType = skipEntityBackward();
        }
    }
    return dirType;
}
Body of Second Method:
{
    lastChar = text.charAt(charIndex - 1);
    if (Character.isLowSurrogate(lastChar)) {
        int codePoint = Character.codePointBefore(text, charIndex);
        charIndex -= Character.charCount(codePoint);
        return getDirectionality(codePoint);
    }
    charIndex--;
    byte dirType = getCachedDirectionality(lastChar);
    if (isHtml) {
        // Process tags and entities.
        if (lastChar == '>') {
            dirType = skipTagBackward();
        } else if (lastChar == ';') {
            dirType = skipEntityBackward();
        }
    }
    return dirType;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.reconfigure:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Modifies the bitmap to have a specified width, height, and {@link
 * Config}, without affecting the underlying allocation backing the bitmap.
 * Bitmap pixel data is not re-initialized for the new configuration.</p>
 *
 * <p>This method can be used to avoid allocating a new bitmap, instead
 * reusing an existing bitmap's allocation for a new configuration of equal
 * or lesser size. If the Bitmap's allocation isn't large enough to support
 * the new configuration, an IllegalArgumentException will be thrown and the
 * bitmap will not be modified.</p>
 *
 * <p>The result of {@link #getByteCount()} will reflect the new configuration,
 * while {@link #getAllocationByteCount()} will reflect that of the initial
 * configuration.</p>
 *
 * <p>Note: This may change this result of hasAlpha(). When converting to 565,
 * the new bitmap will always be considered opaque. When converting from 565,
 * the new bitmap will be considered non-opaque, and will respect the value
 * set by setPremultiplied().</p>
 *
 * <p>WARNING: This method should NOT be called on a bitmap currently in use
 * by the view system, Canvas, or the AndroidBitmap NDK API. It does not
 * make guarantees about how the underlying pixel buffer is remapped to the
 * new config, just that the allocation is reused. Additionally, the view
 * system does not account for bitmap properties being modifying during use,
 * e.g. while attached to drawables.</p>
 *
 * <p>In order to safely ensure that a Bitmap is no longer in use by the
 * View system it is necessary to wait for a draw pass to occur after
 * invalidate()'ing any view that had previously drawn the Bitmap in the last
 * draw pass due to hardware acceleration's caching of draw commands. As
 * an example, here is how this can be done for an ImageView:
 * <pre class="prettyprint">
 * ImageView myImageView = ...;
 * final Bitmap myBitmap = ...;
 * myImageView.setImageDrawable(null);
 * myImageView.post(new Runnable() {
 * public void run() {
 * // myBitmap is now no longer in use by the ImageView
 * // and can be safely reconfigured.
 * myBitmap.reconfigure(...);
 * }
 * });
 * </pre></p>
 *
 * @see #setWidth(int)
 * @see #setHeight(int)
 * @see #setConfig(Config)
 */

Body of Frist Method:
{
    checkRecycled("Can't call reconfigure() on a recycled bitmap");
    if (width <= 0 || height <= 0) {
        throw new IllegalArgumentException("width and height must be > 0");
    }
    if (!isMutable()) {
        throw new IllegalStateException("only mutable bitmaps may be reconfigured");
    }
    if (mBuffer == null) {
        throw new IllegalStateException("native-backed bitmaps may not be reconfigured");
    }
    nativeReconfigure(mNativePtr, width, height, config.nativeInt, mBuffer.length, mRequestPremultiplied);
    mWidth = width;
    mHeight = height;
}
Body of Second Method:
{
    checkRecycled("Can't call reconfigure() on a recycled bitmap");
    if (width <= 0 || height <= 0) {
        throw new IllegalArgumentException("width and height must be > 0");
    }
    if (!isMutable()) {
        throw new IllegalStateException("only mutable bitmaps may be reconfigured");
    }
    nativeReconfigure(mNativePtr, width, height, config.nativeInt, mRequestPremultiplied);
    mWidth = width;
    mHeight = height;
    mColorSpace = null;
}
------------------------
Find a silently evolved API code:android.text.StaticLayout.getHyphen:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mLines[mColumns * line + HYPHEN] & 0xff;
}
Body of Second Method:
{
    return mLines[mColumns * line + HYPHEN] & HYPHEN_MASK;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.getSaveCount:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the number of matrix/clip states on the Canvas' private stack.
 * This will equal # save() calls - # restore() calls.
 */

Body of Frist Method:
{
    return native_getSaveCount(mNativeCanvasWrapper);
}
Body of Second Method:
{
    return nGetSaveCount(mNativeCanvasWrapper);
}
------------------------
Find a silently evolved API code:android.media.PlayerBase.baseUpdateAudioAttributes:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * To be called whenever the audio attributes of the player change
 * @param attr non-null audio attributes
 */

Body of Frist Method:
{
    if (attr == null) {
        throw new IllegalArgumentException("Illegal null AudioAttributes");
    }
    synchronized (mAppOpsLock) {
        mAttributes = attr;
        updateAppOpsPlayAudio_sync();
    }
}
Body of Second Method:
{
    if (attr == null) {
        throw new IllegalArgumentException("Illegal null AudioAttributes");
    }
    try {
        getService().playerAttributes(mPlayerIId, attr);
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, STARTED state will not be tracked", e);
    }
    synchronized (mLock) {
        mAttributes = attr;
        updateAppOpsPlayAudio_sync();
    }
}
------------------------
Find a silently evolved API code:android.service.notification.StatusBarNotification.getPackageContext:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mContext == null) {
        try {
            ApplicationInfo ai = context.getPackageManager().getApplicationInfo(pkg, PackageManager.GET_UNINSTALLED_PACKAGES);
            mContext = context.createApplicationContext(ai, Context.CONTEXT_RESTRICTED);
        } catch (PackageManager.NameNotFoundException e) {
            mContext = null;
        }
    }
    if (mContext == null) {
        mContext = context;
    }
    return mContext;
}
Body of Second Method:
{
    if (mContext == null) {
        try {
            ApplicationInfo ai = context.getPackageManager().getApplicationInfoAsUser(pkg, PackageManager.MATCH_UNINSTALLED_PACKAGES, getUserId());
            mContext = context.createApplicationContext(ai, Context.CONTEXT_RESTRICTED);
        } catch (PackageManager.NameNotFoundException e) {
            mContext = null;
        }
    }
    if (mContext == null) {
        mContext = context;
    }
    return mContext;
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.InputMethodImpl.bindInput:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a new input binding, calling
 * {@link InputMethodService#onBindInput InputMethodService.onBindInput()}
 * when done.
 */

Body of Frist Method:
{
    mInputBinding = binding;
    mInputConnection = binding.getConnection();
    if (DEBUG)
        Log.v(TAG, "bindInput(): binding=" + binding + " ic=" + mInputConnection);
    InputConnection ic = getCurrentInputConnection();
    if (ic != null)
        ic.reportFullscreenMode(mIsFullscreen);
    initialize();
    onBindInput();
}
Body of Second Method:
{
    mInputBinding = binding;
    mInputConnection = binding.getConnection();
    if (DEBUG)
        Log.v(TAG, "bindInput(): binding=" + binding + " ic=" + mInputConnection);
    if (mImm != null && mToken != null) {
        mImm.reportFullscreenMode(mToken, mIsFullscreen);
    }
    initialize();
    onBindInput();
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.endAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Called internally to end an animation by removing it from the animations list. Must be
 * called on the UI thread.
 */

Body of Frist Method:
{
    if (mAnimationEndRequested) {
        return;
    }
    AnimationHandler handler = AnimationHandler.getInstance();
    handler.removeCallback(this);
    mAnimationEndRequested = true;
    mPaused = false;
    if ((mStarted || mRunning) && mListeners != null) {
        if (!mRunning) {
            // If it's not yet running, then start listeners weren't called. Call them now.
            notifyStartListeners();
        }
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        int numListeners = tmpListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            tmpListeners.get(i).onAnimationEnd(this);
        }
    }
    mRunning = false;
    mStarted = false;
    mStartListenersCalled = false;
    mReversing = false;
    mLastFrameTime = 0;
    if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
        Trace.asyncTraceEnd(Trace.TRACE_TAG_VIEW, getNameForTrace(), System.identityHashCode(this));
    }
}
Body of Second Method:
{
    if (mAnimationEndRequested) {
        return;
    }
    removeAnimationCallback();
    mAnimationEndRequested = true;
    mPaused = false;
    boolean notify = (mStarted || mRunning) && mListeners != null;
    if (notify && !mRunning) {
        // If it's not yet running, then start listeners weren't called. Call them now.
        notifyStartListeners();
    }
    mRunning = false;
    mStarted = false;
    mStartListenersCalled = false;
    mLastFrameTime = -1;
    mFirstFrameTime = -1;
    mStartTime = -1;
    if (notify && mListeners != null) {
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        int numListeners = tmpListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            tmpListeners.get(i).onAnimationEnd(this, mReversing);
        }
    }
    // mReversing needs to be reset *after* notifying the listeners for the end callbacks.
    mReversing = false;
    if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
        Trace.asyncTraceEnd(Trace.TRACE_TAG_VIEW, getNameForTrace(), System.identityHashCode(this));
    }
}
------------------------
Find a silently evolved API code:android.text.TextLine.handleRun:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Utility function for handling a unidirectional run.  The run must not
 * contain tabs but can contain styles.
 *
 * @param start the line-relative start of the run
 * @param measureLimit the offset to measure to, between start and limit inclusive
 * @param limit the limit of the run
 * @param runIsRtl true if the run is right-to-left
 * @param c the canvas, can be null
 * @param x the end of the run closest to the leading margin
 * @param top the top of the line
 * @param y the baseline
 * @param bottom the bottom of the line
 * @param fmi receives metrics information, can be null
 * @param needWidth true if the width is required
 * @return the signed width of the run based on the run direction; only
 * valid if needWidth is true
 */

Body of Frist Method:
{
    // Case of an empty line, make sure we update fmi according to mPaint
    if (start == measureLimit) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        if (fmi != null) {
            expandMetricsFromPaint(fmi, wp);
        }
        return 0f;
    }
    if (mSpanned == null) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        final int mlimit = measureLimit;
        return handleText(wp, start, limit, start, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit, mlimit);
    }
    mMetricAffectingSpanSpanSet.init(mSpanned, mStart + start, mStart + limit);
    mCharacterStyleSpanSet.init(mSpanned, mStart + start, mStart + limit);
    // Shaping needs to take into account context up to metric boundaries,
    // but rendering needs to take into account character style boundaries.
    // So we iterate through metric runs to get metric bounds,
    // then within each metric run iterate through character style runs
    // for the run bounds.
    final float originalX = x;
    for (int i = start, inext; i < measureLimit; i = inext) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        inext = mMetricAffectingSpanSpanSet.getNextTransition(mStart + i, mStart + limit) - mStart;
        int mlimit = Math.min(inext, measureLimit);
        ReplacementSpan replacement = null;
        for (int j = 0; j < mMetricAffectingSpanSpanSet.numberOfSpans; j++) {
            // empty by construction. This special case in getSpans() explains the >= & <= tests
            if ((mMetricAffectingSpanSpanSet.spanStarts[j] >= mStart + mlimit) || (mMetricAffectingSpanSpanSet.spanEnds[j] <= mStart + i))
                continue;
            MetricAffectingSpan span = mMetricAffectingSpanSpanSet.spans[j];
            if (span instanceof ReplacementSpan) {
                replacement = (ReplacementSpan) span;
            } else {
                // We might have a replacement that uses the draw
                // state, otherwise measure state would suffice.
                span.updateDrawState(wp);
            }
        }
        if (replacement != null) {
            x += handleReplacement(replacement, wp, i, mlimit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
            continue;
        }
        for (int j = i, jnext; j < mlimit; j = jnext) {
            jnext = mCharacterStyleSpanSet.getNextTransition(mStart + j, mStart + inext) - mStart;
            int offset = Math.min(jnext, mlimit);
            wp.set(mPaint);
            for (int k = 0; k < mCharacterStyleSpanSet.numberOfSpans; k++) {
                // Intentionally using >= and <= as explained above
                if ((mCharacterStyleSpanSet.spanStarts[k] >= mStart + offset) || (mCharacterStyleSpanSet.spanEnds[k] <= mStart + j))
                    continue;
                CharacterStyle span = mCharacterStyleSpanSet.spans[k];
                span.updateDrawState(wp);
            }
            // Only draw hyphen on last run in line
            if (jnext < mLen) {
                wp.setHyphenEdit(0);
            }
            x += handleText(wp, j, jnext, i, inext, runIsRtl, c, x, top, y, bottom, fmi, needWidth || jnext < measureLimit, offset);
        }
    }
    return x - originalX;
}
Body of Second Method:
{
    if (measureLimit < start || measureLimit > limit) {
        throw new IndexOutOfBoundsException("measureLimit (" + measureLimit + ") is out of " + "start (" + start + ") and limit (" + limit + ") bounds");
    }
    // Case of an empty line, make sure we update fmi according to mPaint
    if (start == measureLimit) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        if (fmi != null) {
            expandMetricsFromPaint(fmi, wp);
        }
        return 0f;
    }
    if (mSpanned == null) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        wp.setHyphenEdit(adjustHyphenEdit(start, limit, wp.getHyphenEdit()));
        return handleText(wp, start, limit, start, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth, measureLimit);
    }
    mMetricAffectingSpanSpanSet.init(mSpanned, mStart + start, mStart + limit);
    mCharacterStyleSpanSet.init(mSpanned, mStart + start, mStart + limit);
    // Shaping needs to take into account context up to metric boundaries,
    // but rendering needs to take into account character style boundaries.
    // So we iterate through metric runs to get metric bounds,
    // then within each metric run iterate through character style runs
    // for the run bounds.
    final float originalX = x;
    for (int i = start, inext; i < measureLimit; i = inext) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        inext = mMetricAffectingSpanSpanSet.getNextTransition(mStart + i, mStart + limit) - mStart;
        int mlimit = Math.min(inext, measureLimit);
        ReplacementSpan replacement = null;
        for (int j = 0; j < mMetricAffectingSpanSpanSet.numberOfSpans; j++) {
            // empty by construction. This special case in getSpans() explains the >= & <= tests
            if ((mMetricAffectingSpanSpanSet.spanStarts[j] >= mStart + mlimit) || (mMetricAffectingSpanSpanSet.spanEnds[j] <= mStart + i))
                continue;
            MetricAffectingSpan span = mMetricAffectingSpanSpanSet.spans[j];
            if (span instanceof ReplacementSpan) {
                replacement = (ReplacementSpan) span;
            } else {
                // We might have a replacement that uses the draw
                // state, otherwise measure state would suffice.
                span.updateDrawState(wp);
            }
        }
        if (replacement != null) {
            x += handleReplacement(replacement, wp, i, mlimit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
            continue;
        }
        for (int j = i, jnext; j < mlimit; j = jnext) {
            jnext = mCharacterStyleSpanSet.getNextTransition(mStart + j, mStart + inext) - mStart;
            int offset = Math.min(jnext, mlimit);
            wp.set(mPaint);
            for (int k = 0; k < mCharacterStyleSpanSet.numberOfSpans; k++) {
                // Intentionally using >= and <= as explained above
                if ((mCharacterStyleSpanSet.spanStarts[k] >= mStart + offset) || (mCharacterStyleSpanSet.spanEnds[k] <= mStart + j))
                    continue;
                CharacterStyle span = mCharacterStyleSpanSet.spans[k];
                span.updateDrawState(wp);
            }
            wp.setHyphenEdit(adjustHyphenEdit(j, jnext, wp.getHyphenEdit()));
            x += handleText(wp, j, jnext, i, inext, runIsRtl, c, x, top, y, bottom, fmi, needWidth || jnext < measureLimit, offset);
        }
    }
    return x - originalX;
}
------------------------
Find a silently evolved API code:android.content.ClipData.Item.coerceToText:COMMENT
Method Modifier: public      
Comment:// BEGIN_INCLUDE(coerceToText)

Body of Frist Method:
{
    // If this Item has an explicit textual value, simply return that.
    CharSequence text = getText();
    if (text != null) {
        return text;
    }
    // If this Item has a URI value, try using that.
    Uri uri = getUri();
    if (uri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        FileInputStream stream = null;
        try {
            // Ask for a stream of the desired type.
            AssetFileDescriptor descr = context.getContentResolver().openTypedAssetFileDescriptor(uri, "text/*", null);
            stream = descr.createInputStream();
            InputStreamReader reader = new InputStreamReader(stream, "UTF-8");
            // Got it...  copy the stream into a local string and return it.
            StringBuilder builder = new StringBuilder(128);
            char[] buffer = new char[8192];
            int len;
            while ((len = reader.read(buffer)) > 0) {
                builder.append(buffer, 0, len);
            }
            return builder.toString();
        } catch (FileNotFoundException e) {
        // Unable to open content URI as text...  not really an
        // error, just something to ignore.
        } catch (IOException e) {
            // Something bad has happened.
            Log.w("ClipData", "Failure loading text", e);
            return e.toString();
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        // probably serves fairly well as a textual representation.
        return uri.toString();
    }
    // Finally, if all we have is an Intent, then we can just turn that
    // into text.  Not the most user-friendly thing, but it's something.
    Intent intent = getIntent();
    if (intent != null) {
        return intent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return "";
}
Body of Second Method:
{
    // If this Item has an explicit textual value, simply return that.
    CharSequence text = getText();
    if (text != null) {
        return text;
    }
    // If this Item has a URI value, try using that.
    Uri uri = getUri();
    if (uri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        FileInputStream stream = null;
        try {
            // Ask for a stream of the desired type.
            AssetFileDescriptor descr = context.getContentResolver().openTypedAssetFileDescriptor(uri, "text/*", null);
            stream = descr.createInputStream();
            InputStreamReader reader = new InputStreamReader(stream, "UTF-8");
            // Got it...  copy the stream into a local string and return it.
            StringBuilder builder = new StringBuilder(128);
            char[] buffer = new char[8192];
            int len;
            while ((len = reader.read(buffer)) > 0) {
                builder.append(buffer, 0, len);
            }
            return builder.toString();
        } catch (SecurityException e) {
            Log.w("ClipData", "Failure opening stream", e);
        } catch (FileNotFoundException e) {
        // Unable to open content URI as text...  not really an
        // error, just something to ignore.
        } catch (IOException e) {
            // Something bad has happened.
            Log.w("ClipData", "Failure loading text", e);
            return e.toString();
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        // If we couldn't open the URI as a stream, use the URI itself as a textual
        // representation (but not for "content", "android.resource" or "file" schemes).
        final String scheme = uri.getScheme();
        if (SCHEME_CONTENT.equals(scheme) || SCHEME_ANDROID_RESOURCE.equals(scheme) || SCHEME_FILE.equals(scheme)) {
            return "";
        }
        return uri.toString();
    }
    // Finally, if all we have is an Intent, then we can just turn that
    // into text.  Not the most user-friendly thing, but it's something.
    Intent intent = getIntent();
    if (intent != null) {
        return intent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return "";
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbDevice.setConfigurations:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Only used by UsbService implementation
 * @hide
 */

Body of Frist Method:
{
    mConfigurations = configuration;
}
Body of Second Method:
{
    mConfigurations = Preconditions.checkArrayElementsNotNull(configuration, "configuration");
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setSimOperatorNumeric:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC for the default phone.
 *
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    setSimOperatorNumericForPhone(phoneId, numeric);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    setSimOperatorNumericForPhone(phoneId, numeric);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getSubjectMatch:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Get subject match (deprecated)
 * @return the subject match string
 * @deprecated in favor of altSubjectMatch
 */

Body of Frist Method:
{
    return getFieldValue(SUBJECT_MATCH_KEY, "");
}
Body of Second Method:
{
    return getFieldValue(SUBJECT_MATCH_KEY);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.InsetDrawable.InsetState.applyDensityScaling:COMMENT
Method Modifier: private     
Comment:/**
 * Called when the constant state density changes to scale
 * density-dependent properties specific to insets.
 *
 * @param sourceDensity the previous constant state density
 * @param targetDensity the new constant state density
 */

Body of Frist Method:
{
    mInsetLeft = Bitmap.scaleFromDensity(mInsetLeft, sourceDensity, targetDensity);
    mInsetTop = Bitmap.scaleFromDensity(mInsetTop, sourceDensity, targetDensity);
    mInsetRight = Bitmap.scaleFromDensity(mInsetRight, sourceDensity, targetDensity);
    mInsetBottom = Bitmap.scaleFromDensity(mInsetBottom, sourceDensity, targetDensity);
}
Body of Second Method:
{
    mInsetLeft.scaleFromDensity(sourceDensity, targetDensity);
    mInsetTop.scaleFromDensity(sourceDensity, targetDensity);
    mInsetRight.scaleFromDensity(sourceDensity, targetDensity);
    mInsetBottom.scaleFromDensity(sourceDensity, targetDensity);
}
------------------------
Find a silently evolved API code:android.service.quicksettings.TileService.requestListeningState:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Requests that a tile be put in the listening state so it can send an update.
 *
 * This method is only applicable to tiles that have {@link #META_DATA_ACTIVE_TILE} defined
 * as true on their TileService Manifest declaration, and will do nothing otherwise.
 */

Body of Frist Method:
{
    Intent intent = new Intent(ACTION_REQUEST_LISTENING);
    intent.putExtra(EXTRA_COMPONENT, component);
    context.sendBroadcast(intent, Manifest.permission.BIND_QUICK_SETTINGS_TILE);
}
Body of Second Method:
{
    Intent intent = new Intent(ACTION_REQUEST_LISTENING);
    intent.putExtra(Intent.EXTRA_COMPONENT_NAME, component);
    intent.setPackage("com.android.systemui");
    context.sendBroadcast(intent, Manifest.permission.BIND_QUICK_SETTINGS_TILE);
}
------------------------
Find a silently evolved API code:android.graphics.Path.toggleInverseFillType:COMMENT
Method Modifier: public      
Comment:/**
 * Toggles the INVERSE state of the filltype
 */

Body of Frist Method:
{
    int ft = native_getFillType(mNativePath);
    ft ^= FillType.INVERSE_WINDING.nativeInt;
    native_setFillType(mNativePath, ft);
}
Body of Second Method:
{
    int ft = nGetFillType(mNativePath);
    ft ^= FillType.INVERSE_WINDING.nativeInt;
    nSetFillType(mNativePath, ft);
}
------------------------
Find a silently evolved API code:android.preference.Preference.callChangeListener:COMMENT
Method Modifier: protected   
Comment:/**
 * Call this method after the user changes the preference, but before the
 * internal state is set. This allows the client to ignore the user value.
 *
 * @param newValue The new value of this Preference.
 * @return True if the user value should be set as the preference
 * value (and persisted).
 */

Body of Frist Method:
{
    return mOnChangeListener == null ? true : mOnChangeListener.onPreferenceChange(this, newValue);
}
Body of Second Method:
{
    return mOnChangeListener == null || mOnChangeListener.onPreferenceChange(this, newValue);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setMicrophoneMute:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the microphone mute on or off.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param on set <var>true</var> to mute the microphone;
 * <var>false</var> to turn mute off
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setMicrophoneMute(on, getContext().getOpPackageName(), UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    final IAudioService service = getService();
    try {
        service.setMicrophoneMute(on, getContext().getOpPackageName(), UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfEditor.removePage:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes the page with a given index.
 *
 * @param pageIndex The page to remove.
 */

Body of Frist Method:
{
    throwIfClosed();
    throwIfPageNotInDocument(pageIndex);
    mPageCount = nativeRemovePage(mNativeDocument, pageIndex);
}
Body of Second Method:
{
    throwIfClosed();
    throwIfPageNotInDocument(pageIndex);
    synchronized (PdfRenderer.sPdfiumLock) {
        mPageCount = nativeRemovePage(mNativeDocument, pageIndex);
    }
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.queryRemoteConnectionServices:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Retrieves a list of remote connection services usable to place calls.
 */

Body of Frist Method:
{
    // Only supported when there is only one adapter.
    if (mAdapters.size() == 1) {
        try {
            mAdapters.iterator().next().queryRemoteConnectionServices(callback);
        } catch (RemoteException e) {
            Log.e(this, e, "Exception trying to query for remote CSs");
        }
    }
}
Body of Second Method:
{
    // Only supported when there is only one adapter.
    if (mAdapters.size() == 1) {
        try {
            mAdapters.iterator().next().queryRemoteConnectionServices(callback, Log.getExternalSession());
        } catch (RemoteException e) {
            Log.e(this, e, "Exception trying to query for remote CSs");
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.RadialGradient.copy:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final RadialGradient copy;
    switch(mType) {
        case TYPE_COLORS_AND_POSITIONS:
            copy = new RadialGradient(mX, mY, mRadius, mColors.clone(), mPositions != null ? mPositions.clone() : null, mTileMode);
            break;
        case TYPE_COLOR_CENTER_AND_COLOR_EDGE:
            copy = new RadialGradient(mX, mY, mRadius, mCenterColor, mEdgeColor, mTileMode);
            break;
        default:
            throw new IllegalArgumentException("RadialGradient should be created with either " + "colors and positions or center color and edge color");
    }
    copyLocalMatrix(copy);
    return copy;
}
Body of Second Method:
{
    final RadialGradient copy;
    if (mType == TYPE_COLORS_AND_POSITIONS) {
        copy = new RadialGradient(mX, mY, mRadius, mColors.clone(), mPositions != null ? mPositions.clone() : null, mTileMode);
    } else {
        // TYPE_COLOR_CENTER_AND_COLOR_EDGE
        copy = new RadialGradient(mX, mY, mRadius, mCenterColor, mEdgeColor, mTileMode);
    }
    copyLocalMatrix(copy);
    return copy;
}
------------------------
Find a silently evolved API code:android.os.StrictMode.ViolationInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Save a ViolationInfo instance to a parcel.
 */

Body of Frist Method:
{
    dest.writeString(message);
    crashInfo.writeToParcel(dest, flags);
    int start = dest.dataPosition();
    dest.writeInt(policy);
    dest.writeInt(durationMillis);
    dest.writeInt(violationNumThisLoop);
    dest.writeInt(numAnimationsRunning);
    dest.writeLong(violationUptimeMillis);
    dest.writeLong(numInstances);
    dest.writeString(broadcastIntentAction);
    dest.writeStringArray(tags);
    int total = dest.dataPosition() - start;
    if (total > 10 * 1024) {
        Slog.d(TAG, "VIO: policy=" + policy + " dur=" + durationMillis + " numLoop=" + violationNumThisLoop + " anim=" + numAnimationsRunning + " uptime=" + violationUptimeMillis + " numInst=" + numInstances);
        Slog.d(TAG, "VIO: action=" + broadcastIntentAction);
        Slog.d(TAG, "VIO: tags=" + Arrays.toString(tags));
        Slog.d(TAG, "VIO: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
Body of Second Method:
{
    dest.writeString(message);
    if (crashInfo != null) {
        dest.writeInt(1);
        crashInfo.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    int start = dest.dataPosition();
    dest.writeInt(policy);
    dest.writeInt(durationMillis);
    dest.writeInt(violationNumThisLoop);
    dest.writeInt(numAnimationsRunning);
    dest.writeLong(violationUptimeMillis);
    dest.writeLong(numInstances);
    dest.writeString(broadcastIntentAction);
    dest.writeStringArray(tags);
    int total = dest.dataPosition() - start;
    if (Binder.CHECK_PARCEL_SIZE && total > 10 * 1024) {
        Slog.d(TAG, "VIO: policy=" + policy + " dur=" + durationMillis + " numLoop=" + violationNumThisLoop + " anim=" + numAnimationsRunning + " uptime=" + violationUptimeMillis + " numInst=" + numInstances);
        Slog.d(TAG, "VIO: action=" + broadcastIntentAction);
        Slog.d(TAG, "VIO: tags=" + Arrays.toString(tags));
        Slog.d(TAG, "VIO: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfEditor.setPageMediaBox:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the media box of a given page in mils (1/72").
 *
 * @param pageIndex The page index.
 * @param mediaBox The media box.
 */

Body of Frist Method:
{
    throwIfClosed();
    throwIfMediaBoxNull(mediaBox);
    throwIfPageNotInDocument(pageIndex);
    nativeSetPageMediaBox(mNativeDocument, pageIndex, mediaBox);
}
Body of Second Method:
{
    throwIfClosed();
    throwIfMediaBoxNull(mediaBox);
    throwIfPageNotInDocument(pageIndex);
    synchronized (PdfRenderer.sPdfiumLock) {
        nativeSetPageMediaBox(mNativeDocument, pageIndex, mediaBox);
    }
}
------------------------
Find a silently evolved API code:android.util.EventLog.Event.decodeObject:COMMENT
Method Modifier: private     
Comment:/**
 * @return the loggable item at the current position in mBuffer.
 */

Body of Frist Method:
{
    byte type = mBuffer.get();
    switch(type) {
        case INT_TYPE:
            return mBuffer.getInt();
        case LONG_TYPE:
            return mBuffer.getLong();
        case FLOAT_TYPE:
            return mBuffer.getFloat();
        case STRING_TYPE:
            try {
                int length = mBuffer.getInt();
                int start = mBuffer.position();
                mBuffer.position(start + length);
                return new String(mBuffer.array(), start, length, "UTF-8");
            } catch (UnsupportedEncodingException e) {
                Log.wtf(TAG, "UTF-8 is not supported", e);
                return null;
            }
        case LIST_TYPE:
            int length = mBuffer.get();
            // treat as signed byte
            if (length < 0)
                length += 256;
            Object[] array = new Object[length];
            for (int i = 0; i < length; ++i) array[i] = decodeObject();
            return array;
        default:
            throw new IllegalArgumentException("Unknown entry type: " + type);
    }
}
Body of Second Method:
{
    byte type = mBuffer.get();
    switch(type) {
        case INT_TYPE:
            return mBuffer.getInt();
        case LONG_TYPE:
            return mBuffer.getLong();
        case FLOAT_TYPE:
            return mBuffer.getFloat();
        case STRING_TYPE:
            try {
                int length = mBuffer.getInt();
                int start = mBuffer.position();
                mBuffer.position(start + length);
                return new String(mBuffer.array(), start, length, "UTF-8");
            } catch (UnsupportedEncodingException e) {
                Log.wtf(TAG, "UTF-8 is not supported", e);
                mLastWtf = e;
                return null;
            }
        case LIST_TYPE:
            int length = mBuffer.get();
            // treat as signed byte
            if (length < 0)
                length += 256;
            Object[] array = new Object[length];
            for (int i = 0; i < length; ++i) array[i] = decodeObject();
            return array;
        default:
            throw new IllegalArgumentException("Unknown entry type: " + type);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawPoint:COMMENT
Method Modifier: public      
Comment:/**
 * Helper for drawPoints() for drawing a single point.
 */

Body of Frist Method:
{
    native_drawPoint(mNativeCanvasWrapper, x, y, paint.getNativeInstance());
}
Body of Second Method:
{
    super.drawPoint(x, y, paint);
}
------------------------
Find a silently evolved API code:android.content.pm.ApplicationInfo.initForUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    uid = UserHandle.getUid(userId, UserHandle.getAppId(uid));
    if ("android".equals(packageName)) {
        dataDir = Environment.getDataSystemDirectory().getAbsolutePath();
        return;
    }
    deviceEncryptedDataDir = deviceProtectedDataDir = Environment.getDataUserDePackageDirectory(volumeUuid, userId, packageName).getAbsolutePath();
    credentialEncryptedDataDir = credentialProtectedDataDir = Environment.getDataUserCePackageDirectory(volumeUuid, userId, packageName).getAbsolutePath();
    if ((privateFlags & PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE) != 0 && PackageManager.APPLY_DEFAULT_TO_DEVICE_PROTECTED_STORAGE) {
        dataDir = deviceProtectedDataDir;
    } else {
        dataDir = credentialProtectedDataDir;
    }
}
Body of Second Method:
{
    uid = UserHandle.getUid(userId, UserHandle.getAppId(uid));
    if ("android".equals(packageName)) {
        dataDir = Environment.getDataSystemDirectory().getAbsolutePath();
        return;
    }
    deviceProtectedDataDir = Environment.getDataUserDePackageDirectory(volumeUuid, userId, packageName).getAbsolutePath();
    credentialProtectedDataDir = Environment.getDataUserCePackageDirectory(volumeUuid, userId, packageName).getAbsolutePath();
    if ((privateFlags & PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE) != 0 && PackageManager.APPLY_DEFAULT_TO_DEVICE_PROTECTED_STORAGE) {
        dataDir = deviceProtectedDataDir;
    } else {
        dataDir = credentialProtectedDataDir;
    }
}
------------------------
Find a silently evolved API code:android.graphics.BidiRenderer.render:COMMENT
Method Modifier: private     
Comment:/**
 * Renders the text to the right of the bounds with the given font.
 * @param font The font to render the text with.
 */

Body of Frist Method:
{
    FontRenderContext frc;
    if (mGraphics != null) {
        frc = mGraphics.getFontRenderContext();
    } else {
        frc = Toolkit.getDefaultToolkit().getFontMetrics(font).getFontRenderContext();
        // Metrics obtained this way don't have anti-aliasing set. So,
        // we create a new FontRenderContext with anti-aliasing set.
        frc = new FontRenderContext(font.getTransform(), mPaint.isAntiAliased(), frc.usesFractionalMetrics());
    }
    GlyphVector gv = font.layoutGlyphVector(frc, mText, start, limit, flag);
    int ng = gv.getNumGlyphs();
    int[] ci = gv.getGlyphCharIndices(0, ng, null);
    if (advances != null) {
        for (int i = 0; i < ng; i++) {
            int adv_idx = advancesIndex + ci[i];
            advances[adv_idx] += gv.getGlyphMetrics(i).getAdvanceX();
        }
    }
    if (draw && mGraphics != null) {
        mGraphics.drawGlyphVector(gv, mBounds.right, mBaseline);
    }
    // Update the bounds.
    Rectangle2D awtBounds = gv.getLogicalBounds();
    RectF bounds = awtRectToAndroidRect(awtBounds, mBounds.right, mBaseline);
    // coordinates from the bounds as an offset.
    if (Math.abs(mBounds.right - mBounds.left) == 0) {
        mBounds = bounds;
    } else {
        mBounds.union(bounds);
    }
}
Body of Second Method:
{
    FontRenderContext frc;
    if (mGraphics != null) {
        frc = mGraphics.getFontRenderContext();
    } else {
        frc = Toolkit.getDefaultToolkit().getFontMetrics(font).getFontRenderContext();
        // Metrics obtained this way don't have anti-aliasing set. So,
        // we create a new FontRenderContext with anti-aliasing set.
        AffineTransform transform = font.getTransform();
        if (mPaint.isAntiAliased() && // Workaround for http://b.android.com/211659
        (transform.getScaleX() <= 9.9 || !"JetBrains s.r.o".equals(JAVA_VENDOR))) {
            frc = new FontRenderContext(transform, true, frc.usesFractionalMetrics());
        }
    }
    GlyphVector gv = font.layoutGlyphVector(frc, mText, start, limit, flag);
    int ng = gv.getNumGlyphs();
    int[] ci = gv.getGlyphCharIndices(0, ng, null);
    if (advances != null) {
        for (int i = 0; i < ng; i++) {
            int adv_idx = advancesIndex + ci[i];
            advances[adv_idx] += gv.getGlyphMetrics(i).getAdvanceX();
        }
    }
    if (draw && mGraphics != null) {
        mGraphics.drawGlyphVector(gv, mBounds.right, mBaseline);
    }
    // Update the bounds.
    Rectangle2D awtBounds = gv.getLogicalBounds();
    RectF bounds = awtRectToAndroidRect(awtBounds, mBounds.right, mBaseline);
    // coordinates from the bounds as an offset.
    if (Math.abs(mBounds.right - mBounds.left) == 0) {
        mBounds = bounds;
    } else {
        mBounds.union(bounds);
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setSimCountryIso:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY for the default phone.
 *
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    setSimCountryIsoForPhone(phoneId, iso);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    setSimCountryIsoForPhone(phoneId, iso);
}
------------------------
Find a silently evolved API code:android.net.NetworkCapabilities.transportNamesOf:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String transports = "";
    for (int i = 0; i < types.length; ) {
        switch(types[i]) {
            case TRANSPORT_CELLULAR:
                transports += "CELLULAR";
                break;
            case TRANSPORT_WIFI:
                transports += "WIFI";
                break;
            case TRANSPORT_BLUETOOTH:
                transports += "BLUETOOTH";
                break;
            case TRANSPORT_ETHERNET:
                transports += "ETHERNET";
                break;
            case TRANSPORT_VPN:
                transports += "VPN";
                break;
        }
        if (++i < types.length)
            transports += "|";
    }
    return transports;
}
Body of Second Method:
{
    if (types == null || types.length == 0) {
        return "";
    }
    StringBuilder transports = new StringBuilder();
    for (int t : types) {
        transports.append("|").append(transportNameOf(t));
    }
    return transports.substring(1);
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setNetworkOperatorName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the alphabetic name of current registered operator.
 * @param name the alphabetic name of current registered operator.
 * @hide
 */

Body of Frist Method:
{
    int phoneId = getDefaultPhone();
    setNetworkOperatorNameForPhone(phoneId, name);
}
Body of Second Method:
{
    int phoneId = getPhoneId();
    setNetworkOperatorNameForPhone(phoneId, name);
}
------------------------
Find a silently evolved API code:android.net.LocalServerSocket.accept:COMMENT
Method Modifier: public      
Comment:/**
 * Accepts a new connection to the socket. Blocks until a new
 * connection arrives.
 *
 * @return a socket representing the new connection.
 * @throws IOException
 */

Body of Frist Method:
{
    LocalSocketImpl acceptedImpl = new LocalSocketImpl();
    impl.accept(acceptedImpl);
    return new LocalSocket(acceptedImpl, LocalSocket.SOCKET_UNKNOWN);
}
Body of Second Method:
{
    LocalSocketImpl acceptedImpl = new LocalSocketImpl();
    impl.accept(acceptedImpl);
    return LocalSocket.createLocalSocketForAccept(acceptedImpl);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.disable:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Turn off the local Bluetooth adapter and don't persist the setting.
 *
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter shutdown has begun, or false on
 * immediate error
 * @hide
 */

Body of Frist Method:
{
    try {
        return mManagerService.disable(persist);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    try {
        return mManagerService.disable(ActivityThread.currentPackageName(), persist);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.ViewDebug.dumpv2:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Dumps the view hierarchy starting from the given view.
 * Rather than using reflection, it uses View's encode method to obtain all the properties.
 * @hide
 */

Body of Frist Method:
{
    final ViewHierarchyEncoder encoder = new ViewHierarchyEncoder(out);
    final CountDownLatch latch = new CountDownLatch(1);
    view.post(new Runnable() {

        @Override
        public void run() {
            view.encode(encoder);
            latch.countDown();
        }
    });
    latch.await(2, TimeUnit.SECONDS);
    encoder.endStream();
}
Body of Second Method:
{
    final ViewHierarchyEncoder encoder = new ViewHierarchyEncoder(out);
    final CountDownLatch latch = new CountDownLatch(1);
    view.post(new Runnable() {

        @Override
        public void run() {
            encoder.addProperty("window:left", view.mAttachInfo.mWindowLeft);
            encoder.addProperty("window:top", view.mAttachInfo.mWindowTop);
            view.encode(encoder);
            latch.countDown();
        }
    });
    latch.await(2, TimeUnit.SECONDS);
    encoder.endStream();
}
------------------------
Find a silently evolved API code:android.telecom.VideoProfile.videoStateToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Generates a string representation of a video state.
 *
 * @param videoState The video state.
 * @return String representation of the video state.
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("Audio");
    if (isAudioOnly(videoState)) {
        sb.append(" Only");
    } else {
        if (isTransmissionEnabled(videoState)) {
            sb.append(" Tx");
        }
        if (isReceptionEnabled(videoState)) {
            sb.append(" Rx");
        }
        if (isPaused(videoState)) {
            sb.append(" Pause");
        }
    }
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("Audio");
    if (videoState == STATE_AUDIO_ONLY) {
        sb.append(" Only");
    } else {
        if (isTransmissionEnabled(videoState)) {
            sb.append(" Tx");
        }
        if (isReceptionEnabled(videoState)) {
            sb.append(" Rx");
        }
        if (isPaused(videoState)) {
            sb.append(" Pause");
        }
    }
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getResourceId:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        boolean create = value.startsWith("@+");
        boolean isFrameworkId = mPlatformFile || value.startsWith("@android") || value.startsWith("@+android");
        // Look for the idName in project or android R class depending on isPlatform.
        if (create) {
            Integer idValue;
            if (isFrameworkId) {
                idValue = Bridge.getResourceId(ResourceType.ID, idName);
            } else {
                idValue = mContext.getLayoutlibCallback().getResourceId(ResourceType.ID, idName);
            }
            return idValue == null ? defValue : idValue;
        }
        // one is not found.
        if (isFrameworkId) {
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        } else {
            return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
        }
    }
    // not a direct id valid reference? resolve it
    Integer idValue;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getLayoutlibCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue;
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
Body of Second Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    value = value.trim();
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    if (value.startsWith("#")) {
        // this looks like a color, do not try to parse it
        return defValue;
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        boolean create = value.startsWith("@+");
        boolean isFrameworkId = mPlatformFile || value.startsWith("@android") || value.startsWith("@+android");
        // Look for the idName in project or android R class depending on isPlatform.
        if (create) {
            Integer idValue;
            if (isFrameworkId) {
                idValue = Bridge.getResourceId(ResourceType.ID, idName);
            } else {
                idValue = mContext.getLayoutlibCallback().getResourceId(ResourceType.ID, idName);
            }
            return idValue == null ? defValue : idValue;
        }
        // one is not found.
        if (isFrameworkId) {
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        } else {
            return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
        }
    } else if (value.startsWith("@aapt:_aapt")) {
        return mContext.getLayoutlibCallback().getResourceId(ResourceType.AAPT, value);
    }
    // not a direct id valid reference. First check if it's an enum (this is a corner case
    // for attributes that have a reference|enum type), then fallback to resolve
    // as an ID without prefix.
    Integer enumValue = resolveEnumAttribute(index);
    if (enumValue != null) {
        return enumValue;
    }
    // Ok, not an enum, resolve as an ID
    Integer idValue;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getLayoutlibCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue;
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
------------------------
Find a silently evolved API code:android.widget.ActivityChooserView.showPopupUnchecked:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Shows the popup no matter if it was already showing.
 *
 * @param maxActivityCount The max number of activities to display.
 */

Body of Frist Method:
{
    if (mAdapter.getDataModel() == null) {
        throw new IllegalStateException("No data model. Did you call #setDataModel?");
    }
    getViewTreeObserver().addOnGlobalLayoutListener(mOnGlobalLayoutListener);
    final boolean defaultActivityButtonShown = mDefaultActivityButton.getVisibility() == VISIBLE;
    final int activityCount = mAdapter.getActivityCount();
    final int maxActivityCountOffset = defaultActivityButtonShown ? 1 : 0;
    if (maxActivityCount != ActivityChooserViewAdapter.MAX_ACTIVITY_COUNT_UNLIMITED && activityCount > maxActivityCount + maxActivityCountOffset) {
        mAdapter.setShowFooterView(true);
        mAdapter.setMaxActivityCount(maxActivityCount - 1);
    } else {
        mAdapter.setShowFooterView(false);
        mAdapter.setMaxActivityCount(maxActivityCount);
    }
    ListPopupWindow popupWindow = getListPopupWindow();
    if (!popupWindow.isShowing()) {
        if (mIsSelectingDefaultActivity || !defaultActivityButtonShown) {
            mAdapter.setShowDefaultActivity(true, defaultActivityButtonShown);
        } else {
            mAdapter.setShowDefaultActivity(false, false);
        }
        final int contentWidth = Math.min(mAdapter.measureContentWidth(), mListPopupMaxWidth);
        popupWindow.setContentWidth(contentWidth);
        popupWindow.show();
        if (mProvider != null) {
            mProvider.subUiVisibilityChanged(true);
        }
        popupWindow.getListView().setContentDescription(mContext.getString(R.string.activitychooserview_choose_application));
    }
}
Body of Second Method:
{
    if (mAdapter.getDataModel() == null) {
        throw new IllegalStateException("No data model. Did you call #setDataModel?");
    }
    getViewTreeObserver().addOnGlobalLayoutListener(mOnGlobalLayoutListener);
    final boolean defaultActivityButtonShown = mDefaultActivityButton.getVisibility() == VISIBLE;
    final int activityCount = mAdapter.getActivityCount();
    final int maxActivityCountOffset = defaultActivityButtonShown ? 1 : 0;
    if (maxActivityCount != ActivityChooserViewAdapter.MAX_ACTIVITY_COUNT_UNLIMITED && activityCount > maxActivityCount + maxActivityCountOffset) {
        mAdapter.setShowFooterView(true);
        mAdapter.setMaxActivityCount(maxActivityCount - 1);
    } else {
        mAdapter.setShowFooterView(false);
        mAdapter.setMaxActivityCount(maxActivityCount);
    }
    ListPopupWindow popupWindow = getListPopupWindow();
    if (!popupWindow.isShowing()) {
        if (mIsSelectingDefaultActivity || !defaultActivityButtonShown) {
            mAdapter.setShowDefaultActivity(true, defaultActivityButtonShown);
        } else {
            mAdapter.setShowDefaultActivity(false, false);
        }
        final int contentWidth = Math.min(mAdapter.measureContentWidth(), mListPopupMaxWidth);
        popupWindow.setContentWidth(contentWidth);
        popupWindow.show();
        if (mProvider != null) {
            mProvider.subUiVisibilityChanged(true);
        }
        popupWindow.getListView().setContentDescription(mContext.getString(R.string.activitychooserview_choose_application));
        popupWindow.getListView().setSelector(new ColorDrawable(Color.TRANSPARENT));
    }
}
------------------------
Find a silently evolved API code:android.app.backup.BackupManager.requestRestore:COMMENT
Method Modifier: public      
Comment:/**
 * Restore the calling application from backup.  The data will be restored from the
 * current backup dataset if the application has stored data there, or from
 * the dataset used during the last full device setup operation if the current
 * backup dataset has no matching data.  If no backup data exists for this application
 * in either source, a nonzero value will be returned.
 *
 * <p>If this method returns zero (meaning success), the OS will attempt to retrieve
 * a backed-up dataset from the remote transport, instantiate the application's
 * backup agent, and pass the dataset to the agent's
 * {@link android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()}
 * method.
 *
 * @param observer The {@link RestoreObserver} to receive callbacks during the restore
 * operation. This must not be null.
 *
 * @return Zero on success; nonzero on error.
 */

Body of Frist Method:
{
    int result = -1;
    checkServiceBinder();
    if (sService != null) {
        RestoreSession session = null;
        try {
            IRestoreSession binder = sService.beginRestoreSession(mContext.getPackageName(), null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
                result = session.restorePackage(mContext.getPackageName(), observer);
            }
        } catch (RemoteException e) {
            Log.e(TAG, "restoreSelf() unable to contact service");
        } finally {
            if (session != null) {
                session.endRestoreSession();
            }
        }
    }
    return result;
}
Body of Second Method:
{
    return requestRestore(observer, null);
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * @return hash code
 */

Body of Frist Method:
{
    int primeNum = 31;
    return ((mGsmSignalStrength * primeNum) + (mGsmBitErrorRate * primeNum) + (mCdmaDbm * primeNum) + (mCdmaEcio * primeNum) + (mEvdoDbm * primeNum) + (mEvdoEcio * primeNum) + (mEvdoSnr * primeNum) + (mLteSignalStrength * primeNum) + (mLteRsrp * primeNum) + (mLteRsrq * primeNum) + (mLteRssnr * primeNum) + (mLteCqi * primeNum) + (mTdScdmaRscp * primeNum) + (isGsm ? 1 : 0));
}
Body of Second Method:
{
    int primeNum = 31;
    return ((mGsmSignalStrength * primeNum) + (mGsmBitErrorRate * primeNum) + (mCdmaDbm * primeNum) + (mCdmaEcio * primeNum) + (mEvdoDbm * primeNum) + (mEvdoEcio * primeNum) + (mEvdoSnr * primeNum) + (mLteSignalStrength * primeNum) + (mLteRsrp * primeNum) + (mLteRsrq * primeNum) + (mLteRssnr * primeNum) + (mLteCqi * primeNum) + (mLteRsrpBoost * primeNum) + (mTdScdmaRscp * primeNum) + (isGsm ? 1 : 0));
}
------------------------
Find a silently evolved API code:android.security.NetworkSecurityPolicy.handleTrustStorageUpdate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Handle an update to the system or user certificate stores.
 * @hide
 */

Body of Frist Method:
{
    ApplicationConfig.getDefaultInstance().handleTrustStorageUpdate();
}
Body of Second Method:
{
    ApplicationConfig config = ApplicationConfig.getDefaultInstance();
    if (config != null) {
        config.handleTrustStorageUpdate();
    }
}
------------------------

